import * as TinyMCE from 'tinymce';
import * as io from 'socket.io';
import { Socket } from 'socket.io';
import * as smooth from '@pixi/graphics-smooth';
import * as particles from '@pixi/particle-emitter';
import {
  AccessibilityManager,
  AlphaFilter,
  Application as Application$1,
  ALPHA_MODES,
  BLEND_MODES,
  BlurFilter,
  CLEAR_MODES,
  Circle,
  Container,
  DisplayObject,
  Ellipse,
  EventBoundary,
  Extract,
  FederatedEvent,
  FederatedPointerEvent,
  FederatedWheelEvent,
  Filter,
  FilterState,
  FilterSystem,
  FORMATS,
  Geometry,
  Graphics,
  IDestroyOptions,
  ITextStyle,
  Matrix,
  Mesh,
  MIPMAP_MODES,
  MSAA_QUALITY,
  ParticleContainer,
  ParticleRenderer,
  Point as Point$1,
  Polygon,
  Prepare,
  Program,
  Rectangle as Rectangle$1,
  RenderTexture,
  Renderer,
  RoundedRectangle,
  SCALE_MODES,
  Shader,
  Sprite,
  Spritesheet,
  Text as Text$1,
  TextStyle,
  Texture,
  TilingSpriteRenderer,
  Transform as Transform$1,
  UniformGroup,
  utils,
} from 'pixi.js';
import * as State from 'prosemirror-state';
import * as Transform from 'prosemirror-transform';
import * as View from 'prosemirror-view';

declare global {
  interface ActiveEffectConfigOptions extends DocumentSheetOptions {
    classes: string[];
    title: string;
    template: string;
    width: number;
    height: string;
    tabs: [
      {
        navSelector: '.tabs';
        contentSelector: 'form';
        initial: 'details';
      },
    ];
  }

  interface ActiveEffectConfigData<TDocument extends ActiveEffect<Actor | Item | null>>
    extends DocumentSheetData<TDocument> {
    effect: TDocument;
    isActorEffect: boolean;
    isItemEffect: boolean;
    submitText: string;
    modes: Record<number, string>;
  }

  class ActiveEffectConfig<TDocument extends ActiveEffect<Actor | Item | null>> extends DocumentSheet<TDocument> {
    static override get defaultOptions(): ActiveEffectConfigOptions;

    override getData(options?: DocumentSheetOptions): ActiveEffectConfigData<TDocument>;

    /**
     * Provide centralized handling of mouse clicks on control buttons.
     * Delegate responsibility out to action-specific handlers depending on the button action.
     * @param event The originating click event
     */
    protected _onEffectControl(event: Event): void;

    /**
     * Handle adding a new change to the changes array.
     * @param button    The clicked action button
     */
    private _addEffectChange(button: HTMLElement): HTMLElement;

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;
  }
}

declare global {
  /**
   * The Application responsible for displaying and editing a single Actor document.
   * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
   * @category - Applications
   * @param actor     The Actor instance being displayed within the sheet.
   * @param [options] Additional application configuration options.
   */
  class ActorSheet<TActor extends Actor, TItem extends Item = Item> extends DocumentSheet<TActor, ActorSheetOptions> {
    static override get defaultOptions(): ActorSheetOptions;

    override get id(): string;

    override get title(): string;

    /** A convenience reference to the Actor document */
    get actor(): TActor;

    /** If this Actor Sheet represents a synthetic Token actor, reference the active Token */
    get token(): TActor['parent'];

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override close(options?: { force?: boolean }): Promise<void>;

    override getData(options?: ActorSheetOptions): ActorSheetData<TActor> | Promise<ActorSheetData<TActor>>;

    protected override _getHeaderButtons(): ApplicationHeaderButton[];

    protected override _getSubmitData(updateData?: Record<string, unknown>): Record<string, unknown>;

    /* -------------------------------------------- */
    /*  Event Listeners                             */
    /* -------------------------------------------- */

    /** Handle requests to configure the prototype Token for the Actor */
    protected _onConfigureToken(event: Event): void;

    /**
     * Handle requests to configure the default sheet used by this Actor
     */
    protected _onConfigureSheet(event: Event): void;

    /**
     * Handle changing the actor profile image by opening a FilePicker
     */
    protected _onEditImage(event: Event): void;

    /* -------------------------------------------- */
    /*  Drag and Drop                               */
    /* -------------------------------------------- */

    protected override _canDragStart(selector: string): boolean;

    protected override _canDragDrop(selector: string): boolean;

    protected override _onDragStart(event: DragEvent): void;

    protected override _onDrop(event: DragEvent): Promise<boolean | void>;

    protected override _onDragOver(event: DragEvent): boolean;

    /**
     * Handle dropping of an Actor data onto another Actor sheet
     * @param event The concluding DragEvent which contains drop data
     * @param data The data transfer extracted from the event
     * @return A data object which describes the result of the drop
     */
    protected _onDropActiveEffect<TDocument extends ActiveEffect<TActor>>(
      event: DragEvent,
      data?: DropCanvasData<'ActiveEffect', TDocument>,
    ): Promise<TDocument | void>;

    /**
     * Handle dropping of an Actor data onto another Actor sheet
     * @param event The concluding DragEvent which contains drop data
     * @param data  The data transfer extracted from the event
     * @return A data object which describes the result of the drop
     */
    protected _onDropActor(event: DragEvent, data: DropCanvasData<'Actor', TActor>): Promise<false | void>;

    /**
     * Handle dropping of an item reference or item data onto an Actor Sheet
     * @param event The concluding DragEvent which contains drop data
     * @param data  The data transfer extracted from the event
     * @return A data object which describes the result of the drop
     */
    protected _onDropItem(event: DragEvent, data: DropCanvasData<'Item', TItem>): Promise<TItem[]>;

    /**
     * Handle dropping of a Folder on an Actor Sheet.
     * Currently supports dropping a Folder of Items to create all items as owned items.
     * @param event The concluding DragEvent which contains drop data
     * @param data  The data transfer extracted from the event
     * @return A data object which describes the result of the drop
     */
    protected _onDropFolder(event: DragEvent, data: DropCanvasData<'Folder', Folder>): Promise<TItem[]>;

    /**
     * Handle the final creation of dropped Item data on the Actor.
     * This method is factored out to allow downstream classes the opportunity to override item creation behavior.
     * @param itemData The item data requested for creation
     */
    protected _onDropItemCreate(
      itemData: foundry.documents.ItemSource | foundry.documents.ItemSource[],
    ): Promise<Item<TActor>[]>;

    /** Handle a drop event for an existing embedded Item to sort that Item relative to its siblings */
    protected _onSortItem(event: DragEvent, itemData: TItem['_source']): Promise<TItem[]>;
  }

  interface ActorSheetOptions extends DocumentSheetOptions {
    token: TokenDocument | null;
  }

  interface ActorSheetData<TActor extends Actor> extends DocumentSheetData<TActor> {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    actor: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    data: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    items: any;
    cssClass: 'editable' | 'locked';
    effects: RawObject<ActiveEffect<TActor>>[];
    limited: boolean;
    options: Partial<ActorSheetOptions>;
  }
}

declare global {
  /**
   * The Application responsible for displaying and editing a single JournalEntryPage document.
   * @param object    The JournalEntryPage instance which is being edited.
   * @param [options] Application options.
   */
  class JournalPageSheet<TDocument extends JournalEntryPage<JournalEntry | null>> extends DocumentSheet<TDocument> {
    /** The table of contents for this JournalTextPageSheet. */
    toc: Record<string, JournalEntryPageHeading>;

    static override get defaultOptions(): DocumentSheetOptions;

    override get template(): string;

    override get title(): string;

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    override getData(
      options?: Partial<DocumentSheetOptions> | undefined,
    ): DocumentSheetData<TDocument> | Promise<DocumentSheetData<TDocument>>;

    protected override _renderInner(
      data: FormApplicationData<TDocument>,
      options: RenderOptions,
    ): Promise<JQuery<HTMLElement>>;

    /* -------------------------------------------- */
    /*  Text Secrets Management                     */
    /* -------------------------------------------- */

    protected override _getSecretContent(secret: HTMLElement): string;

    protected override _updateSecret(secret: HTMLElement, content: string): Promise<TDocument>;

    /* -------------------------------------------- */
    /*  Text Editor Integration                     */
    /* -------------------------------------------- */

    override activateEditor(
      name: string,
      options?: EditorCreateOptions | undefined,
      initialContent?: string | undefined,
    ): Promise<TinyMCE.Editor | ProseMirror.EditorView>;

    /**
     * Update the parent sheet if it is open when the server autosaves the contents of this editor.
     * @param html The updated editor contents.
     */
    onAutosave(html: string): void;

    /** Update the UI appropriately when receiving new steps from another client. */
    onNewSteps(): void;
  }

  /** The Application responsible for displaying and editing a single JournalEntryPage image document. */
  class JournalImagePageSheet<
    TDocument extends JournalEntryPage<JournalEntry | null>,
  > extends JournalPageSheet<TDocument> {
    static override get defaultOptions(): DocumentSheetOptions;
  }

  class JournalTextPageSheet<
    TDocument extends JournalEntryPage<JournalEntry | null>,
  > extends JournalPageSheet<TDocument> {
    /** Bi-directional HTML <-> Markdown converter. */
    protected static _converter: object;

    /**
     * Declare the format that we edit text content in for this sheet so we can perform conversions as necessary.
     */
    static get format(): number;

    static override get defaultOptions(): DocumentSheetOptions;

    override getData(options?: Partial<DocumentSheetOptions>): Promise<DocumentSheetData<TDocument>>;

    override close(options?: { force?: boolean }): Promise<void>;

    protected override _render(force: boolean, options: RenderOptions): Promise<void>;

    /** Determine if any editors are dirty. */
    isEditorDirty(): boolean;

    protected _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;

    /**
     * Lazily convert text formats if we detect the document being saved in a different format.
     * @param renderData Render data.
     */
    protected _convertFormats(renderData?: Record<string, unknown>): void;
  }

  class JournalTextTinyMCESheet<
    TDocument extends JournalEntryPage<JournalEntry | null>,
  > extends JournalTextPageSheet<TDocument> {
    override getData(options?: DocumentSheetOptions): Promise<DocumentSheetData<TDocument>>;

    override close(options?: { force?: boolean }): Promise<void>;

    protected override _render(force?: boolean, options?: RenderOptions): Promise<void>;
  }

  interface JournalTextTinyMCESheet<TDocument extends JournalEntryPage<JournalEntry | null>>
    extends JournalTextPageSheet<TDocument> {
    activateEditor(
      name: string,
      options?: Partial<TinyMCE.EditorOptions>,
      initialContent?: string,
    ): Promise<TinyMCE.Editor>;
  }
}

declare global {
  /**
   * The Application responsible for configuring a single User document.
   * @extends {DocumentSheet}
   *
   * @param user      The User document being configured.
   * @param [options] Additional rendering options which modify the behavior of the form.
   */
  class UserConfig<TUser extends User> extends DocumentSheet<TUser> {
    static override get defaultOptions(): DocumentSheetOptions;

    override get title(): string;

    override getData(options: DocumentSheetOptions): Promise<UserConfigData<TUser>>;

    override activateListeners(html: JQuery): void;

    /** Handle changing the user avatar image by opening a FilePicker */
    protected _onEditAvatar(event: JQuery.TriggeredEvent): void;
  }

  interface UserConfigData<TUser extends User> extends DocumentSheetData<TUser> {
    user: User;
    actors: Actor<null>[];
  }
}

declare global {
  /**
   * The Application responsible for configuring a single Wall document within a parent Scene.
   * @param object    The Wall object for which settings are being configured
   * @param [options] Additional options which configure the rendering of the configuration sheet.
   */
  class WallConfig<TDocument extends WallDocument<Scene | null>> extends DocumentSheet<TDocument, WallConfigOptions> {
    static override get defaultOptions(): WallConfigOptions;

    override get title(): string;

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;
  }

  interface WallConfigOptions extends DocumentSheetOptions {
    id: 'wall-config';
    editTargets: WallDocument<Scene | null>[];
  }
}

declare global {
  interface DocumentSheetConfigData<TDocument extends foundry.abstract.Document>
    extends FormApplicationData<TDocument> {
    isGM: boolean;
    object: TDocument;
    options: FormApplicationOptions;
    sheetClass: string;
    sheetClasses: Record<string, string>;
    defaultClass: string;
    blankLabel: string;
  }

  interface RegisterSheetOptions {
    label?: string | (() => string);
    types?: string[];
    makeDefault?: boolean;
    canBeDefault?: boolean;
  }

  /** Document Sheet Configuration Application */
  class DocumentSheetConfig<TDocument extends foundry.abstract.Document> extends FormApplication<TDocument> {
    static override get defaultOptions(): FormApplicationOptions;

    /** An array of pending sheet assignments which are submitted before other elements of the framework are ready. */
    protected static _pending: object[];

    override get title(): string;

    override getData(
      options?: Partial<FormApplicationOptions>,
    ): DocumentSheetConfigData<TDocument> | Promise<DocumentSheetConfigData<TDocument>>;

    protected override _updateObject(event: Event, formData: FormApplicationData): Promise<void>;

    /* -------------------------------------------- */
    /*  Configuration Methods                       */
    /* -------------------------------------------- */

    /**
     * Initialize the configured Sheet preferences for Documents which support dynamic Sheet assignment
     * Create the configuration structure for supported documents
     * Process any pending sheet registrations
     * Update the default values from settings data
     */
    static initializeSheets(): void;

    protected static _getDocumentTypes(cls: foundry.abstract.Document, types?: string[]): string[];

    /**
     * Register a sheet class as a candidate which can be used to display documents of a given type
     * @param documentClass         The Document class for which to register a new Sheet option
     * @param scope                 Provide a unique namespace scope for this sheet
     * @param sheetClass            A defined Application class used to render the sheet
     * @param options               Additional options used for sheet registration
     * @param [options.label]       A human readable label for the sheet name, which will be localized
     * @param [options.types]       An array of document types for which this sheet should be used
     * @param [options.makeDefault] Whether to make this sheet the default for provided types
     */
    static registerSheet<T extends foundry.abstract.Document & { get sheet(): FormApplication<T> }>(
      documentClass: ConstructorOf<T>,
      scope: string,
      sheetClass: ConstructorOf<T['sheet']>,
      options?: RegisterSheetOptions,
    ): void;

    /** Perform the sheet registration */
    protected static _registerSheet(options: unknown): void;

    /**
     * Unregister a sheet class, removing it from the list of available Applications to use for a Document type
     * @param documentClass  The Document class for which to register a new Sheet option
     * @param scope            Provide a unique namespace scope for this sheet
     * @param sheetClass  A defined Application class used to render the sheet
     * @param types             An Array of types for which this sheet should be removed
     */
    static unregisterSheet<T extends foundry.abstract.Document & { get sheet(): FormApplication<T> }>(
      documentClass: ConstructorOf<T>,
      scope: string,
      sheetClass: ConstructorOf<T['sheet']>,
      options?: { types: string[] },
    ): void;

    /** Perform the sheet de-registration */
    protected static _unregisterSheet(options: {
      documentClass: typeof foundry.abstract.Document;
      id: string;
      types: string[];
    }): void;

    /** Update the currently default Sheets using a new core world setting */
    static updateDefaultSheets(setting: object): void;
  }
}

declare global {
  /**
   * An Image Popout Application which features a single image in a lightbox style frame.
   * This popout can also be used as a form, allowing the user to edit an image which is being used.
   * Furthermore, this application allows for sharing the display of an image with other connected players.
   * @param src The image URL.
   * @param [options] Application configuration options.
   * @example
   * // Construct the Application instance
   * const ip = new ImagePopout("path/to/image.jpg", {
   *   title: "My Featured Image",
   *   shareable: true,
   *   uuid: game.actors.getName("My Hero").uuid
   * });
   *
   * // Display the image popout
   * ip.render(true);
   *
   * // Share the image with other connected players
   * ip.share();
   */
  class ImagePopout<TDocument extends foundry.abstract.Document> extends FormApplication<
    TDocument,
    ImagePopoutOptions
  > {
    constructor(src: string, options?: Partial<ImagePopoutOptions>);

    static override get defaultOptions(): ImagePopoutOptions;

    override get title(): string;

    override getData(options?: Partial<ImagePopoutOptions>): Promise<{
      image: TDocument;
      options: Partial<ImagePopoutOptions>;
      title: string;
      showTitle: boolean;
    }>;

    /** Provide a reference to the Document referenced by this popout, if one exists */
    getRelatedObject(): Promise<TDocument | null>;

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;
  }

  interface ImagePopoutOptions extends FormApplicationOptions {
    template: string;
    classes: string[];
    editable: boolean;
    resizable: boolean;
    /** Can this image be shared with connected users? */
    shareable: boolean;
    /** The UUID of some related  */
    uuid: DocumentUUID | null;
  }
}

declare global {
  /**
   * The global action bar displayed at the bottom of the game view.
   * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
   * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
   *
   * Left clicking a Macro button triggers its effect.
   * Right clicking the button displays a context menu of Macro options.
   * The number keys 1 through 0 activate numbered hotbar slots.
   * Pressing the delete key while hovering over a Macro will remove it from the bar.
   *
   * @extends {Application}
   *
   * @see {@link Macros}
   * @see {@link Macro}
   */
  class Hotbar<TMacro extends Macro = Macro> extends Application {
    constructor(options: ApplicationOptions);

    /** The currently viewed macro page */
    page: number;

    /** The currently displayed set of macros */
    macros: TMacro[];

    /** Track collapsed state */
    protected _collapsed: false;

    /** Track which hotbar slot is the current hover target, if any */
    protected _hover: number | null;

    static override get defaultOptions(): ApplicationOptions;

    override getData(options?: {}): {
      page: number;
      macros: TMacro[];
      barClass: string;
    };

    /**
     * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
     * @param page
     */
    protected _getMacrosByPage(page: number): TMacro[];

    /**
     * Collapse the Hotbar, minimizing its display.
     * @return A promise which resolves once the collapse animation completes
     */
    collapse(): Promise<void>;

    /**
     * Expand the Hotbar, displaying it normally.
     * @return A promise which resolves once the expand animation completes
     */
    expand(): Promise<void>;

    /**
     * Change to a specific numbered page from 1 to 5
     * @param page The page number to change to.
     */
    changePage(page: number): void;

    /**
     * Change the page of the hotbar by cycling up (positive) or down (negative)
     * @param direction The direction to cycle
     */
    cyclePage(direction: number): void;

    override activateListeners(html: JQuery): void;

    /**
     * Create a Context Menu attached to each Macro button
     * @param html
     */
    protected _contextMenu(html: JQuery): void;

    /** Get the Macro entry context options */
    protected _getEntryContextOptions(): EntryContextOption[];

    /** Handle left-click events to */
    protected _onClickMacro(event: MouseEvent): Promise<void>;

    /**
     * Handle hover events on a macro button to track which slot is the hover target
     * @param event The originating mouseover or mouseleave event
     */
    protected _onHoverMacro(event: MouseEvent): void;

    /**
     * Handle pagination controls
     * @param event   The originating click event
     */
    protected _onClickPageControl(event: MouseEvent): void;

    protected override _canDragStart(selector: string): boolean;

    protected override _onDragStart(event: DragEvent): void;

    protected override _canDragDrop(selector: string): boolean;

    protected override _onDrop(event: DragEvent): Promise<void>;

    /**
     * Get the Macro entity being dropped in the Hotbar. If the data comes from a non-World source, create the Macro
     * @param data The data transfer attached to the DragEvent
     * @return A Promise which returns the dropped Macro, or null
     */
    protected _getDropMacro(data: unknown): Promise<TMacro | null>;

    /**
     * Handle click events to toggle display of the macro bar
     * @param event
     */
    protected _onToggleBar(event: Event): void;
  }
}

declare global {
  /**
   * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
   * @todo Fill in
   */
  abstract class BasePlaceableHUD<TPlaceableObject extends PlaceableObject> extends Application {
    /**
     * Reference a PlaceableObject this HUD is currently bound to
     */
    object: TPlaceableObject;

    constructor(...args: ConstructorParameters<typeof Application>);

    /**
     * Bind the HUD to a new PlaceableObject and display it
     * @param object A PlaceableObject instance to which the HUD should be bound
     */
    bind(object: TPlaceableObject): void;

    override getData(): BasePlaceableHUDData<TPlaceableObject>;

    /**
     * Clear the HUD by fading out it's active HTML and recording the new display state
     */
    clear(): void;
  }

  type BasePlaceableHUDData<T extends PlaceableObject> = T['document']['_source'] & {
    id: string;
    classes: string;
    appId: number;
    isGM: boolean;
    icons: ControlIconsConfig;
  };
}

declare global {
  /**
   * The UI element which displays the list of Users who are currently playing within the active World.
   */
  class PlayerList extends Application {
    constructor(options: ApplicationOptions);

    /** An internal toggle for whether to show offline players or hide them */
    protected _showOffline: boolean;

    static override get defaultOptions(): ApplicationOptions;

    /* -------------------------------------------- */
    /*  Application Rendering                       */
    /* -------------------------------------------- */

    override render(force?: boolean, options?: RenderOptions): this;

    override getData(options: ApplicationOptions): PlayerListData;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    override activateListeners(html: JQuery): void;

    /** Return the default context options available for the Players application */
    protected _getUserContextOptions(): ContextMenuEntry[];

    /**
     * Toggle display of the Players hud setting for whether or not to display offline players
     * @param event The originating click event
     */
    protected _onToggleOfflinePlayers(event: Event): void;
  }
}

interface PlayerListData {
  users: UserTemplateData[];
  hide: boolean;
  showOffline: boolean;
}

interface UserTemplateData {
  active: boolean;
  isGM: boolean;
  isSelf: boolean;
  charname: string;
  color: HexColorString;
  border: HexColorString;
}

declare global {
  /** Render the Sidebar container, and after rendering insert Sidebar tabs. */
  abstract class SidebarTab<TOptions extends ApplicationOptions = ApplicationOptions> extends Application<TOptions> {
    constructor(options?: DeepPartial<TOptions>);

    /** The base name of this sidebar tab */
    tabName: string;

    /** A reference to the pop-out variant of this SidebarTab, if one exists */
    protected _popout: this;

    /**
     * Denote whether or not this is the original version of the sidebar tab, or a pop-out variant
     */
    protected _original: this;

    /**
     * Get the set of ContextMenu options which should be used for Entities in a SidebarDirectory
     * @return The Array of context options passed to the ContextMenu instance
     */
    protected _getEntryContextOptions(): EntryContextOption[];

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /** Activate this SidebarTab, switching focus to it */
    activate(): void;

    override close(options?: { force?: boolean }): Promise<void>;

    /** Render the SidebarTab as a pop-out container */
    renderPopout(...args: unknown[]): void;
  }

  type ContextOptionCondition = (li: JQuery) => boolean;

  interface EntryContextOption {
    name: string;
    icon: string;
    condition: ContextOptionCondition;
    callback: (li: JQuery) => void;
  }
}

declare global {
  /** The sidebar directory which organizes and displays world-level Actor documents. */
  class ActorDirectory<TActor extends Actor<null>> extends DocumentDirectory<TActor> {
    constructor(options: SidebarDirectoryOptions);

    static override documentName: 'Actor';

    protected override _canDragStart(selector: string): boolean;

    protected override _onDragStart(event: DragEvent): void;

    protected override _canDragDrop(selector: string): boolean;

    protected override _getEntryContextOptions(): EntryContextOption[];
  }
}

declare global {
  /** A shared pattern for the sidebar directory which Actors, Items, and Scenes all use */
  class DocumentDirectory<TDocument extends WorldDocument> extends SidebarTab<SidebarDirectoryOptions> {
    /** References to the set of Documents that are displayed in the Sidebar */
    documents: TDocument[];

    /** Reference the set of Folders which exist in this Sidebar */
    folders: Folder[];

    /** A reference to the named Document type that this Sidebar Directory instance displays */
    static documentName: string;

    /** The path to the template partial which renders a single Entry within this directory */
    static entryPartial: string;

    /** The path to the template partial which renders a single Folder within this directory */
    static folderPartial: string;

    static override get defaultOptions(): SidebarDirectoryOptions;

    /** The WorldCollection instance which this Sidebar Directory displays. */
    static get collection(): WorldCollection<WorldDocument>;

    /** Initialize the content of the directory by categorizing folders and documents into a hierarchical tree structure. */
    initialize(): void;

    /**
     * Given a Document type and a list of Document instances, set up the Folder tree
     * @param folders   The Array of Folder objects to organize
     * @param documents The Array of Document objects to organize
     * @return A tree structure containing the folders and documents
     */
    static setupFolders(
      folders: Folder[],
      documents: WorldDocument[],
    ): { root: boolean; content: WorldDocument[]; children: Folder[] };

    /**
     * Populate a single folder with child folders and content
     * This method is called recursively when building the folder tree
     */
    protected static _populate(
      folder: Folder,
      folders: Folder[],
      documents: WorldDocument[],
      { allowChildren }?: { allowChildren?: boolean },
    ): [Folder[], WorldDocument[]];

    /**
     * Sort two Documents by name, alphabetically.
     * @return A value > 0 if b should be sorted before a.
     *         A value < 0 if a should be sorted before b.
     *         0 if the position of a and b should not change.
     */
    protected static _sortAlphabetical(a: WorldDocument, b: WorldDocument): number;

    protected override _render(force?: boolean, context?: SidebarDirectoryRenderOptions): Promise<void>;

    protected override _renderInner(data: object): Promise<JQuery>;

    protected override _onSearchFilter(event: KeyboardEvent, query: string, rgx: RegExp, html: HTMLElement): void;

    /** Highlight folders as drop targets when a drag event enters or exits their area */
    protected _onDragHighlight(event: DragEvent): void;

    /** Collapse all subfolders in this directory */
    collapseAll(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /** Activate event listeners triggered within the Actor Directory HTML */
    override activateListeners(html: JQuery): void;

    /**
     * Handle Entry data being dropped into the directory.
     * @param target The target element
     * @param data   The data being dropped
     */
    protected _handleDroppedEntry(target: HTMLElement, data: DropCanvasData): Promise<void>;

    /**
     * Handle Folder data being dropped into the directory.
     * @param target The target element
     * @param data   The data being dropped
     */
    protected _handleDroppedFolder(target: HTMLElement, data: DropCanvasData): Promise<void>;

    /**
     * Default folder context actions
     * @param html The context menu HTML being rendered for the directory
     */
    protected _contextMenu(html: JQuery): void;
  }

  interface SidebarDirectoryOptions extends ApplicationOptions {
    /**
     * A list of data property keys that will trigger a re-render of the tab if they are updated on a Document that
     * this tab is responsible for.
     */
    renderUpdateKeys: string[];
    /** The CSS selector that activates the context menu for displayed Documents. */
    contextMenuSelector: string;
  }

  interface SidebarDirectoryRenderOptions extends RenderOptions {
    documentType?: string;
    data?: Record<string, unknown>[];
  }
}

declare global {
  /** The sidebar directory which organizes and displays world-level Item documents. */
  class ItemDirectory<TItem extends Item<null>> extends DocumentDirectory<TItem> {
    static override documentName: 'Item';

    protected override _canDragDrop(selector: string): boolean;

    protected override _getEntryContextOptions(): EntryContextOption[];
  }
}

declare global {
  /** The standard application window that is rendered for a large variety of UI elements in Foundry VTT */
  class Application<TOptions extends ApplicationOptions = ApplicationOptions> {
    constructor(options?: Partial<TOptions>);

    /** The options provided to this application upon initialization */
    options: TOptions;

    /**
     * The application ID is a unique incrementing integer which is used to identify every application window
     * drawn by the VTT
     */
    appId: number;

    /** Track the current position and dimensions of the Application UI */
    position: ApplicationPosition;

    /** An internal reference to the HTML element this application renders */
    protected _element: JQuery;

    /** DragDrop workflow handlers which are active for this Application */
    protected _dragDrop: DragDrop[];

    /** Tab navigation handlers which are active for this Application */
    protected _tabs: Tabs[];

    /** SearchFilter handlers which are active for this Application */
    protected _searchFilters: SearchFilter[];

    /** Track whether the Application is currently minimized */
    _minimized: boolean;

    /**
     * Track the render state of the Application
     * @see {Application.RENDER_STATES}
     */
    _state: ApplicationRenderState;

    /** Track the most recent scroll positions for any vertically scrolling containers */
    protected _scrollPositions: Record<string, unknown> | null;

    static readonly RENDER_STATES: {
      CLOSING: -2;
      CLOSED: -1;
      NONE: 0;
      RENDERING: 1;
      RENDERED: 2;
      ERROR: 3;
    };

    /**
     * Create drag-and-drop workflow handlers for this Application
     * @return An array of DragDrop handlers
     */
    protected _createDragDropHandlers(): DragDrop[];

    /**
     * Create tabbed navigation handlers for this Application
     * @return An array of Tabs handlers
     */
    protected _createTabHandlers(): Tabs[];

    /**
     * Assign the default options which are supported by all Application classes.
     * Application subclasses may include additional options which are specific to their usage.
     * All keys are optional, descriptions and default values are listed below:
     */
    static get defaultOptions(): ApplicationOptions;

    /**
     * Return the CSS application ID which uniquely references this UI element
     */
    get id(): string;

    /**
     * Return the active application element, if it currently exists in the DOM
     */
    get element(): JQuery;

    /**
     * The path to the HTML template file which should be used to render the inner content of the app
     */
    get template(): string;

    /**
     * Control the rendering style of the application. If popOut is true, the application is rendered in its own
     * wrapper window, otherwise only the inner app content is rendered
     */
    get popOut(): boolean;

    /**
     * Return a flag for whether the Application instance is currently rendered
     */
    get rendered(): boolean;

    /**
     * An Application window should define its own title definition logic which may be dynamic depending on its data
     */
    get title(): string;

    /* -------------------------------------------- */
    /* Application rendering                        */
    /* -------------------------------------------- */

    /**
     * An application should define the data object used to render its template.
     * This function may either return an Object directly, or a Promise which resolves to an Object
     * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
     */
    getData(options?: Partial<ApplicationOptions>): object | Promise<object>;

    /**
     * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
     * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
     *
     * @param force   Add the rendered application to the DOM if it is not already present. If false, the
     *                Application will only be re-rendered if it is already present.
     * @param options Additional rendering options which are applied to customize the way that the Application
     *                is rendered in the DOM.
     * @returns The rendered Application instance
     */
    render(force?: boolean, options?: RenderOptions): this;

    /**
     * An asynchronous inner function which handles the rendering of the Application
     * @param force   Render and display the application even if it is not currently displayed.
     * @param options Provided rendering options, see the render function for details
     * @return A Promise that resolves to the Application once rendering is complete
     */
    protected _render(force?: boolean, options?: RenderOptions): Promise<void>;

    /**
     * Persist the scroll positions of containers within the app before re-rendering the content
     */
    protected _saveScrollPositions(html: HTMLElement | JQuery): void;

    /**
     * Restore the scroll positions of containers within the app after re-rendering the content
     */
    protected _restoreScrollPositions(html: HTMLElement | JQuery): void;

    /**
     * Render the outer application wrapper
     * @return  A promise resolving to the constructed jQuery object
     */
    protected _renderOuter(options: RenderOptions): Promise<JQuery>;

    /**
     * Render the inner application content
     * @param data  The data used to render the inner template
     * @return      A promise resolving to the constructed jQuery object
     */
    protected _renderInner(data: object, options: RenderOptions): Promise<JQuery>;

    /**
     * Customize how inner HTML is replaced when the application is refreshed
     * @param element   The original HTML element
     * @param html      New updated HTML
     */
    protected _replaceHTML(element: JQuery, html: JQuery | HTMLElement, options: Record<string, unknown>): void;

    /**
     * Customize how a new HTML Application is added and first appears in the DOC
     */
    protected _injectHTML(html: JQuery): void;

    /**
     * Specify the set of config buttons which should appear in the Application header.
     * Buttons should be returned as an Array of objects.
     * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
     * @fires Application#hook:getApplicationHeaderButtons
     */
    protected _getHeaderButtons(): ApplicationHeaderButton[];

    /* -------------------------------------------- */
    /* Event Listeners and Handlers                 */
    /* -------------------------------------------- */

    /**
     * Activate required listeners which must be enabled on every Application.
     * These are internal interactions which should not be overridden by downstream subclasses.
     */
    protected _activateCoreListeners(html: JQuery): void;

    /**
     * After rendering, activate event listeners which provide interactivity for the Application.
     * This is where user-defined Application subclasses should attach their event-handling logic.
     */
    activateListeners(html: JQuery): void;

    /**
     * Handle changes to the active tab in a configured Tabs controller
     * @param event     A left click event
     * @param tabs      The TabsV2 controller
     * @param active    The new active tab name
     */
    protected _onChangeTab(event: MouseEvent, tabs: Tabs, active: string): void;

    /**
     * Handle changes to search filtering controllers which are bound to the Application
     * @param event The key-up event from keyboard input
     * @param query The raw string input to the search field
     * @param rgx   The regular expression to test against
     * @param html  The HTML element which should be filtered
     */
    protected _onSearchFilter(event: KeyboardEvent, query: string, rgx: RegExp, html: HTMLElement | null): void;

    /**
     * Define whether a user is able to begin a dragstart workflow for a given drag selector
     * @param selector  The candidate HTML selector for dragging
     * @return Can the current user drag this selector?
     */
    protected _canDragStart(selector: string): boolean;

    /**
     * Define whether a user is able to conclude a drag-and-drop workflow for a given drop selector
     * @param selector  The candidate HTML selector for the drop target
     * @return Can the current user drop on this selector?
     */
    protected _canDragDrop(selector: string): boolean;

    /**
     * Callback actions which occur at the beginning of a drag start workflow.
     * @param event The originating DragEvent
     */
    protected _onDragStart(event: DragEvent): void;

    /**
     * Callback actions which occur when a dragged element is over a drop target.
     * @param event The originating DragEvent
     */
    protected _onDragOver(event: DragEvent): void;

    /**
     * Callback actions which occur when a dragged element is dropped on a target.
     * @param event The originating DragEvent
     */
    protected _onDrop(event: DragEvent): void;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Close the application and un-register references to it within UI mappings
     * This function returns a Promise which resolves once the window closing animation concludes
     * @fires closeApplication
     * @param options Options which affect how the Application is closed
     * @returns A Promise which resolves once the application is closed
     */
    close(options?: { force?: boolean }): Promise<void>;

    /**
     * Minimize the pop-out window, collapsing it to a small tab
     * Take no action for applications which are not of the pop-out variety or apps which are already minimized
     * @return  A Promise which resolves to true once the minimization action has completed
     */
    minimize(): Promise<boolean>;

    /**
     * Maximize the pop-out window, expanding it to its original size
     * Take no action for applications which are not of the pop-out variety or are already maximized
     * @return  A Promise which resolves to true once the maximization action has completed
     */
    maximize(): Promise<boolean>;

    /**
     * Bring the application to the top of the rendering stack
     */
    bringToTop(): void;

    /**
     * Set the application position and store it's new location
     */
    setPosition({ left, top, width, height, scale }?: ApplicationPosition): ApplicationPosition | undefined;

    /**
     * Handle application minimization behavior - collapsing content and reducing the size of the header
     */
    protected _onToggleMinimize(ev: Event | JQuery.Event): void;

    /**
     * Additional actions to take when the application window is resized
     */
    protected _onResize(event: Event | JQuery.Event): void;
  }

  interface ApplicationOptions {
    /** A named "base application" which generates an additional hook */
    baseApplication: string | null;
    /** The default pixel width for the rendered HTML */
    width: number | string | null;
    /** The default pixel height for the rendered HTML */
    height: number | string | null;
    /** The default offset-top position for the rendered HTML */
    top: number | null;
    /** The default offset-left position for the rendered HTML */
    left: number | null;
    /** A transformation scale for the rendered HTML */
    scale?: number | null;
    /** Whether to display the application as a pop-out container */
    popOut: boolean;
    /** Whether the rendered application can be minimized (popOut only) */
    minimizable: boolean;
    /** Whether the rendered application can be drag-resized (popOut only) */
    resizable: boolean | null;
    /** The default CSS id to assign to the rendered HTML */
    id: string;
    /** An array of CSS string classes to apply to the rendered HTML */
    classes: string[];
    /** Track Tab navigation handlers which are active for this Application */
    tabs: TabsOptions[];
    dragDrop: {
      callbacks?: {
        dragover?: Function;
        dragstart?: Function;
        drop?: Function;
      };
      dragSelector?: Maybe<string>;
      dropSelector?: Maybe<string>;
    }[];
    /** A default window title string (popOut only) */
    title: string;
    /** The default HTML template path to render for this Application */
    template: string | null;
    /**
     * A list of unique CSS selectors which target containers that should
     * have their vertical scroll positions preserved during a re-render.
     */
    scrollY: string[];
    /** filters An array of {@link SearchFilter} configuration objects. */
    filters: SearchFilterConfiguration[];
  }

  /** Options which customize the behavior of the filter */
  interface SearchFilterConfiguration {
    /** The CSS selector used to target the text input element. */
    inputSelector: string;
    /** The CSS selector used to target the content container for these tabs. */
    contentSelector: string;
    /** A callback function which executes when the filter changes. */
    callback?: Function;
    /** The initial value of the search query. */
    initial?: string;
    /** The number of milliseconds to wait for text input before processing. */
    delay?: number;
  }

  interface ApplicationHeaderButton {
    label: string;
    class: string;
    icon: string;
    onclick: ((event: Event) => void) | null;
  }

  interface RenderOptions extends Partial<ApplicationOptions> {
    /** The left positioning attribute */
    left?: number;
    /** The top positioning attribute */
    top?: number;
    /** The rendered width */
    width?: number;
    /** The rendered height */
    height?: number;
    /** The rendered transformation scale */
    scale?: number;
    /** Apply focus to the application, maximizing it and bringing it to the top of the vertical stack. */
    focus?: boolean;
    /** A context-providing string which suggests what event triggered the render */
    renderContext?: string;
    /** The data change which motivated the render request */
    renderData?: Record<string, unknown>;
    // Undocumented
    action?: UserAction;
    // Undocumented: applicable only to `FormApplication`s
    editable?: boolean;
  }

  interface ApplicationPosition {
    width?: Maybe<number>;
    height?: Maybe<string | number>;
    left?: Maybe<number>;
    top?: Maybe<number>;
    scale?: Maybe<number>;
    zIndex?: Maybe<number>;
  }

  type ApplicationRenderState = (typeof Application)['RENDER_STATES'][keyof (typeof Application)['RENDER_STATES']];
}

declare global {
  /**
   * An abstract pattern for defining an Application responsible for updating some object using an HTML form
   *
   * A few critical assumptions:
   * 1) This application is used to only edit one object at a time
   * 2) The template used contains one (and only one) HTML <form> as it's outer-most element
   * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
   *
   * @param object    Some object or entity which is the target to be updated.
   *
   * @param options   Additional options which modify the rendering of the sheet.
   */
  abstract class FormApplication<
    TObject extends object = object,
    TOptions extends FormApplicationOptions = FormApplicationOptions,
  > extends Application<TOptions> {
    constructor(object?: TObject, options?: Partial<TOptions>);

    override options: TOptions;

    /**
     * The object target which we are using this form to modify
     */
    object: TObject;

    /** A convenience reference to the form HTLMElement */
    form: HTMLFormElement;

    /**
     * Keep track of any FilePicker instances which are associated with this form
     * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
     */
    filepickers: FilePicker[];

    /**
     * Keep track of any mce editors which may be active as part of this form
     * The values of this Array are inner-objects with references to the MCE editor and other metadata
     */
    editors: Record<string, TinyMCEEditorData>;

    // Undocumented
    _submitting?: boolean;

    /** Assign the default options which are supported by the entity edit sheet */
    static override get defaultOptions(): FormApplicationOptions;

    /** Is the Form Application currently editable? */
    get isEditable(): boolean;

    getData(options?: Partial<TOptions>): FormApplicationData<TObject> | Promise<FormApplicationData<TObject>>;

    protected override _render(force?: boolean, options?: RenderOptions): Promise<void>;

    protected override _renderInner(data: FormApplicationData<TObject>, options: RenderOptions): Promise<JQuery>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /**
     * Activate the default set of listeners for the Entity sheet
     * These listeners handle basic stuff like form submission or updating images
     *
     * @param html The rendered template ready to have listeners attached
     */
    override activateListeners(html: JQuery): void;

    /**
     * If the form is not editable, disable its input fields
     * @param form The form HTML
     */
    protected _disableFields(form: HTMLElement): void;

    /**
     * Handle standard form submission steps
     * @param event           The submit event which triggered this handler
     * @param [updateData]    Additional specific data keys/values which override or extend the contents of
     *                        the parsed form. This can be used to update other flags or data fields at the
     *                        same time as processing a form submission to avoid multiple database operations.
     * @param [preventClose]  Override the standard behavior of whether to close the form on submit
     * @param [preventRender] Prevent the application from re-rendering as a result of form submission
     * @returns A promise which resolves to the validated update data
     */
    protected _onSubmit(event: Event, options?: OnSubmitFormOptions): Promise<Record<string, unknown> | false>;

    /**
     * Get an object of update data used to update the form's target object
     * @param updateData Additional data that should be merged with the form data
     * @return The prepared update data
     */
    protected _getSubmitData(updateData?: Record<string, unknown>): Record<string, unknown>;

    /**
     * Handle changes to an input element, submitting the form if options.submitOnChange is true.
     * Do not preventDefault in this handler as other interactions on the form may also be occurring.
     * @param event The initial change event
     */
    protected _onChangeInput(event: Event): Promise<void>;

    /**
     * Handle unfocusing an input on form - maybe trigger an update if ``options.liveUpdate`` has been set to true
     * @param event The initial triggering event
     */
    protected _onUnfocus(event: Event | JQuery.Event): void;

    /**
     * This method is called upon form submission after form data is validated
     * @param event     The initial triggering submission event
     * @param formData  The object of validated form data with which to update the object
     * @returns         A Promise which resolves once the update operation has completed
     */
    protected abstract _updateObject(event: Event, formData: Record<string, unknown>): Promise<unknown>;

    /* -------------------------------------------- */
    /*  TinyMCE Editor                              */
    /* -------------------------------------------- */

    /**
     * Activate a named TinyMCE text editor
     * @param name           The named data field which the editor modifies.
     * @param options        TinyMCE initialization options passed to TextEditor.create
     * @param initialContent Initial text content for the editor area.
     */
    activateEditor(
      name: string,
      options?: EditorCreateOptions,
      initialContent?: string,
    ): Promise<TinyMCE.Editor | ProseMirror.EditorView>;

    /**
     * Handle saving the content of a specific editor by name
     * @param name     The named editor to save
     * @param [remove] Remove the editor after saving its content
     */
    saveEditor(name: string, { remove }?: { remove?: boolean }): Promise<void>;

    /** Activate a TinyMCE editor instance present within the form */
    protected _activateEditor(div: JQuery | HTMLElement): void;

    /** Activate a FilePicker instance present within the form */
    protected _activateFilePicker(button: JQuery | HTMLElement): void;

    /**
     * Determine the configuration options used to initialize a FilePicker instance within this FormApplication.
     * Subclasses can extend this method to customize the behavior of pickers within their form.
     * @param event The initiating mouse click event which opens the picker
     * @returns Options passed to the FilePicker constructor
     */
    protected _getFilePickerOptions(event: PointerEvent): FilePickerOptions;

    /**
     * Submit the contents of a Form Application, processing its content as defined by the Application
     * @param [options] Options passed to the _onSubmit event handler
     * @returns Return a self-reference for convenient method chaining
     */
    submit(options?: OnSubmitFormOptions): Promise<this>;

    override close(options?: { force?: boolean }): Promise<void>;
  }

  class FormDataExtended extends FormData {
    constructor(form: HTMLElement, options?: { editors?: Record<string, TinyMCEEditorData>; dtypes?: string[] });

    /** The object representation of the form data, available once processed. */
    readonly object: Record<string, unknown>;

    /**
     * Process the HTML form element to populate the FormData instance.
     * @param form The HTML form
     */
    process(form: HTMLFormElement): void;
  }

  interface FormApplicationData<O extends object = object> {
    object?: O | object;
    options?: Partial<FormApplicationOptions>;
    title?: string;
  }

  interface OnSubmitFormOptions {
    updateData?: Record<string, unknown> | null;
    preventClose?: boolean;
    preventRender?: boolean;
  }

  interface FormApplicationOptions extends ApplicationOptions {
    /**
     * Whether the application form is editable - if true, it's fields will
     * be unlocked and the form can be submitted. If false, all form fields
     * will be disabled and the form cannot be submitted. Default is true.
     */
    editable: boolean;

    /**
     * Whether to automatically close the application when it's contained
     * form is submitted. Default is true.
     */
    closeOnSubmit: boolean;

    /**
     * Whether to automatically submit the contained HTML form when the
     * application window is manually closed. Default is false.
     */
    submitOnClose: boolean;

    /**
     * Whether to automatically submit the contained HTML form when an input
     * or select element is changed. Default is false.
     */
    submitOnChange: boolean;
  }

  interface TinyMCEEditorData {
    active: boolean;
    button: HTMLElement;
    changed: boolean;
    hasButton: boolean;
    initial: string;
    mce: TinyMCE.Editor | null;
    options: Partial<TinyMCE.EditorOptions>;
    target: string;
  }

  /** A simple implementation of the FormApplication pattern which is specialized in editing Entity instances */
  class DocumentSheet<
    TDocument extends foundry.abstract.Document = foundry.abstract.Document,
    TOptions extends DocumentSheetOptions = DocumentSheetOptions,
  > extends FormApplication<TDocument, TOptions> {
    constructor(object: TDocument, options?: Partial<TOptions>);

    static override get defaultOptions(): DocumentSheetOptions;

    /** A convenience accessor for the object property of the inherited FormApplication instance */
    get document(): TDocument;

    override get id(): string;

    override get isEditable(): boolean;

    override get title(): string;

    override close(options?: { force?: boolean | undefined }): Promise<void>;

    override getData(options?: Partial<TOptions>): DocumentSheetData<TDocument> | Promise<DocumentSheetData<TDocument>>;

    protected override _activateCoreListeners(html: JQuery): void;

    override activateEditor(
      name: string,
      options?: EditorCreateOptions,
      initialContent?: string,
    ): Promise<TinyMCE.Editor | ProseMirror.EditorView>;

    override render(force?: boolean, options?: RenderOptions): this;

    protected override _renderOuter(options: RenderOptions): Promise<JQuery>;

    /** Create an ID link button in the document sheet header which displays the document ID and copies to clipboard */
    protected _createDocumentIdLink(html: JQuery): void;

    /**
     * Test whether a certain User has permission to view this Document Sheet.
     * @param user The user requesting to render the sheet
     * @returns Does the User have permission to view this sheet?
     */
    protected _canUserView(user: User): boolean;

    /** Create objects for managing the functionality of secret blocks within this Document's content. */
    protected _createSecretHandlers(): HTMLSecret[];

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _getHeaderButtons(): ApplicationHeaderButton[];

    /**
     * Get the HTML content that a given secret block is embedded in.
     * @param secret The secret block.
     */
    protected _getSecretContent(secret: HTMLElement): string;

    /**
     * Update the HTML content that a given secret block is embedded in.
     * @param secret  The secret block.
     * @param content The new content.
     * @returns The updated Document.
     */
    protected _updateSecret(secret: HTMLElement, content: string): Promise<TDocument>;

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;
  }

  interface DocumentSheetOptions extends FormApplicationOptions {
    classes: string[];
    template: string;
    viewPermission: number;
    sheetConfig: boolean;
  }

  interface DocumentSheetData<TDocument extends foundry.abstract.Document = foundry.abstract.Document> {
    cssClass: string;
    editable: boolean;
    document: TDocument;
    data: object;
    limited: boolean;
    options: Partial<DocumentSheetOptions>;
    owner: boolean;
    title: string;
  }
}

declare global {
  /** A class responsible for configuring custom fonts for the world. */
  class FontConfig extends FormApplication {
    /**
     * An application for configuring custom world fonts.
     * @param [object]  The default settings for new font definition creation.
     * @param [options] Additional options to configure behaviour.
     */
    constructor(object?: NewFontDefinition, options?: Partial<FormApplicationOptions>);

    static override get defaultOptions(): FormApplicationOptions;

    /** Whether a font is distributed to connected clients or found on their OS. */
    static FONT_TYPES: {
      FILE: 'file';
      SYSTEM: 'system';
    };

    override getData(options?: Partial<FormApplicationOptions>): FormApplicationData;

    /**
     * Template data for a given font definition.
     * @param family     The font family.
     * @param definition The font family definition.
     */
    protected _getDataForDefinition(
      family: string,
      definition: FontFamilyDefinition,
    ): { family: string; index: number; selected?: true; font: unknown }[];

    override activateListeners(html: JQuery): void;

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;

    /**
     * Handle application controls.
     * @param event The click event.
     */
    protected _onClickControl(event: MouseEvent): void;

    protected override _onChangeInput(event: Event): Promise<void>;

    /** Update available font fields based on the font type selected. */
    protected _updateFontFields(): void;

    /** Add a new custom font definition. */
    protected _onAddFont(): Promise<void>;

    /**
     * Delete a font.
     * @param event The click event.
     */
    protected _onDeleteFont(event: MouseEvent): Promise<void>;

    /**
     * Select a font to preview.
     * @param event The click event.
     */
    protected _onSelectFont(event: MouseEvent): void;

    /* -------------------------------------------- */
    /*  Font Management Methods                     */
    /* -------------------------------------------- */

    /** Define the setting key where this world's font information will be stored. */
    static SETTING: 'fonts';

    /** Get the list of fonts that successfully loaded. */
    static getAvailableFonts(): string[];

    /** Get the list of fonts formatted for display with selectOptions. */
    static getAvailableFontChoices(): Record<string, string>;

    /* -------------------------------------------- */

    /**
     * Load a font definition.
     * @param  family    The font family name (case-sensitive).
     * @param definition The font family definition.
     * @returns Returns true if the font was successfully loaded.
     */
    static loadFont(family: string, definition: FontFamilyDefinition): Promise<boolean>;

    /**
     * Ensure that fonts have loaded and are ready for use.
     * Enforce a maximum timeout in milliseconds.
     * Proceed after that point even if fonts are not yet available.
     * @param [ms=4500] The maximum time to spend loading fonts before proceeding.
     */
    protected static _loadFonts(ms?: number): Promise<void>;

    /**
     * Create FontFace object from a FontDefinition.
     * @param family The font family name.
     * @param font   The font definition.
     * @protected
     */
    protected static _createFontFace(family: string, font: FontDefinition): FontFace;

    /**
     * Format a font definition for display.
     * @param family     The font family.
     * @param definition The font definition.
     * @returns The formatted definition.
     */
    protected static _formatFont(family: string, definition: FontDefinition): string;
  }

  interface NewFontDefinition {
    family?: string;
    weight?: number;
    style?: string;
    src?: string;
    /** The text to preview the font */
    preview?: string;
  }
}

/** The shortened software name */
declare const vtt: 'Foundry VTT';

/** The full software name */
declare const VTT: 'Foundry Virtual Tabletop';

/** The software website URL */
declare const WEBSITE_URL: 'https://foundryvtt.com';

/** The serverless API URL */
declare const WEBSITE_API_URL: 'https://api.foundryvtt.com';

/** An ASCII greeting displayed to the client */
declare const ASCII: `_______________________________________________________________
 _____ ___  _   _ _   _ ____  ______   __ __     _______ _____
|  ___/ _ \\| | | | \\ | |  _ \\|  _ \\ \\ / / \\ \\   / |_   _|_   _|
| |_ | | | | | | |  \\| | | | | |_) \\ V /   \\ \\ / /  | |   | |
|  _|| |_| | |_| | |\\  | |_| |  _ < | |     \\ V /   | |   | |
|_|   \\___/ \\___/|_| \\_|____/|_| \\_\\|_|      \\_/    |_|   |_|
===============================================================`;

/** Define the allowed ActiveEffect application modes */
declare const ACTIVE_EFFECT_MODES: {
  CUSTOM: 0;
  MULTIPLY: 1;
  ADD: 2;
  DOWNGRADE: 3;
  UPGRADE: 4;
  OVERRIDE: 5;
};

/** Define the string name used for the base document type when specific sub-types are not defined by the system */
declare const BASE_DOCUMENT_TYPE: 'base';

/**
 * Define the methods by which a Card can be drawn from a Cards stack
 * TOP and FIRST are synonymous, as are BOTTOM and LAST.
 */
declare const CARD_DRAW_MODES: {
  FIRST: 0;
  TOP: 0;
  LAST: 1;
  BOTTOM: 1;
  RANDOM: 2;
};

/** An enumeration of canvas performance modes. */
declare const CANVAS_PERFORMANCE_MODES: {
  LOW: 0;
  MED: 1;
  HIGH: 2;
  MAX: 3;
};

/** Valid Chat Message types */
declare const CHAT_MESSAGE_TYPES: {
  OTHER: 0;
  OOC: 1;
  IC: 2;
  EMOTE: 3;
  WHISPER: 4;
  ROLL: 5;
};

/** Define the set of languages which have built-in support in the core software */
declare const CORE_SUPPORTED_LANGUAGES: ['en'];

/**
 * Configure the severity of compatibility warnings.
 * If SILENT, nothing will be logged
 * If WARNING, a message will be logged at the "warn" level
 * If ERROR, a message will be logged at the "error" level
 * If FAILURE, an Error will be thrown
 */
declare const COMPATIBILITY_MODES: {
  SILENT: 0;
  WARNING: 1;
  ERROR: 2;
  FAILURE: 3;
};

/** The default artwork used for Token images if none is provided */
declare const DEFAULT_TOKEN: 'icons/svg/mystery-man.svg';

/** Define the allowed Document class types. */
declare const DOCUMENT_TYPES: [
  'Actor',
  'Cards',
  'ChatMessage',
  'Combat',
  'Item',
  'Folder',
  'JournalEntry',
  'Macro',
  'Playlist',
  'RollTable',
  'Scene',
  'User',
];

/** The allowed Document types which may exist within a Compendium pack. */
declare const COMPENDIUM_DOCUMENT_TYPES: [
  'Actor',
  'Cards',
  'Item',
  'JournalEntry',
  'Macro',
  'Playlist',
  'RollTable',
  'Scene',
  'Adventure',
];

/**
 * Define the allowed ownership levels for a Document.
 * Each level is assigned a value in ascending order.
 * Higher levels grant more permissions.
 */
declare const DOCUMENT_OWNERSHIP_LEVELS: {
  INHERIT: -1;
  NONE: 0;
  LIMITED: 1;
  OBSERVER: 2;
  OWNER: 3;
};

/** Meta ownership levels that are used in the UI but never stored. */
declare const DOCUMENT_META_OWNERSHIP_LEVELS: {
  DEFAULT: -20;
  NOCHANGE: -10;
};

/** Define the allowed Document types which may be dynamically linked in chat */
declare const DOCUMENT_LINK_TYPES: [
  'Actor',
  'Cards',
  'Item',
  'Scene',
  'JournalEntry',
  'Macro',
  'RollTable',
  'PlaylistSound',
];

/** The supported dice roll visibility modes */
declare const DICE_ROLL_MODES: {
  PUBLIC: 'publicroll';
  PRIVATE: 'gmroll';
  BLIND: 'blindroll';
  SELF: 'selfroll';
};

/**
 * The allowed fill types which a Drawing object may display
 * NONE: The drawing is not filled
 * SOLID: The drawing is filled with a solid color
 * PATTERN: The drawing is filled with a tiled image pattern
 */
declare const DRAWING_FILL_TYPES: {
  NONE: 0;
  SOLID: 1;
  PATTERN: 2;
};

/**
 * Define the allowed Document types which Folders may contain
 */
declare const FOLDER_DOCUMENT_TYPES: [
  'Actor',
  'Item',
  'Scene',
  'JournalEntry',
  'Playlist',
  'RollTable',
  'Cards',
  'Macro',
];

/** The maximum allowed level of depth for Folder nesting */
declare const FOLDER_MAX_DEPTH: 3;

/** A list of allowed game URL names */
declare const GAME_VIEWS: ['game', 'stream'];

/** The minimum allowed grid size which is supported by the software */
declare const GRID_MIN_SIZE: 50;

/** The allowed Grid types which are supported by the software */
declare const GRID_TYPES: {
  GRIDLESS: 0;
  SQUARE: 1;
  HEXODDR: 2;
  HEXEVENR: 3;
  HEXODDQ: 4;
  HEXEVENQ: 5;
};

/** A list of supported setup URL names */
declare const SETUP_VIEWS: ['license', 'setup', 'players', 'join', 'auth'];

/** An Array of valid MacroAction scope values */
declare const MACRO_SCOPES: ['global', 'actors', 'actor'];

/** An enumeration of valid Macro types */
declare const MACRO_TYPES: {
  SCRIPT: 'script';
  CHAT: 'chat';
};

/**
 * The allowed playback modes for an audio Playlist
 * DISABLED: The playlist does not play on its own, only individual Sound tracks played as a soundboard
 * SEQUENTIAL: The playlist plays sounds one at a time in sequence
 * SHUFFLE: The playlist plays sounds one at a time in randomized order
 * SIMULTANEOUS: The playlist plays all contained sounds at the same time
 */
declare const PLAYLIST_MODES: {
  DISABLED: -1;
  SEQUENTIAL: 0;
  SHUFFLE: 1;
  SIMULTANEOUS: 2;
};

/**
 * The available sort modes for an audio Playlist.
 * ALPHABETICAL (default): Sort sounds alphabetically.
 * MANUAL: Sort sounds by manual drag-and-drop.
 */
declare const PLAYLIST_SORT_MODES: {
  ALPHABETICAL: 'a';
  MANUAL: 'm';
};

/** The available modes for searching within a DirectoryCollection */
declare const DIRECTORY_SEARCH_MODES: {
  FULL: 'full';
  NAME: 'name';
};

/** The allowed package types */
declare const PACKAGE_TYPES: ['world', 'system', 'module'];

/** Encode the reasons why a package may be available or unavailable for use */
declare const PACKAGE_AVAILABILITY_CODES: {
  UNKNOWN: -1;
  AVAILABLE: 0;
  REQUIRES_UPDATE: 1;
  REQUIRES_SYSTEM: 2;
  REQUIRES_DEPENDENCY: 3;
  REQUIRES_CORE_UPGRADE: 4;
  REQUIRES_CORE_DOWNGRADE: 5;
};

/** A safe password string which can be displayed */
declare const PASSWORD_SAFE_STRING: '••••••••••••••••';

/** The allowed software update channels */
declare const SOFTWARE_UPDATE_CHANNELS: {
  stable: 'SETUP.UpdateStable';
  testing: 'SETUP.UpdateTesting';
  development: 'SETUP.UpdateDevelopment';
  prototype: 'SETUP.UpdatePrototype';
};

/** The default sorting density for manually ordering child objects within a parent */
declare const SORT_INTEGER_DENSITY: 100000;

/** The allowed types of a TableResult document */
declare const TABLE_RESULT_TYPES: {
  TEXT: 0;
  DOCUMENT: 1;
  COMPENDIUM: 2;
};

/** The allowed formats of a Journal Entry Page. */
declare const JOURNAL_ENTRY_PAGE_FORMATS: {
  HTML: 1;
  MARKDOWN: 2;
};

/** Define the valid anchor locations for a Tooltip displayed on a Placeable Object */
declare const TEXT_ANCHOR_POINTS: {
  CENTER: 0;
  BOTTOM: 1;
  TOP: 2;
  LEFT: 3;
  RIGHT: 4;
};

/** Define the valid occlusion modes which an overhead tile can use */
declare const TILE_OCCLUSION_MODES: {
  NONE: 0;
  FADE: 1;
  // ROOF: 2,  This mode is no longer supported so we don't use 2 for any other mode
  RADIAL: 3;
  VISION: 4;
};

/**
 * Describe the various thresholds of token control upon which to show certain pieces of information
 * NONE - no information is displayed
 * CONTROL - displayed when the token is controlled
 * OWNER HOVER - displayed when hovered by a GM or a user who owns the actor
 * HOVER - displayed when hovered by any user
 * OWNER - always displayed for a GM or for a user who owns the actor
 * ALWAYS - always displayed for everyone
 */
declare const TOKEN_DISPLAY_MODES: {
  NONE: 0;
  CONTROL: 10;
  OWNER_HOVER: 20;
  HOVER: 30;
  OWNER: 40;
  ALWAYS: 50;
};

/**
 * The allowed Token disposition types
 * @see https://foundryvtt.com/article/tokens/
 */
declare const TOKEN_DISPOSITIONS: {
  /** Displayed with a purple borders for owners and with no borders for others (and no pointer change). */
  SECRET: -2;

  /** Displayed as an enemy with a red border. */
  HOSTILE: -1;

  /** Displayed as neutral with a yellow border. */
  NEUTRAL: 0;

  /** Displayed as an ally with a cyan border. */
  FRIENDLY: 1;
};

/**
 * Define the allowed User permission levels.
 * Each level is assigned a value in ascending order. Higher levels grant more permissions.
 */
declare const USER_ROLES: {
  NONE: 0;
  PLAYER: 1;
  TRUSTED: 2;
  ASSISTANT: 3;
  GAMEMASTER: 4;
};

/** Invert the User Role mapping to recover role names from a role integer */
declare const USER_ROLE_NAMES: {
  0: 'NONE';
  1: 'PLAYER';
  2: 'TRUSTED';
  3: 'ASSISTANT';
  4: 'GAMEMASTER';
};

/** An enumeration of the allowed types for a MeasuredTemplate embedded document */
declare const MEASURED_TEMPLATE_TYPES: {
  CIRCLE: 'circle';
  CONE: 'cone';
  RECTANGLE: 'rect';
  RAY: 'ray';
};

/** Define the recognized User capabilities which individual Users or role levels may be permitted to perform */
declare const USER_PERMISSIONS: {
  ACTOR_CREATE: {
    label: 'PERMISSION.ActorCreate';
    hint: 'PERMISSION.ActorCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  BROADCAST_AUDIO: {
    label: 'PERMISSION.BroadcastAudio';
    hint: 'PERMISSION.BroadcastAudioHint';
    disableGM: true;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  BROADCAST_VIDEO: {
    label: 'PERMISSION.BroadcastVideo';
    hint: 'PERMISSION.BroadcastVideoHint';
    disableGM: true;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  CARDS_CREATE: {
    label: 'PERMISSION.CardsCreate';
    hint: 'PERMISSION.CardsCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  DRAWING_CREATE: {
    label: 'PERMISSION.DrawingCreate';
    hint: 'PERMISSION.DrawingCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  ITEM_CREATE: {
    label: 'PERMISSION.ItemCreate';
    hint: 'PERMISSION.ItemCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  FILES_BROWSE: {
    label: 'PERMISSION.FilesBrowse';
    hint: 'PERMISSION.FilesBrowseHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  FILES_UPLOAD: {
    label: 'PERMISSION.FilesUpload';
    hint: 'PERMISSION.FilesUploadHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  JOURNAL_CREATE: {
    label: 'PERMISSION.JournalCreate';
    hint: 'PERMISSION.JournalCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  MACRO_SCRIPT: {
    label: 'PERMISSION.MacroScript';
    hint: 'PERMISSION.MacroScriptHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
  MESSAGE_WHISPER: {
    label: 'PERMISSION.MessageWhisper';
    hint: 'PERMISSION.MessageWhisperHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
  NOTE_CREATE: {
    label: 'PERMISSION.NoteCreate';
    hint: 'PERMISSION.NoteCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  SETTINGS_MODIFY: {
    label: 'PERMISSION.SettingsModify';
    hint: 'PERMISSION.SettingsModifyHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  SHOW_CURSOR: {
    label: 'PERMISSION.ShowCursor';
    hint: 'PERMISSION.ShowCursorHint';
    disableGM: true;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
  SHOW_RULER: {
    label: 'PERMISSION.ShowRuler';
    hint: 'PERMISSION.ShowRulerHint';
    disableGM: true;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
  TEMPLATE_CREATE: {
    label: 'PERMISSION.TemplateCreate';
    hint: 'PERMISSION.TemplateCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
  TOKEN_CREATE: {
    label: 'PERMISSION.TokenCreate';
    hint: 'PERMISSION.TokenCreateHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.ASSISTANT;
  };
  TOKEN_CONFIGURE: {
    label: 'PERMISSION.TokenConfigure';
    hint: 'PERMISSION.TokenConfigureHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.TRUSTED;
  };
  WALL_DOORS: {
    label: 'PERMISSION.WallDoors';
    hint: 'PERMISSION.WallDoorsHint';
    disableGM: false;
    defaultRole: typeof USER_ROLES.PLAYER;
  };
};

/**
 * The allowed directions of effect that a Wall can have
 * BOTH: The wall collides from both directions
 * LEFT: The wall collides only when a ray strikes its left side
 * RIGHT: The wall collides only when a ray strikes its right side
 */
declare const WALL_DIRECTIONS: {
  BOTH: 0;
  LEFT: 1;
  RIGHT: 2;
};

/**
 * The allowed door types which a Wall may contain
 * NONE: The wall does not contain a door
 * DOOR: The wall contains a regular door
 * SECRET: The wall contains a secret door
 */
declare const WALL_DOOR_TYPES: {
  NONE: 0;
  DOOR: 1;
  SECRET: 2;
};

/**
 * The allowed door states which may describe a Wall that contains a door
 * CLOSED: The door is closed
 * OPEN: The door is open
 * LOCKED: The door is closed and locked
 */
declare const WALL_DOOR_STATES: {
  CLOSED: 0;
  OPEN: 1;
  LOCKED: 2;
};

/** The wall properties which restrict the way interaction occurs with a specific wall */
declare const WALL_RESTRICTION_TYPES: ['light', 'sight', 'sound', 'move'];

/**
 * The types of sensory collision which a Wall may impose
 * NONE: Senses do not collide with this wall
 * NORMAL: Senses collide with this wall
 * LIMITED: Senses collide with the second intersection, bypassing the first
 */
declare const WALL_SENSE_TYPES: {
  NONE: 0;
  LIMITED: 10;
  NORMAL: 20;
};

/**
 * The types of movement collision which a Wall may impose
 * NONE: Movement does not collide with this wall
 * NORMAL: Movement collides with this wall
 */
declare const WALL_MOVEMENT_TYPES: {
  NONE: typeof WALL_SENSE_TYPES.NONE;
  NORMAL: typeof WALL_SENSE_TYPES.NORMAL;
};

/**
 * The possible precedence values a Keybinding might run in
 * PRIORITY: Runs in the first group along with other PRIORITY keybindings
 * NORMAL: Runs after the PRIORITY group along with other NORMAL keybindings
 * DEFERRED: Runs in the last group along with other DEFERRED keybindings
 */
declare const KEYBINDING_PRECEDENCE: {
  PRIORITY: 0;
  NORMAL: 1;
  DEFERRED: 2;
};

/** The allowed set of HTML template extensions  */
declare const HTML_FILE_EXTENSIONS: ['html', 'handlebars', 'hbs'];

/** The supported file extensions for image-type files, and their corresponding mime types. */
declare const IMAGE_FILE_EXTENSIONS: {
  apng: 'image/apng';
  avif: 'image/avif';
  bmp: 'image/bmp';
  gif: 'image/gif';
  jpeg: 'image/jpeg';
  jpg: 'image/jpeg';
  png: 'image/png';
  svg: 'image/svg+xml';
  tiff: 'image/tiff';
  webp: 'image/webp';
};

/** The supported file extensions for video-type files, and their corresponding mime types. */
declare const VIDEO_FILE_EXTENSIONS: {
  m4v: 'video/mp4';
  mp4: 'video/mp4';
  ogg: 'video/ogg';
  webm: 'video/webm';
};

/** The supported file extensions for audio-type files, and their corresponding mime types. */
declare const AUDIO_FILE_EXTENSIONS: {
  aac: 'audio/aac';
  flac: 'audio/flac';
  m4a: 'audio/mp4';
  mid: 'audio/midi';
  mp3: 'audio/mpeg';
  ogg: 'audio/ogg';
  opus: 'audio/opus';
  wav: 'audio/wav';
  webm: 'audio/webm';
};

/** The supported file extensions for text files, and their corresponding mime types. */
declare const TEXT_FILE_EXTENSIONS: {
  csv: 'text/csv';
  json: 'application/json';
  md: 'text/markdown';
  pdf: 'application/pdf';
  tsv: 'text/tab-separated-values';
  txt: 'text/plain';
  xml: 'application/xml';
  yml: 'application/yaml';
  yaml: 'application/yaml';
};

/** Supported file extensions for font files, and their corresponding mime types. */
declare const FONT_FILE_EXTENSIONS: {
  ttf: 'font/ttf';
  otf: 'font/otf';
  woff: 'font/woff';
  woff2: 'font/woff2';
};

/** Supported file extensions for 3D files, and their corresponding mime types. */
declare const GRAPHICS_FILE_EXTENSIONS: {
  fbx: 'application/octet-stream';
  glb: 'model/gltf-binary';
  gltf: 'model/gltf+json';
  mtl: 'model/mtl';
  obj: 'model/obj';
  stl: 'model/stl';
  usdz: 'model/vnd.usdz+zip';
};

declare const UPLOADABLE_FILE_EXTENSIONS: typeof IMAGE_FILE_EXTENSIONS &
  Omit<typeof VIDEO_FILE_EXTENSIONS, 'ogg' | 'webm'> &
  typeof AUDIO_FILE_EXTENSIONS &
  typeof TEXT_FILE_EXTENSIONS &
  typeof FONT_FILE_EXTENSIONS &
  typeof GRAPHICS_FILE_EXTENSIONS;

/**
 * A list of MIME types which are treated as uploaded "media", which are allowed to overwrite existing files.
 * Any non-media MIME type is not allowed to replace an existing file.
 */
declare const MEDIA_MIME_TYPES: (typeof UPLOADABLE_FILE_EXTENSIONS)[keyof typeof UPLOADABLE_FILE_EXTENSIONS];

/** An enumeration of file type categories which can be selected */
declare const FILE_CATEGORIES: {
  HTML: typeof HTML_FILE_EXTENSIONS;
  IMAGE: typeof IMAGE_FILE_EXTENSIONS;
  VIDEO: typeof VIDEO_FILE_EXTENSIONS;
  AUDIO: typeof AUDIO_FILE_EXTENSIONS;
  TEXT: typeof TEXT_FILE_EXTENSIONS;
  FONT: typeof FONT_FILE_EXTENSIONS;
  GRAPHICS: typeof GRAPHICS_FILE_EXTENSIONS;
  MEDIA: typeof MEDIA_MIME_TYPES;
};

/** A font weight to name mapping. */
declare const FONT_WEIGHTS: {
  Thin: 100;
  ExtraLight: 200;
  Light: 300;
  Regular: 400;
  Medium: 500;
  SemiBold: 600;
  Bold: 700;
  ExtraBold: 800;
  Black: 900;
};

/** Stores shared commonly used timeouts, measured in MS */
declare const TIMEOUTS: {
  FOUNDRY_WEBSITE: 10000;
  PACKAGE_REPOSITORY: 5000;
  IP_DISCOVERY: 5000;
};

declare global {
  interface UserPermission {
    label: string;
    hint: string;
    disableGM: boolean;
    defaultRole: UserRole;
  }

  type ActiveEffectChangeMode = (typeof CONST.ACTIVE_EFFECT_MODES)[keyof typeof CONST.ACTIVE_EFFECT_MODES];
  type AudioFileExtension = keyof typeof AUDIO_FILE_EXTENSIONS;
  type CanvasPerformanceMode = (typeof CANVAS_PERFORMANCE_MODES)[keyof typeof CANVAS_PERFORMANCE_MODES];
  type ChatMessageType = (typeof CONST.CHAT_MESSAGE_TYPES)[keyof typeof CONST.CHAT_MESSAGE_TYPES];
  type CompatibilityMode = (typeof CONST.COMPATIBILITY_MODES)[keyof typeof CONST.COMPATIBILITY_MODES];
  type DirectorySearchMode = (typeof DIRECTORY_SEARCH_MODES)[keyof typeof DIRECTORY_SEARCH_MODES];
  type DocumentOwnershipLevel = (typeof DOCUMENT_OWNERSHIP_LEVELS)[DocumentOwnershipString];
  type DocumentOwnershipString = keyof typeof DOCUMENT_OWNERSHIP_LEVELS;
  type DrawingFillType = (typeof DRAWING_FILL_TYPES)[keyof typeof DRAWING_FILL_TYPES];
  type DrawingShapeType = 'r' | 'e' | 't' | 'p' | 'f';
  type FileCategory = keyof typeof FILE_CATEGORIES;
  type FileExtension = keyof typeof UPLOADABLE_FILE_EXTENSIONS;
  type FolderDocumentType = (typeof FOLDER_DOCUMENT_TYPES)[number];
  type GridType = (typeof GRID_TYPES)[keyof typeof GRID_TYPES];
  type ImageFileExtension = keyof typeof IMAGE_FILE_EXTENSIONS;
  type JournalEntryPageFormat = (typeof JOURNAL_ENTRY_PAGE_FORMATS)[keyof typeof JOURNAL_ENTRY_PAGE_FORMATS];
  type MacroScope = (typeof MACRO_SCOPES)[number];
  type MacroType = (typeof MACRO_TYPES)[keyof typeof MACRO_TYPES];
  type MeasuredTemplateType = (typeof MEASURED_TEMPLATE_TYPES)[keyof typeof MEASURED_TEMPLATE_TYPES];
  type PackageAvailabilityCode = (typeof PACKAGE_AVAILABILITY_CODES)[keyof typeof PACKAGE_AVAILABILITY_CODES];
  type PackageType = (typeof PACKAGE_TYPES)[number];
  type PlaylistMode = (typeof PLAYLIST_MODES)[keyof typeof PLAYLIST_MODES];
  type PlaylistSortMode = (typeof PLAYLIST_SORT_MODES)[keyof typeof PLAYLIST_SORT_MODES];
  type RollMode = (typeof CONST.DICE_ROLL_MODES)[keyof typeof CONST.DICE_ROLL_MODES];
  type TableResultType = (typeof TABLE_RESULT_TYPES)[keyof typeof TABLE_RESULT_TYPES];
  type TextAnchorPoint = (typeof TEXT_ANCHOR_POINTS)[keyof typeof TEXT_ANCHOR_POINTS];
  type TileOcclusionMode = (typeof TILE_OCCLUSION_MODES)[keyof typeof TILE_OCCLUSION_MODES];
  type TokenDisplayMode = (typeof TOKEN_DISPLAY_MODES)[keyof typeof TOKEN_DISPLAY_MODES];
  type TokenDisposition = (typeof TOKEN_DISPOSITIONS)[keyof typeof TOKEN_DISPOSITIONS];
  type UserAction = 'create' | 'update' | 'delete';
  type UserPermissionString = keyof typeof USER_PERMISSIONS;
  type UserRole = keyof typeof USER_ROLE_NAMES;
  type UserRoleName = keyof typeof USER_ROLES;
  type VideoFileExtension = keyof typeof VIDEO_FILE_EXTENSIONS;
  type WallDirection = (typeof WALL_DIRECTIONS)[keyof typeof WALL_DIRECTIONS];
  type WallDoorState = (typeof WALL_DOOR_STATES)[keyof typeof WALL_DOOR_STATES];
  type WallDoorType = (typeof WALL_DOOR_TYPES)[keyof typeof WALL_DOOR_TYPES];
  type WallMovementType = (typeof WALL_MOVEMENT_TYPES)[keyof typeof WALL_MOVEMENT_TYPES];
  type WallRestrictionType = (typeof WALL_RESTRICTION_TYPES)[number];
  type WallSenseType = (typeof WALL_SENSE_TYPES)[keyof typeof WALL_SENSE_TYPES];
}

declare const Constants_ACTIVE_EFFECT_MODES: typeof ACTIVE_EFFECT_MODES;
declare const Constants_ASCII: typeof ASCII;
declare const Constants_AUDIO_FILE_EXTENSIONS: typeof AUDIO_FILE_EXTENSIONS;
declare const Constants_BASE_DOCUMENT_TYPE: typeof BASE_DOCUMENT_TYPE;
declare const Constants_CANVAS_PERFORMANCE_MODES: typeof CANVAS_PERFORMANCE_MODES;
declare const Constants_CARD_DRAW_MODES: typeof CARD_DRAW_MODES;
declare const Constants_CHAT_MESSAGE_TYPES: typeof CHAT_MESSAGE_TYPES;
declare const Constants_COMPATIBILITY_MODES: typeof COMPATIBILITY_MODES;
declare const Constants_COMPENDIUM_DOCUMENT_TYPES: typeof COMPENDIUM_DOCUMENT_TYPES;
declare const Constants_CORE_SUPPORTED_LANGUAGES: typeof CORE_SUPPORTED_LANGUAGES;
declare const Constants_DEFAULT_TOKEN: typeof DEFAULT_TOKEN;
declare const Constants_DICE_ROLL_MODES: typeof DICE_ROLL_MODES;
declare const Constants_DIRECTORY_SEARCH_MODES: typeof DIRECTORY_SEARCH_MODES;
declare const Constants_DOCUMENT_LINK_TYPES: typeof DOCUMENT_LINK_TYPES;
declare const Constants_DOCUMENT_META_OWNERSHIP_LEVELS: typeof DOCUMENT_META_OWNERSHIP_LEVELS;
declare const Constants_DOCUMENT_OWNERSHIP_LEVELS: typeof DOCUMENT_OWNERSHIP_LEVELS;
declare const Constants_DOCUMENT_TYPES: typeof DOCUMENT_TYPES;
declare const Constants_DRAWING_FILL_TYPES: typeof DRAWING_FILL_TYPES;
declare const Constants_FILE_CATEGORIES: typeof FILE_CATEGORIES;
declare const Constants_FOLDER_DOCUMENT_TYPES: typeof FOLDER_DOCUMENT_TYPES;
declare const Constants_FOLDER_MAX_DEPTH: typeof FOLDER_MAX_DEPTH;
declare const Constants_FONT_FILE_EXTENSIONS: typeof FONT_FILE_EXTENSIONS;
declare const Constants_FONT_WEIGHTS: typeof FONT_WEIGHTS;
declare const Constants_GAME_VIEWS: typeof GAME_VIEWS;
declare const Constants_GRAPHICS_FILE_EXTENSIONS: typeof GRAPHICS_FILE_EXTENSIONS;
declare const Constants_GRID_MIN_SIZE: typeof GRID_MIN_SIZE;
declare const Constants_GRID_TYPES: typeof GRID_TYPES;
declare const Constants_HTML_FILE_EXTENSIONS: typeof HTML_FILE_EXTENSIONS;
declare const Constants_IMAGE_FILE_EXTENSIONS: typeof IMAGE_FILE_EXTENSIONS;
declare const Constants_JOURNAL_ENTRY_PAGE_FORMATS: typeof JOURNAL_ENTRY_PAGE_FORMATS;
declare const Constants_KEYBINDING_PRECEDENCE: typeof KEYBINDING_PRECEDENCE;
declare const Constants_MACRO_SCOPES: typeof MACRO_SCOPES;
declare const Constants_MACRO_TYPES: typeof MACRO_TYPES;
declare const Constants_MEASURED_TEMPLATE_TYPES: typeof MEASURED_TEMPLATE_TYPES;
declare const Constants_MEDIA_MIME_TYPES: typeof MEDIA_MIME_TYPES;
declare const Constants_PACKAGE_AVAILABILITY_CODES: typeof PACKAGE_AVAILABILITY_CODES;
declare const Constants_PACKAGE_TYPES: typeof PACKAGE_TYPES;
declare const Constants_PASSWORD_SAFE_STRING: typeof PASSWORD_SAFE_STRING;
declare const Constants_PLAYLIST_MODES: typeof PLAYLIST_MODES;
declare const Constants_PLAYLIST_SORT_MODES: typeof PLAYLIST_SORT_MODES;
declare const Constants_SETUP_VIEWS: typeof SETUP_VIEWS;
declare const Constants_SOFTWARE_UPDATE_CHANNELS: typeof SOFTWARE_UPDATE_CHANNELS;
declare const Constants_SORT_INTEGER_DENSITY: typeof SORT_INTEGER_DENSITY;
declare const Constants_TABLE_RESULT_TYPES: typeof TABLE_RESULT_TYPES;
declare const Constants_TEXT_ANCHOR_POINTS: typeof TEXT_ANCHOR_POINTS;
declare const Constants_TEXT_FILE_EXTENSIONS: typeof TEXT_FILE_EXTENSIONS;
declare const Constants_TILE_OCCLUSION_MODES: typeof TILE_OCCLUSION_MODES;
declare const Constants_TIMEOUTS: typeof TIMEOUTS;
declare const Constants_TOKEN_DISPLAY_MODES: typeof TOKEN_DISPLAY_MODES;
declare const Constants_TOKEN_DISPOSITIONS: typeof TOKEN_DISPOSITIONS;
declare const Constants_UPLOADABLE_FILE_EXTENSIONS: typeof UPLOADABLE_FILE_EXTENSIONS;
declare const Constants_USER_PERMISSIONS: typeof USER_PERMISSIONS;
declare const Constants_USER_ROLES: typeof USER_ROLES;
declare const Constants_USER_ROLE_NAMES: typeof USER_ROLE_NAMES;
declare const Constants_VIDEO_FILE_EXTENSIONS: typeof VIDEO_FILE_EXTENSIONS;
declare const Constants_VTT: typeof VTT;
declare const Constants_WALL_DIRECTIONS: typeof WALL_DIRECTIONS;
declare const Constants_WALL_DOOR_STATES: typeof WALL_DOOR_STATES;
declare const Constants_WALL_DOOR_TYPES: typeof WALL_DOOR_TYPES;
declare const Constants_WALL_MOVEMENT_TYPES: typeof WALL_MOVEMENT_TYPES;
declare const Constants_WALL_RESTRICTION_TYPES: typeof WALL_RESTRICTION_TYPES;
declare const Constants_WALL_SENSE_TYPES: typeof WALL_SENSE_TYPES;
declare const Constants_WEBSITE_API_URL: typeof WEBSITE_API_URL;
declare const Constants_WEBSITE_URL: typeof WEBSITE_URL;
declare const Constants_vtt: typeof vtt;
declare namespace Constants {
  export {
    Constants_ACTIVE_EFFECT_MODES as ACTIVE_EFFECT_MODES,
    Constants_ASCII as ASCII,
    Constants_AUDIO_FILE_EXTENSIONS as AUDIO_FILE_EXTENSIONS,
    Constants_BASE_DOCUMENT_TYPE as BASE_DOCUMENT_TYPE,
    Constants_CANVAS_PERFORMANCE_MODES as CANVAS_PERFORMANCE_MODES,
    Constants_CARD_DRAW_MODES as CARD_DRAW_MODES,
    Constants_CHAT_MESSAGE_TYPES as CHAT_MESSAGE_TYPES,
    Constants_COMPATIBILITY_MODES as COMPATIBILITY_MODES,
    Constants_COMPENDIUM_DOCUMENT_TYPES as COMPENDIUM_DOCUMENT_TYPES,
    Constants_CORE_SUPPORTED_LANGUAGES as CORE_SUPPORTED_LANGUAGES,
    Constants_DEFAULT_TOKEN as DEFAULT_TOKEN,
    Constants_DICE_ROLL_MODES as DICE_ROLL_MODES,
    Constants_DIRECTORY_SEARCH_MODES as DIRECTORY_SEARCH_MODES,
    Constants_DOCUMENT_LINK_TYPES as DOCUMENT_LINK_TYPES,
    Constants_DOCUMENT_META_OWNERSHIP_LEVELS as DOCUMENT_META_OWNERSHIP_LEVELS,
    Constants_DOCUMENT_OWNERSHIP_LEVELS as DOCUMENT_OWNERSHIP_LEVELS,
    Constants_DOCUMENT_TYPES as DOCUMENT_TYPES,
    Constants_DRAWING_FILL_TYPES as DRAWING_FILL_TYPES,
    Constants_FILE_CATEGORIES as FILE_CATEGORIES,
    Constants_FOLDER_DOCUMENT_TYPES as FOLDER_DOCUMENT_TYPES,
    Constants_FOLDER_MAX_DEPTH as FOLDER_MAX_DEPTH,
    Constants_FONT_FILE_EXTENSIONS as FONT_FILE_EXTENSIONS,
    Constants_FONT_WEIGHTS as FONT_WEIGHTS,
    Constants_GAME_VIEWS as GAME_VIEWS,
    Constants_GRAPHICS_FILE_EXTENSIONS as GRAPHICS_FILE_EXTENSIONS,
    Constants_GRID_MIN_SIZE as GRID_MIN_SIZE,
    Constants_GRID_TYPES as GRID_TYPES,
    Constants_HTML_FILE_EXTENSIONS as HTML_FILE_EXTENSIONS,
    Constants_IMAGE_FILE_EXTENSIONS as IMAGE_FILE_EXTENSIONS,
    Constants_JOURNAL_ENTRY_PAGE_FORMATS as JOURNAL_ENTRY_PAGE_FORMATS,
    Constants_KEYBINDING_PRECEDENCE as KEYBINDING_PRECEDENCE,
    Constants_MACRO_SCOPES as MACRO_SCOPES,
    Constants_MACRO_TYPES as MACRO_TYPES,
    Constants_MEASURED_TEMPLATE_TYPES as MEASURED_TEMPLATE_TYPES,
    Constants_MEDIA_MIME_TYPES as MEDIA_MIME_TYPES,
    Constants_PACKAGE_AVAILABILITY_CODES as PACKAGE_AVAILABILITY_CODES,
    Constants_PACKAGE_TYPES as PACKAGE_TYPES,
    Constants_PASSWORD_SAFE_STRING as PASSWORD_SAFE_STRING,
    Constants_PLAYLIST_MODES as PLAYLIST_MODES,
    Constants_PLAYLIST_SORT_MODES as PLAYLIST_SORT_MODES,
    Constants_SETUP_VIEWS as SETUP_VIEWS,
    Constants_SOFTWARE_UPDATE_CHANNELS as SOFTWARE_UPDATE_CHANNELS,
    Constants_SORT_INTEGER_DENSITY as SORT_INTEGER_DENSITY,
    Constants_TABLE_RESULT_TYPES as TABLE_RESULT_TYPES,
    Constants_TEXT_ANCHOR_POINTS as TEXT_ANCHOR_POINTS,
    Constants_TEXT_FILE_EXTENSIONS as TEXT_FILE_EXTENSIONS,
    Constants_TILE_OCCLUSION_MODES as TILE_OCCLUSION_MODES,
    Constants_TIMEOUTS as TIMEOUTS,
    Constants_TOKEN_DISPLAY_MODES as TOKEN_DISPLAY_MODES,
    Constants_TOKEN_DISPOSITIONS as TOKEN_DISPOSITIONS,
    Constants_UPLOADABLE_FILE_EXTENSIONS as UPLOADABLE_FILE_EXTENSIONS,
    Constants_USER_PERMISSIONS as USER_PERMISSIONS,
    Constants_USER_ROLES as USER_ROLES,
    Constants_USER_ROLE_NAMES as USER_ROLE_NAMES,
    Constants_VIDEO_FILE_EXTENSIONS as VIDEO_FILE_EXTENSIONS,
    Constants_VTT as VTT,
    Constants_WALL_DIRECTIONS as WALL_DIRECTIONS,
    Constants_WALL_DOOR_STATES as WALL_DOOR_STATES,
    Constants_WALL_DOOR_TYPES as WALL_DOOR_TYPES,
    Constants_WALL_MOVEMENT_TYPES as WALL_MOVEMENT_TYPES,
    Constants_WALL_RESTRICTION_TYPES as WALL_RESTRICTION_TYPES,
    Constants_WALL_SENSE_TYPES as WALL_SENSE_TYPES,
    Constants_WEBSITE_API_URL as WEBSITE_API_URL,
    Constants_WEBSITE_URL as WEBSITE_URL,
    Constants_vtt as vtt,
  };
}

/**
 * The abstract base class which defines the data schema contained within a Document.
 * @param [data={}]    Initial data used to construct the data object
 * @param [options={}] Options which affect DataModel construction
 */
declare abstract class DataModel<
  TParent extends DataModel | null = _DataModel | null,
  TSchema extends DataSchema = DataSchema,
> {
  constructor(data?: DeepPartial<SourceFromSchema<DataSchema>>, options?: DataModelConstructionOptions<TParent>);

  /**
   * The source data object for this DataModel instance.
   * Once constructed, the source object is sealed such that no keys may be added nor removed.
   */
  readonly _source: SourceFromSchema<TSchema>;

  /** An immutable reverse-reference to a parent DataModel to which this model belongs. */
  readonly parent: TParent;

  /** The defined and cached Data Schema for all instances of this DataModel. */
  protected static _schema: SchemaField<DataSchema> | undefined;

  /** Configure the data model instance before validation and initialization workflows are performed. */
  protected _configure(): void;

  /* ---------------------------------------- */
  /*  Data Schema                             */
  /* ---------------------------------------- */

  /**
   * Define the data schema for documents of this type.
   * The schema is populated the first time it is accessed and cached for future reuse.
   */
  static defineSchema(): DataSchema;

  /** Define the data schema for documents of this type. */
  static get schema(): SchemaField<DataSchema>;

  /** Define the data schema for this document instance. */
  // PROJECT NOTE: this must be overloaded in an interface merge declaration
  get schema(): SchemaField<TSchema>;

  /** Is the current state of this DataModel invalid? */
  get invalid(): boolean;

  /** An array of validation failure instances which may have occurred when this instance was last validated. */
  get validationFailures(): {
    fields: foundry.data.validation.DataModelValidationFailure | null;
    joint: foundry.data.validation.DataModelValidationFailure | null;
  };

  /* ---------------------------------------- */
  /*  Data Cleaning Methods                   */
  /* ---------------------------------------- */

  /**
   * Initialize the source data for a new DataModel instance.
   * One-time migrations and initial cleaning operations are applied to the source data.
   * @param data      The candidate source data from which the model will be constructed
   * @param [options] Options provided to the model constructor
   * @returns Migrated and cleaned source data which will be stored to the model instance
   */
  protected _initializeSource(data: object, options?: DataModelConstructionOptions<TParent>): this['_source'];

  /**
   * Clean a data source object to conform to a specific provided schema.
   * @param [source]     The source data object
   * @param [options={}] Additional options which are passed to field cleaning methods
   * @returns The cleaned source data
   */
  static cleanData(source?: object, options?: Record<string, unknown>): SourceFromSchema<DataSchema>;

  /* ---------------------------------------- */
  /*  Data Initialization                     */
  /* ---------------------------------------- */

  /** A generator that orders the DataFields in the DataSchema into an expected initialization order. */
  protected static _initializationOrder(): Generator<Record<string, DataField>>;

  /**
   * Initialize the instance by copying data from the source object to instance attributes.
   * This mirrors the workflow of SchemaField#initialize but with some added functionality.
   * @param [options] Options provided to the model constructor
   */
  protected _initialize(options?: Record<string, unknown>): void;

  /** Reset the state of this data instance back to mirror the contained source data, erasing any changes. */
  reset(): void;

  /**
   * Clone a model, creating a new data model by combining current data with provided overrides.
   * @param [data={}]    Additional data which overrides current document data at the time of creation
   * @param [context={}] Context options passed to the data model constructor
   * @returns The cloned Document instance
   */
  clone(data?: Record<string, unknown>, context?: DataModelConstructionOptions<TParent>): this;

  /* ---------------------------------------- */
  /*  Data Validation Methods                 */
  /* ---------------------------------------- */

  /**
   * Validate the data contained in the document to check for type and content
   * This function throws an error if data within the document is not valid
   *
   * @param options Optional parameters which customize how validation occurs.
   * @param [options.changes]        A specific set of proposed changes to validate, rather than the full
   *                                 source data of the model.
   * @param [options.clean=false]    If changes are provided, attempt to clean the changes before validating
   *                                 them?
   * @param [options.fallback=false] Allow replacement of invalid values with valid defaults?
   * @param [options.strict=true]    Throw if an invalid value is encountered, otherwise log a warning?
   * @param [options.fields=true]    Perform validation on individual fields?
   * @param [options.joint]          Perform joint validation on the full data model?
   *                                 Joint validation will be performed by default if no changes are passed.
   *                                 Joint validation will be disabled by default if changes are passed.
   *                                 Joint validation can be performed on a complete set of changes (for
   *                                 example testing a complete data model) by explicitly passing true.
   * @return An indicator for whether the document contains valid data
   */
  validate(options?: DataModelValidationOptions): boolean;

  /**
   * Get an array of validation errors from the provided error structure
   * @param errors
   * @param [options={}]
   * @param [options.label]     A prefix label that should prepend any error messages
   * @param [options.namespace] A field namespace that should prepend key names with dot-notation
   */
  static formatValidationErrors(
    errors: Record<string, string>,
    options?: { label?: string; namespace?: string },
  ): string;

  /**
   * Jointly validate the overall data model after each field has been individually validated.
   * @param data The candidate data object to validate
   * @throws An error if a validation failure is detected
   */
  static validateJoint(data: SourceFromSchema<DataSchema>): void;

  /* ---------------------------------------- */
  /*  Data Management                         */
  /* ---------------------------------------- */

  /**
   * Update the DataModel locally by applying an object of changes to its source data.
   * The provided changes are cleaned, validated, and stored to the source data object for this model.
   * The source data is then re-initialized to apply those changes to the prepared data.
   * The method returns an object of differential changes which modified the original data.
   *
   * @param changes      New values which should be applied to the data model
   * @param [options={}] Options which determine how the new data is merged
   * @returns An object containing the changed keys and values
   */
  updateSource(
    changes?: Record<string, unknown> | undefined,
    options?: DocumentSourceUpdateContext,
  ): DeepPartial<this['_source']>;

  /* ---------------------------------------- */
  /*  Serialization and Storage               */
  /* ---------------------------------------- */

  /**
   * Copy and transform the DataModel into a plain object.
   * Draw the values of the extracted object from the data source (by default) otherwise from its transformed values.
   * @param [source=true] Draw values from the underlying data source rather than transformed values
   * @returns The extracted primitive object
   */
  toObject(source?: true): this['_source'];
  toObject(source: false): RawObject<this>;
  toObject(source?: boolean): this['_source'] | RawObject<this>;

  /**
   * Extract the source data for the DataModel into a simple object format that can be serialized.
   * @returns The document source data expressed as a plain object
   */
  toJSON(): this['_source'];

  /**
   * Create a new instance of this DataModel from a source record.
   * The source is presumed to be trustworthy and is not strictly validated.
   * @param source       Initial document data which comes from a trusted source.
   * @param [context]    Model construction context
   * @param [context.strict=false]  Models created from trusted source data are validated non-strictly
   */
  static fromSource(source: object, context?: { strict?: boolean; [key: string]: unknown }): DataModel;

  /**
   * Create a DataModel instance using a provided serialized JSON string.
   * @param json Serialized document data in string format
   * @returns A constructed data model instance
   */
  static fromJSON(json: string): DataModel;

  /* -------------------------------------------- */
  /*  Deprecations and Compatibility              */
  /* -------------------------------------------- */

  /**
   * Migrate candidate source data for this DataModel which may require initial cleaning or transformations.
   * @param source The candidate source data from which the model will be constructed
   * @returns Migrated source data, if necessary
   */
  static migrateData<T extends DataModel>(this: ConstructorOf<T>, source: Record<string, unknown>): T['_source'];

  /**
   * Wrap data migration in a try/catch which attempts it safely
   * @param source The candidate source data from which the model will be constructed
   * @returns Migrated source data, if necessary
   */
  static migrateDataSafe(source: object): object;
}

interface DataModelValidationOptions {
  changes?: object;
  clean?: boolean;
  fallback?: boolean;
  strict?: boolean;
  fields?: boolean;
  joint?: boolean;
}

declare global {
  type RawObject<TModel extends DataModel> = TModel extends { system: infer TSystem }
    ? Omit<TModel, 'system'> & { system: TSystem }
    : TModel['_source'];

  interface DataModelConstructionOptions<TParent extends DataModel | null> {
    /** A parent DataModel instance to which this DataModel belongs */
    parent?: TParent;
    /** Control the strictness of validation for initially provided data */
    strict?: boolean;
    /** Attempt to replace invalid values with valid defaults? */
    fallback?: boolean;
    /** Allow partial source data, ignoring absent fields? */
    partial?: boolean;
    [key: string]: unknown;
  }

  interface ParentedDataModelConstructionOptions<TParent extends DataModel>
    extends DataModelConstructionOptions<TParent> {
    parent: TParent;
  }
}

type _DataModel = DataModel<_DataModel | null, DataSchema>;

/**
 * The ActiveEffect document model.
 * @param data    Initial data from which to construct the document.
 * @param context Construction context options
 */
declare class BaseActiveEffect<TParent extends BaseActor | BaseItem<BaseActor | null> | null> extends Document$1<
  TParent,
  ActiveEffectSchema
> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): ActiveEffectMetadata;

  static override defineSchema(): ActiveEffectSchema;

  /* -------------------------------------------- */
  /*  Model Methods                               */
  /* -------------------------------------------- */

  override canUserModify(user: BaseUser, action: UserAction, data?: object): boolean;

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;

  /* -------------------------------------------- */
  /*  Database Event Handlers                     */
  /* -------------------------------------------- */

  protected override _preCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    user: BaseUser,
  ): Promise<boolean | void>;
}

interface BaseActiveEffect<TParent extends BaseActor | BaseItem<BaseActor | null> | null>
  extends Document$1<TParent, ActiveEffectSchema>,
    ModelPropsFromSchema<ActiveEffectSchema> {
  get documentName(): ActiveEffectMetadata['name'];
}

interface ActiveEffectMetadata extends DocumentMetadata {
  name: 'ActiveEffect';
  collection: 'effects';
  label: 'DOCUMENT.ActiveEffect';
  isEmbedded: true;
}

type ActiveEffectSchema = {
  _id: DocumentIdField;
  name: StringField<string, string, true, false, false>;
  changes: ArrayField<
    SchemaField<{
      key: StringField<string, string, true, false, false>;
      value: StringField<string, string, true, false, false>;
      mode: NumberField<ActiveEffectChangeMode, ActiveEffectChangeMode, false, false, true>;
      priority: NumberField;
    }>
  >;
  disabled: BooleanField;
  duration: SchemaField<{
    startTime: NumberField<number, number, false, true, true>;
    seconds: NumberField;
    combat: ForeignDocumentField;
    rounds: NumberField;
    turns: NumberField;
    startRound: NumberField;
    startTurn: NumberField;
  }>;
  description: HTMLField;
  icon: FilePathField<ImageFilePath>;
  origin: StringField<ActorUUID | ItemUUID, ActorUUID | ItemUUID, false, true, true>;
  tint: ColorField;
  transfer: BooleanField;
  statuses: SetField<StringField<string, string, true, false, false>>;
  flags: ObjectField<DocumentFlags>;
};

type ActiveEffectSource = SourceFromSchema<ActiveEffectSchema>;
type EffectDurationData = BaseActiveEffect<null>['duration'];

/**
 * The Document definition for an Item.
 * Defines the DataSchema and common behaviors for an Item which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Item
 * @param context Construction context options
 */
declare class BaseItem<TParent extends BaseActor | null> extends Document$1<TParent, ItemSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): ItemMetadata;

  static override defineSchema(): ItemSchema;

  /** The default icon used for newly created Item documents */
  static DEFAULT_ICON: ImageFilePath;

  /**
   * Determine default artwork based on the provided item data.
   * @param The source item data.
   * @returns Candidate item image.
   */
  static getDefaultArtwork(itemData: ItemSource): { img: ImageFilePath };

  /** The allowed set of Item types which may exist. */
  static get TYPES(): string[];

  override canUserModify(user: BaseUser, action: UserAction, data?: Record<string, unknown>): boolean;

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseItem<TParent extends BaseActor | null>
  extends Document$1<TParent, ItemSchema>,
    ModelPropsFromSchema<ItemSchema> {
  get documentName(): ItemMetadata['name'];

  readonly effects: EmbeddedCollection<BaseActiveEffect<this>>;
}

interface ItemMetadata extends DocumentMetadata {
  name: 'Item';
  collection: 'items';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'img', 'type', 'sort', 'folder'];
  embedded: { ActiveEffect: 'effects' };
  label: 'DOCUMENT.Item';
  labelPlural: 'DOCUMENT.Items';
  permissions: Omit<DocumentMetadata['permissions'], 'create'> & {
    create: 'ITEM_CREATE';
  };
}

type ItemSchema<TType extends string = string, TSystemSource extends object = object> = {
  /** The _id which uniquely identifies this Item document */
  _id: DocumentIdField;
  /** The name of this Item */
  name: StringField<string, string, true, false, false>;
  /** An Item subtype which configures the system data model applied */
  type: StringField<TType, TType, true, false, false>;
  /** An image file path which provides the artwork for this Item */
  img: FilePathField<ImageFilePath, ImageFilePath, false, false, true>;
  /** The system data object which is defined by the system template.json model */
  system: TypeDataField<TSystemSource>;
  /** A collection of ActiveEffect embedded Documents */
  effects: EmbeddedCollectionField<BaseActiveEffect<BaseItem<BaseActor | null>>>;
  /** The _id of a Folder which contains this Item */
  folder: ForeignDocumentField<BaseFolder>;
  /** The numeric sort value which orders this Item relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this Item */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<ItemFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type ItemSource<TType extends string = string, TSystemSource extends object = object> = SourceFromSchema<
  ItemSchema<TType, TSystemSource>
>;

interface ItemFlags extends DocumentFlags {
  core?: {
    sourceId?: ItemUUID;
  };
  [key: string]: Record<string, unknown> | undefined;
}

/**
 * The Document definition for an ActorDelta.
 * Defines the DataSchema and common behaviors for an ActorDelta which are shared between both client and server.
 * ActorDeltas store a delta that can be applied to a particular Actor in order to produce a new Actor.
 *
 * @param data    Initial data used to construct the ActorDelta.
 * @param context Construction context options.
 */
declare class BaseActorDelta<TParent extends BaseToken | null> extends Document$1<TParent, ActorDeltaSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override readonly metadata: ActorDeltaMetadata;

  static override defineSchema(): ActorDeltaSchema;

  override canUserModify(user: BaseUser, action: UserAction, data?: Record<string, unknown>): boolean;

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /**
   * Retrieve the base actor's collection, if it exists.
   * @param collectionName  The collection name.
   */
  getBaseCollection(collectionName: string): Collection<BaseActor> | undefined;

  /**
   * Apply an ActorDelta to an Actor and return the resultant synthetic Actor.
   * @param {ActorDelta} delta  The ActorDelta.
   * @param {Actor} baseActor   The base Actor.
   * @param {object} [context]  Context to supply to synthetic Actor instantiation.
   * @returns {Actor|null}
   */
  static applyDelta(
    delta: BaseActorDelta<BaseToken | null>,
    baseActor: BaseActor,
    context?: DocumentConstructionContext<BaseToken | null>,
  ): BaseActor;
}

interface BaseActorDelta<TParent extends BaseToken | null>
  extends Document$1<TParent, ActorDeltaSchema>,
    ModelPropsFromSchema<ActorDeltaSchema> {}

interface ActorDeltaMetadata extends DocumentMetadata {
  name: 'ActorDelta';
  collection: 'delta';
  label: 'DOCUMENT.ActorDelta';
  labelPlural: 'DOCUMENT.ActorDeltas';
  isEmbedded: true;
  embedded: {
    Item: 'items';
    ActiveEffect: 'effects';
  };
}

type ActorDeltaSchema = {
  _id: DocumentIdField;
  name: StringField<string, string, false, true, true>;
  type: StringField<string, string, false, true, true>;
  img: FilePathField<ImageFilePath, ImageFilePath, false, true, true>;
  system: ObjectField<object, object, true, true, true>;
  items: EmbeddedCollectionDeltaField<
    BaseItem<BaseActor>,
    (DocumentSourceFromSchema<ItemSchema, true> | SourceFromSchema<TombstoneDataSchema>)[]
  >;
  effects: EmbeddedCollectionDeltaField<BaseActiveEffect<BaseActor>>;
  ownership: DocumentOwnershipField;
  flags: ObjectField<DocumentFlags>;
};

/**
 * The Document definition for an Actor.
 * Defines the DataSchema and common behaviors for an Actor which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Actor
 * @param context Construction context options
 */
declare class BaseActor<TParent extends BaseToken | null = BaseToken | null> extends Document$1<TParent, ActorSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): ActorMetadata;

  static override defineSchema(): ActorSchema;

  /** The default icon used for newly created Actor documents */
  static DEFAULT_ICON: ImageFilePath;

  /**
   * Determine default artwork based on the provided actor data.
   * @param actorData The source actor data.
   * @returns Candidate actor image and prototype token artwork.
   */
  static getDefaultArtwork(actorData: ActorSource): {
    img: ImageFilePath;
    texture: { src: ImageFilePath | VideoFilePath };
  };

  /** The allowed set of Actor types which may exist. */
  static get TYPES(): string[];

  protected override _initializeSource(
    data: Record<string, unknown>,
    options?: DocumentConstructionContext<TParent>,
  ): this['_source'];

  static override canUserCreate(user: BaseUser): boolean;

  protected override _preCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    user: BaseUser,
  ): Promise<boolean | void>;

  protected override _preUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    user: BaseUser,
  ): Promise<boolean | void>;
}

interface BaseActor<TParent extends BaseToken | null = BaseToken | null>
  extends Document$1<TParent, ActorSchema>,
    ModelPropsFromSchema<ActorSchema> {
  readonly items: EmbeddedCollection<BaseItem<this>>;
  readonly effects: EmbeddedCollection<BaseActiveEffect<this>>;

  prototypeToken: foundry.data.PrototypeToken<this>;

  get documentName(): ActorMetadata['name'];
}

interface ActorMetadata extends DocumentMetadata {
  name: 'Actor';
  collection: 'actors';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'img', 'type', 'sort', 'folder'];
  embedded: { ActiveEffect: 'effects'; Item: 'items' };
  label: 'DOCUMENT.Actor';
  labelPlural: 'DOCUMENT.Actors';
}

type ActorSchema<
  TType extends string = string,
  TSystemSource extends object = object,
  TItemSource extends ItemSource = ItemSource,
> = {
  /** The _id which uniquely identifies this Actor document */
  _id: DocumentIdField;
  /** The name of this Actor */
  name: StringField<string, string, true, false, false>;
  /** An Actor subtype which configures the system data model applied */
  type: StringField<TType, TType, true, false, false>;
  /** An image file path which provides the artwork for this Actor */
  img: FilePathField<ImageFilePath, ImageFilePath, false, false, true>;
  /** The system data object which is defined by the system template.json model */
  system: TypeDataField<TSystemSource>;
  /** Default Token settings which are used for Tokens created from this Actor */
  prototypeToken: EmbeddedDataField<PrototypeToken<BaseActor>>;
  /** A Collection of Item embedded Documents */
  items: EmbeddedCollectionField<BaseItem<BaseActor<BaseToken | null>>, TItemSource[]>;
  /** A Collection of ActiveEffect embedded Documents */
  effects: EmbeddedCollectionField<BaseActiveEffect<BaseActor<BaseToken | null>>>;
  /** The _id of a Folder which contains this Actor */
  folder: ForeignDocumentField<BaseFolder>;
  /** The numeric sort value which orders this Actor relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this Actor */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<ActorFlags>;
  /** An object of creation and access information. */
  _stats: DocumentStatsField;
};

type ActorFlags = DocumentFlags & {
  core?: {
    sourceId?: ActorUUID;
  };
};

type ActorSource<
  TType extends string = string,
  TSystemSource extends object = object,
  TItemSource extends foundry.documents.ItemSource = foundry.documents.ItemSource,
> = SourceFromSchema<ActorSchema<TType, TSystemSource, TItemSource>>;

/**
 * The Document definition for an Adventure.
 * Defines the DataSchema and common behaviors for an Adventure which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Actor
 * @param context Construction context options
 */
declare class BaseAdventure extends Document$1<null, AdventureSchema> {
  static override get metadata(): AdventureMetadata;

  static override defineSchema(): AdventureSchema;

  /* ---------------------------------------- */
  /*  Permissions                             */
  /* ---------------------------------------- */

  /** Test whether the User has a GAMEMASTER or ASSISTANT role in this World? */
  get isGM(): boolean;

  /**
   * Test whether the User is able to perform a certain permission action.
   * The provided permission string may pertain to an explicit permission setting or a named user role.
   * Alternatively, Gamemaster users are assumed to be allowed to take all actions.
   *
   * @param action The action to test
   * @return Does the user have the ability to perform this action?
   */
  can(action: UserAction): boolean;

  getUserLevel(user: BaseUser): DocumentOwnershipLevel;

  /**
   * Test whether the User has at least a specific permission
   * @param permission The permission name from USER_PERMISSIONS to test
   * @return Does the user have at least this permission
   */
  hasPermission(permission: UserPermission): boolean;

  /**
   * Test whether the User has at least the permission level of a certain role
   * @param role The role name from USER_ROLES to test
   * @param [exact] Require the role match to be exact
   * @return Does the user have at this role level (or greater)?
   */
  hasRole(role: UserRole | UserRoleName, { exact }?: { exact: boolean }): boolean;
}

interface BaseAdventure extends Document$1<null, AdventureSchema>, ModelPropsFromSchema<AdventureSchema> {
  get documentName(): AdventureMetadata['name'];
}

interface AdventureMetadata extends DocumentMetadata {
  name: 'Adventure';
  collection: 'Adventures';
  label: 'DOCUMENT.Adventure';
  isPrimary: true;
}

type AdventureSchema = {
  /** The _id which uniquely identifies this Adventure document */
  _id: DocumentIdField;
  /** The human-readable name of the Adventure */
  name: StringField<string, string, true, false, false>;
  /** The human-readable name of the Adventure*/
  img: FilePathField<ImageFilePath>;
  /** A string caption displayed under the primary image banner */
  caption: HTMLField;
  /** An HTML text description for the adventure */
  description: HTMLField;
  /** An array of Actor documents which are included in the adventure */
  actors: SetField<EmbeddedDataField<BaseActor<null>>>;
  /** An array of Combat documents which are included in the adventure */
  combats: SetField<EmbeddedDataField<BaseCombat>>;
  /** An array of Item documents which are included in the adventure */
  items: SetField<EmbeddedDataField<BaseItem<null>>>;
  /** An array of JournalEntry documents which are included in the adventure */
  journal: SetField<EmbeddedDataField<BaseJournalEntry>>;
  /** An array of Scene documents which are included in the adventure */
  scenes: SetField<EmbeddedDataField<BaseScene>>;
  /** An array of RollTable documents which are included in the adventure */
  tables: SetField<EmbeddedDataField<BaseRollTable>>;
  /** An array of Macro documents which are included in the adventure */
  macros: SetField<EmbeddedDataField<BaseMacro>>;
  /** An array of Cards documents which are included in the adventure */
  cards: SetField<EmbeddedDataField<BaseCards>>;
  /** An array of Playlist documents which are included in the adventure */
  playlists: SetField<EmbeddedDataField<BasePlaylist>>;
  /** An array of Folder documents which are included in the adventure */
  folders: SetField<EmbeddedDataField<BaseFolder>>;
  folder: ForeignDocumentField<BaseFolder>;
  /** The sort order of this adventure relative to its siblings */
  sort: IntegerSortField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type AdventureSource = SourceFromSchema<AdventureSchema>;

/** The AmbientLight embedded document model. */
declare class BaseAmbientLight<TParent extends BaseScene | null> extends Document$1<TParent, AmbientLightSchema> {
  static override get metadata(): AmbientLightMetadata;

  static override defineSchema(): AmbientLightSchema;

  protected override _initialize(): void;
}

interface BaseAmbientLight<TParent extends BaseScene | null>
  extends Document$1<TParent, AmbientLightSchema>,
    ModelPropsFromSchema<AmbientLightSchema> {
  light: LightData<this>;
}

interface AmbientLightMetadata extends DocumentMetadata {
  name: 'AmbientLight';
  collection: 'lights';
  label: 'DOCUMENT.AmbientLight';
  isEmbedded: true;
}

type AmbientLightSchema = {
  /** The _id which uniquely identifies this BaseAmbientLight embedded document */
  _id: DocumentIdField;
  /** The x-coordinate position of the origin of the light */
  x: NumberField<number, number, true, false, true>;
  /** The y-coordinate position of the origin of the light */
  y: NumberField<number, number, true, false, true>;
  /** The angle of rotation for the tile between 0 and 360 */
  rotation: AngleField;
  /** Whether or not this light source is constrained by Walls */
  walls: BooleanField;
  /** Whether or not this light source provides a source of vision */
  vision: BooleanField;
  /** Light configuration data */
  config: EmbeddedDataField<LightData<BaseAmbientLight<BaseScene | null>>>;
  /** Is the light source currently hidden? */
  hidden: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

/**
 * The Document definition for an AmbientSound.
 * Defines the DataSchema and common behaviors for an AmbientSound which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the AmbientSound
 * @param context Construction context options
 */
declare class BaseAmbientSound<TParent extends BaseScene | null> extends Document$1<TParent, AmbientSoundSchema> {
  static override get metadata(): AmbientSoundMetadata;

  static defineSchema(): AmbientSoundSchema;
}

interface BaseAmbientSound<TParent extends BaseScene | null>
  extends Document$1<TParent, AmbientSoundSchema>,
    ModelPropsFromSchema<AmbientSoundSchema> {
  get documentName(): AmbientSoundMetadata['name'];
}

interface AmbientSoundMetadata extends DocumentMetadata {
  name: 'AmbientSound';
  collection: 'sounds';
  label: 'DOCUMENT.AmbientSound';
  labelPlural: 'DOCUMENT.AmbientSounds';
  isEmbedded: true;
}

/**
 * @typedef {Object} AmbientSoundData

 * @property {{min: number, max: number}} darkness  A darkness range (min and max) for which the source should be active
 * @property {object} [flags]             An object of optional key/value flags
 */
type AmbientSoundSchema = {
  /** The _id which uniquely identifies this AmbientSound document */
  _id: DocumentIdField;
  /** The x-coordinate position of the origin of the sound. */
  x: NumberField<number, number, true, false, true>;
  /** The y-coordinate position of the origin of the sound. */
  y: NumberField<number, number, true, false, true>;
  /** The radius of the emitted sound. */
  radius: NumberField<number, number, true, false, true>;
  /** The audio file path that is played by this sound */
  path: FilePathField<AudioFilePath>;
  /** Does this sound loop? */
  repeat: BooleanField;
  /** The audio volume of the sound, from 0 to 1 */
  volume: AlphaField;
  /** Whether or not this sound source is constrained by Walls. */
  walls: BooleanField;
  /**
   * Whether to adjust the volume of the sound heard by the listener based on how close the listener is to the center
   * of the sound source.
   */
  easing: BooleanField;
  /** Is the sound source currently hidden? */
  hidden: BooleanField;
  /** A darkness range (min and max) for which the source should be active */
  darkness: SchemaField<{
    min: AlphaField;
    max: AlphaField;
  }>;
  /** A darkness range (min and max) for which the source should be active */
  flags: ObjectField<DocumentFlags>;
};

/**
 * The data schema for a AmbientSound embedded document.
 * @see BaseAmbientSound
 *
 * @param data Initial data used to construct the data object
 * @param [document] The document to which this data object belongs
 *
 * @property _id             The _id which uniquely identifies this AmbientSound document
 * @property path            The audio file path that is played by this sound
 * @property [playing=false] Is this sound currently playing?
 * @property [repeat=false]  Does this sound loop?
 * @property [volume=0.5]    The audio volume of the sound, from 0 to 1
 * @property [flags={}]      An object of optional key/value flags
 */
type AmbientSoundSource = SourceFromSchema<AmbientSoundSchema>;

/**
 * The Document definition for a Card.
 * Defines the DataSchema and common behaviors for a Card which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Card
 * @param context Construction context options
 */
declare class BaseCard<TParent extends BaseCards | null> extends Document$1<TParent, CardSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): CardMetadata;

  static override defineSchema(): CardSchema;

  /** The default icon used for a Card face that does not have a custom image set */
  static DEFAULT_ICON: ImageFilePath | VideoFilePath;

  /** The allowed set of Card types which may exist */
  static get TYPES(): string;

  /* -------------------------------------------- */
  /*  Model Methods                               */
  /* -------------------------------------------- */

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean | undefined },
  ): boolean;
}

interface BaseCard<TParent extends BaseCards | null>
  extends Document$1<TParent, CardSchema>,
    ModelPropsFromSchema<CardSchema> {
  get documentName(): CardMetadata['name'];
}

interface CardMetadata extends DocumentMetadata {
  name: 'Card';
  collection: 'cards';
  indexed: true;
  label: 'DOCUMENT.Card';
  labelPlural: 'DOCUMENT.Cards';
}

type CardSchema = {
  /** The _id which uniquely identifies this Card document */
  _id: DocumentIdField;
  /** The text name of this card */
  name: StringField<string, string, true, false, false>;
  /** A text description of this card which applies to all faces */
  description: HTMLField;
  /** A category of card (for example, a suit) to which this card belongs */
  type: StringField<string, string, true, false, false>;
  /** Game system data which is defined by the system template.json model */
  system: TypeDataField;
  /** An optional suit designation which is used by default sorting */
  suit: StringField;
  /** An optional numeric value of the card which is used by default sorting */
  value: NumberField;
  /** An object of face data which describes the back of this card */
  back: SchemaField<CardFaceSchema>;
  /** An array of face data which represent displayable faces of this card */
  faces: ArrayField<SchemaField<CardFaceSchema>>;
  /** The index of the currently displayed face, or null if the card is face-down */
  face: NumberField<number, number, true>;
  /** Whether this card is currently drawn from its source deck */
  drawn: BooleanField;
  /** The document ID of the origin deck to which this card belongs */
  origin: ForeignDocumentField<BaseCards>;
  /** The visible width of this card */
  width: NumberField;
  /** The visible height of this card */
  height: NumberField;
  /** The angle of rotation of this card */
  rotation: AngleField;
  /** The sort order of this card relative to others in the same stack */
  sort: IntegerSortField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type CardFaceSchema = {
  /** A name for this card face */
  name: StringField<string, string, false, false, true>;
  /** Displayed text that belongs to this face */
  text: HTMLField;
  /** A displayed image or video file which depicts the face */
  img: FilePathField<ImageFilePath | VideoFilePath>;
};

type CardFaceData = ModelPropsFromSchema<CardFaceSchema>;

/**
 * The Document definition for Cards.
 * Defines the DataSchema and common behaviors for Cards which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Cards
 * @param context Construction context options
 */
declare class BaseCards extends Document$1<null, CardsSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): CardsMetadata;

  static override defineSchema(): CardsSchema;

  /** The default icon used for a cards stack that does not have a custom image set */
  static DEFAULT_ICON: ImageFilePath | VideoFilePath;

  static get TYPES(): string[];

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseCards extends Document$1<null, CardsSchema>, ModelPropsFromSchema<CardsSchema> {
  get documentName(): CardsMetadata['name'];
}

interface CardsMetadata extends DocumentMetadata {
  name: 'Cards';
  collection: 'cards';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'description', 'img', 'type', 'sort', 'folder'];
  embedded: { Card: 'cards' };
  label: 'DOCUMENT.Cards';
  labelPlural: 'DOCUMENT.CardsPlural';
  permissions: {
    create: 'CARDS_CREATE';
    update: MetadataPermission;
    delete: MetadataPermission;
  };
  coreTypes: ['deck', 'hand', 'pile'];
}

type CardsSchema = {
  /** The _id which uniquely identifies this stack of Cards document */
  _id: DocumentIdField;
  /** The text name of this stack */
  name: StringField<string, string, true, false, false>;
  /** The type of this stack, in BaseCards.metadata.types */
  type: StringField<CardsType, CardsType, true, false, true>;
  /** A text description of this stack */
  description: HTMLField;
  /** An image or video which is used to represent the stack of cards */
  img: FilePathField<ImageFilePath | VideoFilePath>;
  /** Game system data which is defined by the system template.json model */
  system: TypeDataField;
  /** A collection of Card documents which currently belong to this stack */
  cards: EmbeddedCollectionField<BaseCard<BaseCards>>;
  /** The visible width of this stack */
  width: NumberField;
  /** The visible height of this stack */
  height: NumberField;
  /** The angle of rotation of this stack */
  rotation: AngleField;
  /** Whether or not to publicly display the number of cards in this stack */
  displayCount: BooleanField;
  /** The _id of a Folder which contains this document */
  folder: ForeignDocumentField<BaseFolder>;
  /** The sort order of this stack relative to others in its parent collection */
  sort: IntegerSortField;
  /** An object which configures user permissions to this stack */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type CardsType = CardsMetadata['coreTypes'][number];

/**
 * The ChatMessage document model.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the document.
 * @property data The constructed data object for the document.
 */
declare class BaseChatMessage extends Document$1<null, ChatMessageSchema> {
  rolls: Rolled<Roll>[];

  static override get metadata(): ChatMessageMetadata;

  static override defineSchema(): ChatMessageSchema;
}

interface BaseChatMessage extends Document$1<null, ChatMessageSchema>, ModelPropsFromSchema<ChatMessageSchema> {
  get documentName(): ChatMessageMetadata['name'];
}

type ChatMessageSchema = {
  /** The _id which uniquely identifies this ChatMessage document */
  _id: DocumentIdField;
  /** The message type from CONST.CHAT_MESSAGE_TYPES */
  type: NumberField<ChatMessageType, ChatMessageType, true, true, true>;
  /** The _id of the User document who generated this message */
  user: ForeignDocumentField<BaseUser, true, false, true>;
  /** The timestamp at which point this message was generated */
  timestamp: NumberField<number, number, true, false, true>;
  /** An optional flavor text message which summarizes this message */
  flavor: HTMLField;
  /** The HTML content of this chat message */
  content: HTMLField;
  /** A ChatSpeakerData object which describes the origin of the ChatMessage */
  speaker: SchemaField<ChatSpeakerSchema>;
  /** An array of User _id values to whom this message is privately whispered */
  whisper: ArrayField<ForeignDocumentField<string>>;
  /** Is this message sent blindly where the creating User cannot see it? */
  blind: BooleanField;
  /** Serialized content of any Roll instances attached to the ChatMessage */
  rolls: ArrayField<JSONField<Roll, true>>;
  /** The URL of an audio file which plays when this message is received */
  sound: FilePathField<AudioFilePath>;
  /** Is this message styled as an emote? */
  emote: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<ChatMessageFlags>;
};

type ChatMessageSource = SourceFromSchema<ChatMessageSchema>;

interface ChatMessageFlags extends DocumentFlags {
  core?: {
    canPopout?: boolean;
    initiativeRoll?: boolean;
    RollTable?: string;
  };
}

type ChatSpeakerSchema = {
  /** The _id of the Scene where this message was created */
  scene: ForeignDocumentField<string>;
  /** The _id of the Actor who generated this message */
  actor: ForeignDocumentField<string>;
  /** The _id of the Token who generated this message */
  token: ForeignDocumentField<string>;
  /** An overridden alias name used instead of the Actor or Token name */
  alias: StringField<string, string, false, false, true>;
};

type ChatSpeakerData = SourceFromSchema<ChatSpeakerSchema>;

interface ChatMessageMetadata extends DocumentMetadata {
  name: 'ChatMessage';
  collection: 'messages';
  label: 'DOCUMENT.ChatMessage';
  labelPlural: 'DOCUMENT.ChatMessages';
  isPrimary: true;
}

declare global {
  interface ChatMessageModificationContext extends DocumentModificationContext<null> {
    rollMode?: RollMode | 'roll';
  }
}

/** The Combat document model. */
declare class BaseCombat extends Document$1<null, CombatSchema> {
  static override get metadata(): CombatMetadata;

  static override defineSchema(): CombatSchema;
}

interface BaseCombat extends Document$1<null, CombatSchema>, ModelPropsFromSchema<CombatSchema> {
  readonly combatants: EmbeddedCollection<BaseCombatant<this>>;

  get documentName(): CombatMetadata['name'];
}

interface CombatMetadata extends DocumentMetadata {
  name: 'Combat';
  collection: 'combats';
  label: 'DOCUMENT.Combat';
  embedded: {
    Combatant: 'combatants';
  };
  isPrimary: true;
}

type CombatSchema = {
  /** The _id which uniquely identifies this Combat document */
  _id: DocumentIdField;
  /** The _id of a Scene within which this Combat occurs */
  scene: ForeignDocumentField<BaseScene>;
  /** A Collection of Combatant embedded Documents */
  combatants: EmbeddedCollectionField<BaseCombatant<BaseCombat>>;
  /** Is the Combat encounter currently active? */
  active: BooleanField;
  /** The current round of the Combat encounter */
  round: NumberField<number, number, true, false, true>;
  /** The current turn in the Combat round */
  turn: NumberField<number, number, true, true, true>;
  /** The current sort order of this Combat relative to others in the same Scene */
  sort: IntegerSortField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  _stats: DocumentStatsField;
};

type CombatSource = SourceFromSchema<CombatSchema>;

/** The Combat document model. */
declare class BaseCombatant<TParent extends BaseCombat | null> extends Document$1<TParent, CombatantSchema> {
  static override get metadata(): CombatantMetadata;

  static override defineSchema(): CombatantSchema;
}

interface BaseCombatant<TParent extends BaseCombat | null>
  extends Document$1<TParent, CombatantSchema>,
    ModelPropsFromSchema<CombatantSchema> {
  get documentName(): CombatantMetadata['name'];
}

interface CombatantMetadata extends DocumentMetadata {
  name: 'Combatant';
  collection: 'combatants';
  label: 'DOCUMENT.Combatant';
  isPrimary: true;
}

/** The data schema for a Combat document. */
type CombatantSchema = {
  /** The _id which uniquely identifies this Combatant embedded document */
  _id: DocumentIdField;
  /** The _id of an Actor associated with this Combatant */
  actorId: ForeignDocumentField<string>;
  /** The _id of a Token associated with this Combatant */
  tokenId: ForeignDocumentField<string>;
  /** A customized name which replaces the name of the Token in the tracker */
  sceneId: ForeignDocumentField<string>;
  /** A customized image which replaces the Token image in the tracker */
  name: StringField<string, string, false, false, true>;
  /** A customized image which replaces the Token image in the tracker */
  img: FilePathField<ImageFilePath>;
  /** The initiative score for the Combatant which determines its turn order */
  initiative: NumberField;
  /** Is this Combatant currently hidden? */
  hidden: BooleanField;
  /** Has this Combatant been defeated? */
  defeated: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type CombatantSource = SourceFromSchema<CombatantSchema>;

/**
 * The Document definition for a Drawing.
 * Defines the DataSchema and common behaviors for a Drawing which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Drawing
 * @param context Construction context options
 */
declare class BaseDrawing<TParent extends BaseScene | null> extends Document$1<TParent, DrawingSchema> {
  /* ---------------------------------------- */
  /*  Model Configuration                     */
  /* ---------------------------------------- */

  static override get metadata(): DrawingMetadata;

  static override defineSchema(): DrawingSchema;

  static override validateJoint(data: DrawingSource): void;

  /* ---------------------------------------- */
  /*  Model Methods                           */
  /* ---------------------------------------- */

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseDrawing<TParent extends BaseScene | null>
  extends Document$1<TParent, DrawingSchema>,
    ModelPropsFromSchema<DrawingSchema> {
  get documentName(): DrawingMetadata['name'];
}

interface DrawingMetadata extends DocumentMetadata {
  name: 'Drawing';
  collection: 'drawings';
  label: 'DOCUMENT.Drawing';
  labelPlural: 'DOCUMENT.Drawings';
  isEmbedded: true;
  permissions: {
    create: 'DRAWING_CREATE';
    update: MetadataPermission;
    delete: MetadataPermission;
  };
}

type DrawingSchema = {
  /** The _id which uniquely identifies this BaseDrawing embedded document */
  _id: DocumentIdField;
  /** The _id of the user who created the drawing */
  author: ForeignDocumentField<BaseUser, true, false, true>;
  /** The geometric shape of the drawing */
  shape: EmbeddedDataField<ShapeData<BaseDrawing<BaseScene | null>>>;
  /** The x-coordinate position of the top-left corner of the drawn shape */
  x: NumberField<number, number, true, false, true>;
  /** The y-coordinate position of the top-left corner of the drawn shape */
  y: NumberField<number, number, true, false, true>;
  /** The z-index of this drawing relative to other siblings */
  z: NumberField<number, number, true, false, true>;
  /** The angle of rotation for the drawing figure */
  rotation: AngleField;
  /** An amount of bezier smoothing applied, between 0 and 1 */
  bezierFactor: AlphaField;
  /** The fill type of the drawing shape, a value from CONST.DRAWING_FILL_TYPES */
  fillType: NumberField<DrawingFillType, DrawingFillType, true, true, true>;
  /** An optional color string with which to fill the drawing geometry */
  fillColor: ColorField;
  /** The opacity of the fill applied to the drawing geometry */
  fillAlpha: AlphaField;
  /** The width in pixels of the boundary lines of the drawing geometry */
  strokeWidth: NumberField;
  /** The color of the boundary lines of the drawing geometry */
  strokeColor: ColorField;
  /** The opacity of the boundary lines of the drawing geometry */
  strokeAlpha: AlphaField;
  /** The path to a tiling image texture used to fill the drawing geometry */
  texture: FilePathField<ImageFilePath>;
  /** Optional text which is displayed overtop of the drawing */
  text: StringField;
  /** The font family used to display text within this drawing, defaults to CONFIG.defaultFontFamily */
  fontFamily: StringField;
  /** The font size used to display text within this drawing */
  fontSize: NumberField;
  /** The color of text displayed within this drawing */
  textColor: ColorField;
  /** The opacity of text displayed within this drawing */
  textAlpha: AlphaField;
  /** Is the drawing currently hidden? */
  hidden: BooleanField;
  /** Is the drawing currently locked? */
  locked: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type DrawingSource = SourceFromSchema<DrawingSchema>;

/**
 * The Document definition for FogExploration.
 * Defines the DataSchema and common behaviors for FogExploration which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the FogExploration
 * @param context Construction context options
 */
declare class BaseFogExploration extends Document$1<null, FogExplorationSchema> {
  static override get metadata(): FogExplorationMetadata;

  static override defineSchema(): FogExplorationSchema;

  protected override _preUpdate(
    changed: Record<string, unknown>,
    options: DocumentModificationContext<null>,
    user: BaseUser,
  ): Promise<boolean | void>;
}

interface BaseFogExploration
  extends Document$1<null, FogExplorationSchema>,
    ModelPropsFromSchema<FogExplorationSchema> {
  get documentName(): FogExplorationMetadata['name'];
}

interface FogExplorationMetadata extends DocumentMetadata {
  name: 'FogExploration';
  collection: 'fog';
  label: 'DOCUMENT.FogExploration';
  labelPlural: 'DOCUMENT.FogExplorations';
  isPrimary: true;
}

type FogExplorationSchema = {
  /** The _id which uniquely identifies this FogExploration document */
  _id: DocumentIdField;
  /** The _id of the Scene document to which this fog applies */
  scene: ForeignDocumentField<BaseScene>;
  /** The _id of the User document to which this fog applies */
  user: ForeignDocumentField<BaseUser>;
  /** The base64 png image of the explored fog polygon */
  explored: FilePathField<ImageFilePath, ImageFilePath, true>;
  /** The object of scene positions which have been explored at a certain vision radius */
  positions: ObjectField<object>;
  /** The timestamp at which this fog exploration was last updated */
  timestamp: NumberField<number, number, false, true, true>;
  flags: ObjectField<DocumentFlags>;
};

type FogExplorationSource = SourceFromSchema<FogExplorationSchema>;

/**
 * The Folder Document model.
 *
 * @param data Initial data from which to construct the document.
 * @property data The constructed data object for the document.
 */
declare class BaseFolder extends Document$1<null, FolderSchema> {
  static override get metadata(): FolderMetadata;

  static override defineSchema(): FolderSchema;

  static override validateJoint(data: FolderSource): void;

  /** Allow folder sorting modes */
  static SORTING_MODES: ['a', 'm'];
}

interface BaseFolder extends Document$1<null, FolderSchema>, ModelPropsFromSchema<FolderSchema> {
  get documentName(): FolderMetadata['name'];
}

interface FolderMetadata extends DocumentMetadata {
  name: 'Folder';
  collection: 'folders';
  label: 'DOCUMENT.Folder';
  labelPlural: 'DOCUMENT.Folders';
  coreTypes: typeof CONST.FOLDER_DOCUMENT_TYPES;
}

type FolderSortingMode = (typeof BaseFolder.SORTING_MODES)[number];

type FolderSchema = {
  /** The _id which uniquely identifies this Folder document */
  _id: DocumentIdField;
  /** The name of this Folder */
  name: StringField<string, string, true, false, false>;
  /** The document type which this Folder contains, from CONST.FOLDER_DOCUMENT_TYPES */
  type: StringField<FolderDocumentType, FolderDocumentType, true, false, false>;
  /** An HTML description of the contents of this folder */
  description: StringField<string, string, false, false, true>;
  folder: ForeignDocumentField<BaseFolder>;
  /** The sorting mode used to organize documents within this Folder, in ["a", "m"] */
  sorting: StringField<FolderSortingMode, FolderSortingMode, true, false, true>;
  /** The numeric sort value which orders this Folder relative to its siblings */
  sort: IntegerSortField;
  /** A color string used for the background color of this Folder */
  color: ColorField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  _stats: DocumentStatsField;
};

type FolderSource = SourceFromSchema<FolderSchema>;

/** The JournalEntry document model. */
declare class BaseJournalEntry extends Document$1<null, JournalEntrySchema> {
  static override get metadata(): JournalEntryMetadata;

  static override defineSchema(): JournalEntrySchema;
}

interface BaseJournalEntry extends Document$1<null, JournalEntrySchema>, ModelPropsFromSchema<JournalEntrySchema> {
  readonly pages: EmbeddedCollection<BaseJournalEntryPage<this>>;

  get documentName(): (typeof BaseJournalEntry)['metadata']['name'];
}

interface JournalEntryMetadata extends DocumentMetadata {
  name: 'JournalEntry';
  collection: 'journal';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'sort'];
  embedded: {
    JournalEntryPage: 'pages';
  };
  label: 'DOCUMENT.JournalEntry';
  labelPlural: 'DOCUMENT.JournalEntries';
  isPrimary: true;
  permissions: Omit<DocumentMetadata['permissions'], 'create'> & {
    create: 'JOURNAL_CREATE';
  };
}

type JournalEntrySchema = {
  /** The _id which uniquely identifies this JournalEntry document */
  _id: DocumentIdField;
  /** The name of this JournalEntry */
  name: StringField<string, string, true, false, false>;
  /** The pages contained within this JournalEntry document */
  pages: EmbeddedCollectionField<BaseJournalEntryPage<BaseJournalEntry>>;
  /** The _id of a Folder which contains this JournalEntry */
  folder: ForeignDocumentField<BaseFolder>;
  /** The numeric sort value which orders this JournalEntry relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this JournalEntry */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type JournalEntrySource = SourceFromSchema<JournalEntrySchema>;

/**
 * The Document definition for a Macro.
 * Defines the DataSchema and common behaviors for a Macro which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Macro
 * @param context Construction context options
 */
declare class BaseMacro extends Document$1<null, MacroSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): MacroMetadata;

  static override defineSchema(): MacroSchema;

  /** The default icon used for newly created Macro documents. */
  static DEFAULT_ICON: ImageFilePath;

  /* -------------------------------------------- */
  /*  Model Methods                               */
  /* -------------------------------------------- */

  override testUserPermission(user: BaseUser, permission: unknown, options?: { exact?: boolean }): boolean;

  /* -------------------------------------------- */
  /*  Database Event Handlers                     */
  /* -------------------------------------------- */

  protected override _preCreate(
    data: this['_source'],
    options: DocumentModificationContext<null>,
    user: BaseUser,
  ): Promise<boolean | void>;
}

interface BaseMacro extends Document$1<null, MacroSchema>, ModelPropsFromSchema<MacroSchema> {
  get documentName(): MacroMetadata['name'];
}

interface MacroMetadata extends DocumentMetadata {
  name: 'Macro';
  collection: 'macros';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'img', 'sort', 'folder'];
  label: 'DOCUMENT.Macro';
  labelPlural: 'DOCUMENT.Macros';
  coreTypes: MacroType[];
  permissions: {
    create: 'PLAYER';
    update: MetadataPermission;
    delete: MetadataPermission;
  };
}

type MacroSchema = {
  /** The _id which uniquely identifies this Macro document */
  _id: DocumentIdField;
  /** The name of this Macro */
  name: StringField<string, string, true, false, false>;
  /** A Macro subtype from CONST.MACRO_TYPES */
  type: StringField<MacroType, MacroType, true, false, true>;
  /** The _id of a User document which created this Macro */
  author: ForeignDocumentField<BaseUser>;
  /** An image file path which provides the thumbnail artwork for this Macro */
  img: FilePathField<ImageFilePath>;
  /** The scope of this Macro application from CONST.MACRO_SCOPES */
  scope: StringField<MacroScope, MacroScope, true, false, true>;
  /** The string content of the macro command */
  command: StringField<string, string, true, false, true>;
  /** The _id of a Folder which contains this Macro */
  folder: ForeignDocumentField;
  /** The numeric sort value which orders this Macro relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this Macro */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type MacroSource = SourceFromSchema<MacroSchema>;

/**
 * The data schema for a MeasuredTemplate embedded document.
 * @see BaseMeasuredTemplate
 *
 * @param data                   Initial data used to construct the data object
 * @param [document] The embedded document to which this data object belongs
 */
declare class BaseMeasuredTemplate<TParent extends BaseScene | null> extends Document$1<
  TParent,
  MeasuredTemplateSchema
> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): MeasuredTemplateMetadata;

  static override defineSchema(): MeasuredTemplateSchema;

  /* -------------------------------------------- */
  /*  Model Methods                               */
  /* -------------------------------------------- */

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseMeasuredTemplate<TParent extends BaseScene | null>
  extends Document$1<TParent, MeasuredTemplateSchema>,
    ModelPropsFromSchema<MeasuredTemplateSchema> {
  get documentName(): MeasuredTemplateMetadata['name'];
}

interface MeasuredTemplateMetadata extends DocumentMetadata {
  name: 'MeasuredTemplate';
  collection: 'templates';
  label: 'DOCUMENT.MeasuredTemplate';
  isEmbedded: true;
}

type MeasuredTemplateSchema = {
  /** The _id which uniquely identifies this BaseMeasuredTemplate embedded document */
  _id: DocumentIdField;
  /** The _id of the user who created this measured template */
  user: ForeignDocumentField<BaseUser>;
  /** The value in CONST.MEASURED_TEMPLATE_TYPES which defines the geometry type of this template */
  t: StringField<MeasuredTemplateType, MeasuredTemplateType, true>;
  /** The x-coordinate position of the origin of the template effect */
  x: NumberField<number, number, true, false>;
  /** The y-coordinate position of the origin of the template effect */
  y: NumberField<number, number, true, false>;
  /** The distance of the template effect */
  distance: NumberField<number, number, true>;
  /** The angle of rotation for the measured template */
  direction: AngleField;
  /** The angle of effect of the measured template, applies to cone types */
  angle: AngleField;
  /** The width of the measured template, applies to ray types */
  width: NumberField;
  /** A color string used to tint the border of the template shape */
  borderColor: ColorField;
  /** A color string used to tint the fill of the template shape */
  fillColor: ColorField;
  /** A repeatable tiling texture used to add a texture fill to the template shape */
  texture: FilePathField<ImageFilePath | VideoFilePath>;
  /** Is the template currently hidden? */
  hidden: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type MeasuredTemplateSource = SourceFromSchema<MeasuredTemplateSchema>;

/**
 * The Document definition for a Note.
 * Defines the DataSchema and common behaviors for a Note which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Note
 * @param context Construction context options
 */
declare class BaseNote<TParent extends BaseScene | null> extends Document$1<TParent, NoteSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): NoteMetadata;

  static override defineSchema(): NoteSchema;

  /** The default icon used for newly created Note documents. */
  static DEFAULT_ICON: ImageFilePath;

  /* -------------------------------------------- */
  /*  Model Methods                               */
  /* -------------------------------------------- */

  testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseNote<TParent extends BaseScene | null>
  extends Document$1<TParent, NoteSchema>,
    ModelPropsFromSchema<NoteSchema> {
  get documentName(): NoteMetadata['name'];
}

interface NoteMetadata extends DocumentMetadata {
  name: 'Note';
  collection: 'notes';
  label: 'DOCUMENT.Note';
  labelPlural: 'DOCUMENT.Notes';
  permissions: {
    create: 'NOTE_CREATE';
    update: MetadataPermission;
    delete: MetadataPermission;
  };
}

type NoteSchema = {
  /** The _id which uniquely identifies this BaseNote embedded document */
  _id: DocumentIdField;
  /** The _id of a JournalEntry document which this Note represents */
  entryId: ForeignDocumentField<string>;
  /** The _id of a specific JournalEntryPage document which this Note represents */
  pageId: ForeignDocumentField<string>;
  /** The x-coordinate position of the center of the note icon */
  x: NumberField<number, number, true, false, true>;
  /** The y-coordinate position of the center of the note icon */
  y: NumberField<number, number, true, false, true>;
  /** An image icon used to represent this note */
  texture: TextureData;
  /** The pixel size of the map note icon */
  iconSize: NumberField<number, number, true, false, true>;
  /** Optional text which overrides the title of the linked Journal Entry */
  text: StringField<string, string, false, false, true>;
  /** The font family used to display the text label on this note, defaults to CONFIG.defaultFontFamily */
  fontFamily: StringField<string, string, true, false, true>;
  /** The font size used to display the text label on this note */
  fontSize: NumberField<number, number, true, true, true>;
  /** A value in CONST.TEXT_ANCHOR_POINTS which defines where the text label anchors to the note icon. */
  textAnchor: NumberField<TextAnchorPoint, TextAnchorPoint, true, false, true>;
  /** The string that defines the color with which the note text is rendered */
  textColor: ColorField;
  /** Whether this map pin is globally visible or requires LoS to see. */
  global: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type NoteSource = SourceFromSchema<NoteSchema>;

/** The PlaylistSound document model. */
declare class BasePlaylistSound<TParent extends BasePlaylist | null> extends Document$1<TParent, PlaylistSoundSchema> {
  static override get metadata(): PlaylistSoundMetadata;

  static override defineSchema(): PlaylistSoundSchema;

  testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BasePlaylistSound<TParent extends BasePlaylist | null>
  extends Document$1<TParent, PlaylistSoundSchema>,
    ModelPropsFromSchema<PlaylistSoundSchema> {
  getDocumentName: PlaylistSoundMetadata['name'];
}

type PlaylistSoundSource = SourceFromSchema<PlaylistSoundSchema>;

interface PlaylistSoundMetadata extends DocumentMetadata {
  name: 'PlaylistSound';
  collection: 'sounds';
  indexed: true;
  label: 'DOCUMENT.PlaylistSound';
  labelPlural: 'DOCUMENT.PlaylistSounds';
}

type PlaylistSoundSchema = {
  /** The _id which uniquely identifies this PlaylistSound document */
  _id: DocumentIdField;
  /** The name of this sound */
  name: StringField<string, string, true, false, false>;
  /** The description of this sound */
  description: StringField;
  /** The audio file path that is played by this sound */
  path: FilePathField<AudioFilePath>;
  /** Is this sound currently playing? */
  playing: BooleanField;
  /** The time in seconds at which playback was paused */
  pausedTime: NumberField;
  /** Does this sound loop? */
  repeat: BooleanField;
  /** The audio volume of the sound, from 0 to 1 */
  volume: AlphaField;
  /** A duration in milliseconds to fade volume transition */
  fade: NumberField;
  /** The sort order of the PlaylistSound relative to others in the same collection */
  sort: IntegerSortField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

/** The Playlist document model. */
declare class BasePlaylist extends Document$1<null, PlaylistSchema> {
  static override get metadata(): PlaylistMetadata;

  static override defineSchema(): PlaylistSchema;
}

interface BasePlaylist extends Document$1<null, PlaylistSchema>, ModelPropsFromSchema<PlaylistSchema> {
  get documentName(): PlaylistMetadata['name'];

  readonly sounds: EmbeddedCollection<BasePlaylistSound<this>>;
}

interface PlaylistMetadata extends DocumentMetadata {
  name: 'Playlist';
  collection: 'playlists';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'description', 'sort', 'folder'];
  embedded: { PlaylistSound: 'sounds' };
  label: 'DOCUMENT.Playlist';
  labelPlural: 'DOCUMENT.Playlists';
}

type PlaylistSchema = {
  _id: DocumentIdField;
  name: StringField<string, string, true, false, false>;
  description: StringField;
  sounds: EmbeddedCollectionField<BasePlaylistSound<BasePlaylist>>;
  mode: NumberField<PlaylistMode, PlaylistMode, true>;
  playing: BooleanField;
  fade: NumberField;
  folder: ForeignDocumentField<BaseFolder>;
  sorting: StringField<PlaylistSortMode, PlaylistSortMode, true, false, true>;
  seed: NumberField;
  sort: IntegerSortField;
  ownership: DocumentOwnershipField;
  flags: ObjectField<DocumentFlags>;
  _stats: DocumentStatsField;
};

/**
 * The Document definition for a RollTable.
 * Defines the DataSchema and common behaviors for a RollTable which are shared between both client and server.
 */
declare class BaseRollTable extends Document$1<null, RollTableSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): RollTableMetadata;

  static override defineSchema(): RollTableSchema;

  /** The default icon used for newly created Macro documents */
  static DEFAULT_ICON: ImageFilePath;
}

interface BaseRollTable extends Document$1<null, RollTableSchema>, ModelPropsFromSchema<RollTableSchema> {
  /** A reference to the Collection of TableResult instances in this document, indexed by _id. */
  readonly results: EmbeddedCollection<BaseTableResult<this>>;

  get documentName(): (typeof BaseRollTable)['metadata']['name'];
}

interface RollTableMetadata extends DocumentMetadata {
  name: 'RollTable';
  collection: 'tables';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'description', 'img', 'sort', 'folder'];
  embedded: { TableResult: 'results' };
  label: 'DOCUMENT.RollTable';
  labelPlural: 'DOCUMENT.RollTables';
}

type RollTableSchema = {
  /** The _id which uniquely identifies this RollTable document */
  _id: DocumentIdField;
  /** The name of this RollTable */
  name: StringField<string, string, true, false, false>;
  /** An image file path which provides the thumbnail artwork for this RollTable */
  img: FilePathField<ImageFilePath>;
  /** The HTML text description for this RollTable document */
  description: HTMLField;
  /** A Collection of TableResult embedded documents which belong to this RollTable */
  // biome-ignore lint/suspicious/noExplicitAny:
  results: EmbeddedCollectionField<BaseTableResult<BaseRollTable>>;
  /** The Roll formula which determines the results chosen from the table */
  formula: StringField<string>;
  /** Are results from this table drawn with replacement? */
  replacement: BooleanField;
  /** Is the Roll result used to draw from this RollTable displayed in chat? */
  displayRoll: BooleanField;
  /** The _id of a Folder which contains this RollTable */
  folder: ForeignDocumentField<BaseFolder>;
  /** The numeric sort value which orders this RollTable relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this RollTable */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type RollTableSource = SourceFromSchema<RollTableSchema>;

/**
 * The Scene document model.
 * @param data                 Initial data from which to construct the document.
 * @property data The constructed data object for the document.
 */
declare class BaseScene extends Document$1<null, SceneSchema> {
  static override get metadata(): SceneMetadata;

  static override defineSchema(): SceneSchema;
}

interface BaseScene extends Document$1<null, SceneSchema>, ModelPropsFromSchema<SceneSchema> {
  get documentName(): SceneMetadata['name'];

  readonly drawings: EmbeddedCollection<BaseDrawing<this>>;
  readonly lights: EmbeddedCollection<BaseAmbientLight<this>>;
  readonly notes: EmbeddedCollection<BaseNote<this>>;
  readonly sounds: EmbeddedCollection<BaseAmbientSound<this>>;
  readonly templates: EmbeddedCollection<BaseMeasuredTemplate<this>>;
  readonly tokens: EmbeddedCollection<BaseToken<this>>;
  readonly tiles: EmbeddedCollection<BaseTile<this>>;
  readonly walls: EmbeddedCollection<BaseWall<this>>;
}

interface SceneMetadata extends DocumentMetadata {
  name: 'Scene';
  collection: 'scenes';
  indexed: true;
  compendiumIndexFields: ['_id', 'name', 'thumb', 'sort', 'folder'];
  embedded: {
    AmbientLight: 'lights';
    AmbientSound: 'sounds';
    Drawing: 'drawings';
    MeasuredTemplate: 'templates';
    Note: 'notes';
    Tile: 'tiles';
    Token: 'tokens';
    Wall: 'walls';
  };
  label: 'DOCUMENT.Scene';
  labelPlural: 'DOCUMENT.Scenes';
  preserveOnImport: string[];
}

type SceneSchema = {
  /** The _id which uniquely identifies this Scene document */
  _id: DocumentIdField;
  /** The name of this scene */
  name: StringField<string, string, true, false, false>;

  // Navigation

  /** Is this scene currently active? Only one scene may be active at a given time */
  active: BooleanField;
  /** Is this scene displayed in the top navigation bar? */
  navigation: BooleanField;
  /** The sorting order of this Scene in the navigation bar relative to siblings */
  navOrder: NumberField<number, number, true, false, true>;
  /** A string which overrides Scene name for display in the navigation bar */
  navName: HTMLField;

  // Canvas Dimensions

  /** An image or video file that provides the background texture for the scene. */
  background: TextureData;
  /** An image or video file path providing foreground media for the scene */
  foreground: FilePathField<ImageFilePath | VideoFilePath>;
  /** The elevation of the foreground layer where overhead tiles reside */
  foregroundElevation: NumberField;

  /** A thumbnail image which depicts the scene at lower resolution */
  thumb: FilePathField<ImageFilePath>;
  /** The width of the scene canvas, normally the width of the background media */
  width: NumberField;
  /** The height of the scene canvas, normally the height of the background media */
  height: NumberField;
  /**
   * The proportion of canvas padding applied around the outside of the scene dimensions to provide additional buffer
   * space
   */
  padding: NumberField<number, number, true, false, true>;
  /** The initial view coordinates for the scene */
  initial: SchemaField<{
    x: NumberField<number, number, false, true, false>;
    y: NumberField<number, number, false, true, false>;
    scale: NumberField<number, number, false, true, false>;
  }>;
  /** The color of the canvas displayed behind the scene background */
  backgroundColor: ColorField;

  // Grid Configuration

  /** Grid configuration for the scene */
  grid: SchemaField<GridDataSchema>;

  // Vision and Lighting Configuration

  /** Do Tokens require vision in order to see the Scene environment? */
  tokenVision: BooleanField;
  /** Should fog exploration progress be tracked for this Scene? */
  fogExploration: BooleanField;
  /** The timestamp at which fog of war was last reset for this Scene. */
  fogReset: NumberField<number, number, false, false, true>;
  /** Is a global source of illumination present which provides dim light to all areas of the Scene? */
  globalLight: BooleanField;
  /**
   * A darkness threshold between 0 and 1. When the Scene darkness level exceeds this threshold Global Illumination
   * is automatically disabled
   */
  globalLightThreshold: AlphaField<true, true, true>;
  /**
   * The ambient darkness level in this Scene, where 0 represents midday (maximum illumination) and 1 represents
   * midnight (maximum darkness)
   */
  darkness: AlphaField;

  /** A special overlay image or video texture which is used for fog of war */
  fogOverlay: FilePathField<ImageFilePath | VideoFilePath>;
  /** A color tint applied to explored regions of fog of war */
  fogExploredColor: ColorField;
  /** A color tint applied to unexplored regions of fog of war */
  fogUnexploredColor: ColorField;

  // Embedded Collections

  /** A collection of embedded Drawing objects. */
  drawings: EmbeddedCollectionField<BaseDrawing<BaseScene>>;
  /** A collection of embedded Token objects. */
  tokens: EmbeddedCollectionField<BaseToken<BaseScene>>;
  /** A collection of embedded AmbientLight objects. */
  lights: EmbeddedCollectionField<BaseAmbientLight<BaseScene>>;
  /** A collection of embedded Note objects. */
  notes: EmbeddedCollectionField<BaseNote<BaseScene>>;
  /** A collection of embedded AmbientSound objects. */
  sounds: EmbeddedCollectionField<BaseAmbientSound<BaseScene>>;
  /** A collection of embedded MeasuredTemplate objects. */
  templates: EmbeddedCollectionField<BaseMeasuredTemplate<BaseScene>>;
  /** A collection of embedded Tile objects. */
  tiles: EmbeddedCollectionField<BaseTile<BaseScene>>;
  /** A collection of embedded Wall objects. */
  walls: EmbeddedCollectionField<BaseWall<BaseScene>>;

  // Linked Documents

  /** A linked Playlist document which should begin automatically playing when this Scene becomes active. */
  playlist: ForeignDocumentField<BasePlaylist>;
  /**
   * A linked PlaylistSound document from the selected playlist that will begin automatically playing when this
   * Scene becomes active
   */
  playlistSound: ForeignDocumentField<string>;
  /** A JournalEntry document which provides narrative details about this Scene */
  journal: ForeignDocumentField<BaseJournalEntry>;
  journalEntryPage: ForeignDocumentField<string>;
  /** A named weather effect which should be rendered in this Scene. */
  weather: StringField;

  // Permissions

  /** The _id of a Folder which contains this Actor */
  folder: ForeignDocumentField<BaseFolder>;
  /** The numeric sort value which orders this Actor relative to its siblings */
  sort: IntegerSortField;
  /** An object which configures ownership of this Scene */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
  /** An object of creation and access information */
  _stats: DocumentStatsField;
};

type GridDataSchema = {
  /** The type of grid, a number from CONST.GRID_TYPES. */
  type: NumberField<GridType, GridType, true, false, false>;
  /** The grid size which represents the width (or height) of a single grid space. */
  size: NumberField<number, number, true, false, true>;
  /** A string representing the color used to render the grid lines. */
  color: ColorField<true, false, true>;
  /** A number between 0 and 1 for the opacity of the grid lines. */
  alpha: AlphaField;
  /** The number of distance units which are represented by a single grid space. */
  distance: NumberField<number, number, true, false, true>;
  /** A label for the units of measure which are used for grid distance. */
  units: StringField<string, string, true, false, true>;
};

type SceneSource = SourceFromSchema<SceneSchema>;

declare global {
  export interface SceneEmbeddedModificationContext<TParent extends BaseScene>
    extends DocumentModificationContext<TParent> {
    /** Is the operation undoing a previous operation, only used by embedded Documents within a Scene */
    isUndo?: boolean;
  }

  export interface GetDimensionsParams {
    gridDistance: number;
    height: number;
    padding: number;
    shiftX: number;
    shiftY: number;
    size: number;
    width: number;
  }
}

/**
 * The Document definition for a Setting.
 * Defines the DataSchema and common behaviors for a Setting which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Setting
 * @param context Construction context options
 */
declare class BaseSetting extends Document$1<null, SettingSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): SettingMetadata;

  static override defineSchema(): SettingSchema;
}

interface BaseSetting extends Document$1<null, SettingSchema>, ModelPropsFromSchema<SettingSchema> {
  get documentName(): SettingMetadata['name'];
}

interface SettingMetadata extends DocumentMetadata {
  name: 'Setting';
  collection: 'settings';
  label: 'DOCUMENT.Setting';
  labelPlural: 'DOCUMENT.Settings';
  permissions: {
    create: 'SETTINGS_MODIFY';
    update: 'SETTINGS_MODIFY';
    delete: 'SETTINGS_MODIFY';
  };
}

type SettingSchema = {
  _id: DocumentIdField;
  key: StringField<string, string, true, false, false>;
  value: JSONField<NonNullable<JSONValue>, true, true, false>;
  _stats: DocumentStatsField;
};

/** The TableResult document model. */
declare class BaseTableResult<TParent extends BaseRollTable | null> extends Document$1<TParent, TableResultSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): TableResultMetadata;

  static override defineSchema(): TableResultSchema;

  override testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;
}

interface BaseTableResult<TParent extends BaseRollTable | null> extends Document$1<TParent, TableResultSchema> {
  get documentName(): TableResultMetadata['name'];
}

interface TableResultMetadata extends DocumentMetadata {
  name: 'TableResult';
  collection: 'results';
  label: 'DOCUMENT.TableResult';
  labelPlural: 'DOCUMENT.TableResults';
  coreTypes: TableResultType[];
}

type TableResultSchema = {
  /** The _id which uniquely identifies this TableResult embedded document */
  _id: DocumentIdField;
  /** A result subtype from CONST.TABLE_RESULT_TYPES */
  type: NumberField<TableResultType, TableResultType, true, true, true>;
  /** The text which describes the table result */
  text: HTMLField;
  /** An image file url that represents the table result */
  img: FilePathField<ImageFilePath>;
  /** A named collection from which this result is drawn */
  documentCollection: StringField<string>;
  /** The _id of a Document within the collection this result references */
  documentId: ForeignDocumentField<string>;
  /** The probabilistic weight of this result relative to other results */
  weight: NumberField<number, number, true, false, true>;
  /**
   * A length 2 array of ascending integers which defines the range of dice roll totals which produce this drawn
   * result
   */
  range: ArrayField<NumberField, [number, number], [number, number]>;
  /** Has this result already been drawn (without replacement) */
  drawn: BooleanField;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type TableResultSource = SourceFromSchema<TableResultSchema>;

/**
 * The Document definition for a Tile.
 * Defines the DataSchema and common behaviors for a Tile which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Tile
 * @param context Construction context options
 */
declare class BaseTile<TParent extends BaseScene | null> extends Document$1<TParent, TileSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): TileMetadata;

  static override defineSchema(): TileSchema;
}

interface BaseTile<TParent extends BaseScene | null>
  extends Document$1<TParent, TileSchema>,
    ModelPropsFromSchema<TileSchema> {
  get documentName(): TileMetadata['name'];
}

interface TileMetadata extends DocumentMetadata {
  name: 'Tile';
  collection: 'tiles';
  label: 'DOCUMENT.Tile';
  labelPlural: 'DOCUMENT.Tiles';
}

type TileSchema = {
  /** The _id which uniquely identifies this Tile embedded document */
  _id: DocumentIdField;
  /** An image or video texture which this tile displays. */
  texture: TextureData;
  /** The pixel width of the tile */
  width: NumberField<number, number, true, false, true>;
  /** The pixel height of the tile */
  height: NumberField<number, number, true, false, true>;
  /** The x-coordinate position of the top-left corner of the tile */
  x: NumberField<number, number, true, false, true>;
  /** The y-coordinate position of the top-left corner of the tile */
  y: NumberField<number, number, true, false, true>;
  /** The z-index ordering of this tile relative to its siblings */
  z: NumberField<number, number, true, false, true>;
  /** The angle of rotation for the tile between 0 and 360 */
  rotation: AngleField;
  /** The tile opacity */
  alpha: AlphaField;
  /** Is the tile currently hidden? */
  hidden: BooleanField;
  /** Is the tile currently locked? */
  locked: BooleanField;
  /** Is the tile an overhead tile? */
  overhead: BooleanField;
  roof: BooleanField;
  /** The tile's occlusion settings */
  occlusion: SchemaField<TileOcclusionSchema>;
  /** The tile's video settings */
  video: SchemaField<TileVideoSchema>;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type TileOcclusionSchema = {
  /** The occlusion mode from CONST.TILE_OCCLUSION_MODES */
  mode: NumberField<TileOcclusionMode, TileOcclusionMode, false, true, true>;
  /** The occlusion alpha between 0 and 1 */
  alpha: AlphaField;
  /** An optional radius of occlusion used for RADIAL mode */
  radius: NumberField;
};

type TileVideoSchema = {
  /** Automatically loop the video? */
  loop: BooleanField;
  /** Should the video play automatically? */
  autoplay: BooleanField;
  /** The volume level of any audio that the video file contains */
  volume: AlphaField;
};

type TileSource = SourceFromSchema<TileSchema>;

/**
 * The Token document model.
 * @param data Initial data from which to construct the document.
 * @property data The constructed data object for the document.
 */
declare class BaseToken<TParent extends BaseScene | null = BaseScene | null> extends Document$1<TParent, TokenSchema> {
  static override get metadata(): TokenMetadata;

  static override defineSchema(): TokenSchema;

  /** The default icon used for newly created Token documents */
  static DEFAULT_ICON: ImageFilePath | VideoFilePath;
}

interface BaseToken<TParent extends BaseScene | null = BaseScene | null>
  extends Document$1<TParent, TokenSchema>,
    ModelPropsFromSchema<TokenSchema> {
  delta: BaseActorDelta<this> | null;
  light: LightData<this>;
}

interface TokenMetadata extends DocumentMetadata {
  name: 'Token';
  collection: 'tokens';
  label: 'DOCUMENT.Token';
  labelPlural: 'DOCUMENT.Tokens';
  isEmbedded: true;
  embedded: {
    ActorDelta: 'delta';
  };
}

type TokenSchema = {
  /** The Token _id which uniquely identifies it within its parent Scene */
  _id: DocumentIdField;
  /** The name used to describe the Token */
  name: StringField<string, string, true>;
  /** The display mode of the Token nameplate, from CONST.TOKEN_DISPLAY_MODES */
  displayName: NumberField<TokenDisplayMode, TokenDisplayMode, true, false, true>;
  /** The _id of an Actor document which this Token represents */
  actorId: ForeignDocumentField<string>;
  /** Does this Token uniquely represent a singular Actor, or is it one of many? */
  actorLink: BooleanField;
  /**
   * The ActorDelta embedded document which stores the differences between this token and the base actor it
   * represents.
   */
  delta: ActorDeltaField<BaseActorDelta<BaseToken>>;
  appendNumber: BooleanField;
  prependAdjective: BooleanField;
  /** The token's texture on the canvas. */
  texture: TextureData;
  /** The width of the Token in grid units */
  width: NumberField<number, number, true, false>;
  /** The height of the Token in grid units */
  height: NumberField<number, number, true, false>;
  /** The x-coordinate of the top-left corner of the Token */
  x: NumberField<number, number, true, false>;
  /** The y-coordinate of the top-left corner of the Token */
  y: NumberField<number, number, true, false>;
  /** The vertical elevation of the Token, in distance units */
  elevation: NumberField<number, number, true, false>;
  /** Prevent the Token image from visually rotating? */
  lockRotation: BooleanField;
  /** The rotation of the Token in degrees, from 0 to 360. A value of 0 represents a southward-facing Token. */
  rotation: AngleField;
  /** An array of effect icon paths which are displayed on the Token */
  effects: ArrayField<FilePathField<ImageFilePath | VideoFilePath, ImageFilePath | VideoFilePath, true, false>>;
  /** A single icon path which is displayed as an overlay on the Token */
  overlayEffect: StringField<ImageFilePath | VideoFilePath | ''>;
  /** The opacity of the token image */
  alpha: AlphaField;
  /** Is the Token currently hidden from player view? */
  hidden: BooleanField;
  /** A displayed Token disposition from CONST.TOKEN_DISPOSITIONS */
  disposition: NumberField<TokenDisposition, TokenDisposition, true>;
  /** The display mode of Token resource bars, from CONST.TOKEN_DISPLAY_MODES */
  displayBars: NumberField<TokenDisplayMode, TokenDisplayMode, true>;
  /** The configuration of the Token's primary resource bar */
  bar1: SchemaField<{
    /** The attribute path within the Token's Actor data which should be displayed */
    attribute: StringField<string, string, true, true, true>;
  }>;
  /** The configuration of the Token's secondary resource bar */
  bar2: SchemaField<{
    /** The attribute path within the Token's Actor data which should be displayed */
    attribute: StringField<string, string, true, true, true>;
  }>;
  /** Configuration of the light source that this Token emits */
  light: EmbeddedDataField<LightData<BaseToken>>;
  /** Configuration of sight and vision properties for the Token */
  sight: SchemaField<{
    /** Should vision computation and rendering be active for this Token? */
    enabled: BooleanField;
    /** How far in distance units the Token can see without the aid of a light source */
    range: NumberField<number, number, true, false>;
    /** An angle at which the Token can see relative to their direction of facing */
    angle: AngleField;
    /** The vision mode which is used to render the appearance of the visible area */
    visionMode: StringField<string, string, true, false, true>;
    /** A special color which applies a hue to the visible area */
    color: ColorField;
    /** A degree of attenuation which gradually fades the edges of the visible area */
    attenuation: AlphaField;
    /** An advanced customization for the perceived brightness of the visible area */
    brightness: NumberField<number, number, true, false>;
    /** An advanced customization of color saturation within the visible area */
    saturation: NumberField<number, number, true, false>;
    /** An advanced customization for contrast within the visible area */
    contrast: NumberField<number, number, true, false>;
  }>;
  /** An array of detection modes which are available to this Token */
  detectionModes: ArrayField<
    SchemaField<{
      /** The id of the detection mode, a key from CONFIG.Canvas.detectionModes */
      id: StringField<string>;
      /** Whether or not this detection mode is presently enabled */
      enabled: BooleanField;
      /** The maximum range in distance units at which this mode can detect targets */
      range: NumberField<number, number, true, false>;
    }>
  >;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type TokenSource = SourceFromSchema<TokenSchema>;

declare class ActorDeltaField<
  TDocument extends BaseActorDelta<BaseToken> = BaseActorDelta<BaseToken>,
> extends EmbeddedDocumentField<TDocument> {
  override initialize(
    value: MaybeSchemaProp<TDocument['_source'], true, true, true>,
    model?: ConstructorOf<TDocument>,
    options?: object,
  ): MaybeSchemaProp<TDocument, true, true, true>;
}

/**
 * The base User document, which is extended by both the server and client.
 * This base User provides shared functionality which is consistent for both sides of the application.
 * Each client who connects to a Foundry Virtual Tabletop session assumes the identity of one (and only one) User.
 *
 * @param data Initial data from which to construct the document.
 * @property   data The constructed data object for the document.
 */
declare class BaseUser<TCharacter extends BaseActor<null> = BaseActor<null>> extends Document$1<
  null,
  UserSchema<TCharacter>
> {
  static override get metadata(): UserMetadata;

  static override defineSchema(): UserSchema<BaseActor<null>>;

  /* ---------------------------------------- */
  /*  Permissions                             */
  /* ---------------------------------------- */

  /** Test whether the User has a GAMEMASTER or ASSISTANT role in this World? */
  get isGM(): boolean;

  /**
   * Test whether the User is able to perform a certain permission action.
   * The provided permission string may pertain to an explicit permission setting or a named user role.
   * Alternatively, Gamemaster users are assumed to be allowed to take all actions.
   *
   * @param action The action to test
   * @return Does the user have the ability to perform this action?
   */
  can(action: UserAction): boolean;

  getUserLevel(user: this): DocumentOwnershipLevel;

  /**
   * Test whether the User has at least a specific permission
   * @param permission The permission name from USER_PERMISSIONS to test
   * @return Does the user have at least this permission
   */
  hasPermission(permission: UserPermission): boolean;

  /**
   * Test whether the User has at least the permission level of a certain role
   * @param role The role name from USER_ROLES to test
   * @param [exact] Require the role match to be exact
   * @return Does the user have at this role level (or greater)?
   */
  hasRole(role: UserRole | UserRoleName, { exact }?: { exact: boolean }): boolean;
}

interface BaseUser<TCharacter extends BaseActor<null> = BaseActor<null>>
  extends Document$1<null, UserSchema<TCharacter>>,
    ModelPropsFromSchema<UserSchema<TCharacter>> {
  get documentName(): UserMetadata['name'];
}

interface UserMetadata extends DocumentMetadata {
  name: 'User';
  collection: 'users';
  label: 'DOCUMENT.User';
  labelPlural: 'DOCUMENT.Users';
}

type UserSchema<TActor extends BaseActor<null>> = {
  _id: DocumentIdField;
  name: StringField<string, string, true, false, false>;
  role: NumberField<UserRole, UserRole, true, false, true>;
  password: StringField<string, string, true, false, true>;
  passwordSalt: StringField<string>;
  avatar: FilePathField<ImageFilePath>;
  character: ForeignDocumentField<TActor>;
  color: ColorField<true, false, true>;
  pronouns: StringField<string, string, true, false, true>;
  hotbar: ObjectField<Record<number, string>>;
  permissions: ObjectField<Record<string, boolean>>;
  flags: ObjectField<DocumentFlags>;
  _stats: DocumentStatsField;
};

type UserSource = SourceFromSchema<UserSchema<BaseActor<null>>>;

/**
 * The Document definition for a Wall.
 * Defines the DataSchema and common behaviors for a Wall which are shared between both client and server.
 * @memberof documents
 *
 * @param data    Initial data from which to construct the Wall
 * @param context Construction context options
 */
declare class BaseWall<TParent extends BaseScene | null> extends Document$1<TParent, WallSchema> {
  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  static override get metadata(): WallMetadata;

  static override defineSchema(): WallSchema;
}

interface BaseWall<TParent extends BaseScene | null>
  extends Document$1<TParent, WallSchema>,
    ModelPropsFromSchema<WallSchema> {
  get documentName(): WallMetadata['name'];
}

interface WallMetadata extends DocumentMetadata {
  name: 'Wall';
  collection: 'walls';
  label: 'DOCUMENT.Wall';
  labelPlural: 'DOCUMENT.Walls';
}

type WallSchema = {
  /** The _id which uniquely identifies the embedded Wall document */
  _id: DocumentIdField;
  /** The wall coordinates, a length-4 array of finite numbers [x0,y0,x1,y1] */
  c: ArrayField<
    NumberField<number, number, true, false, true>,
    [number, number, number, number],
    [number, number, number, number]
  >;
  /** The illumination restriction type of this wall */
  light: NumberField<WallSenseType, WallSenseType, true, true, true>;
  /** The movement restriction type of this wall */
  move: NumberField<WallMovementType, WallMovementType, true, true, true>;
  /** The visual restriction type of this wall */
  sight: NumberField<WallSenseType, WallSenseType, true, true, true>;
  /** The auditory restriction type of this wall */
  sound: NumberField<WallSenseType, WallSenseType, true, true, true>;
  /** The direction of effect imposed by this wall */
  dir: NumberField<WallDirection, WallDirection, true, true, true>;
  /** The type of door which this wall contains, if any */
  door: NumberField<WallDoorType, WallDoorType, true, true, true>;
  /** The state of the door this wall contains, if any */
  ds: NumberField<WallDoorState, WallDoorState, true, true, true>;
  doorSound: StringField<string, string, false, false, false>;
  /** Configuration of threshold data for this wall */
  threshold: SchemaField<WallThresholdSchema>;
  /** An object of optional key/value flags */
  flags: ObjectField<DocumentFlags>;
};

type WallThresholdSchema = {
  /** Minimum distance from a light source for which this wall blocks light */
  light: NumberField<number, number, true, true, true>;
  /** Minimum distance from a vision source for which this wall blocks vision */
  sight: NumberField<number, number, true, true, true>;
  /** Minimum distance from a sound source for which this wall blocks sound */
  sound: NumberField<number, number, true, true, true>;
  /** Whether to attenuate the source radius when passing through the wall */
  attenuation: BooleanField;
};

type WallSource = SourceFromSchema<WallSchema>;

type Documents_ActiveEffectSource = ActiveEffectSource;
type Documents_ActorFlags = ActorFlags;
type Documents_ActorSource<
  TType extends string = string,
  TSystemSource extends object = object,
  TItemSource extends foundry.documents.ItemSource = foundry.documents.ItemSource,
> = ActorSource<TType, TSystemSource, TItemSource>;
type Documents_AdventureSource = AdventureSource;
type Documents_AmbientSoundSource = AmbientSoundSource;
type Documents_BaseActiveEffect<TParent extends BaseActor | BaseItem<BaseActor | null> | null> =
  BaseActiveEffect<TParent>;
type Documents_BaseActor<TParent extends BaseToken | null = BaseToken | null> = BaseActor<TParent>;
type Documents_BaseActorDelta<TParent extends BaseToken | null> = BaseActorDelta<TParent>;
type Documents_BaseAdventure = BaseAdventure;
type Documents_BaseAmbientLight<TParent extends BaseScene | null> = BaseAmbientLight<TParent>;
type Documents_BaseAmbientSound<TParent extends BaseScene | null> = BaseAmbientSound<TParent>;
type Documents_BaseCard<TParent extends BaseCards | null> = BaseCard<TParent>;
type Documents_BaseCards = BaseCards;
type Documents_BaseChatMessage = BaseChatMessage;
type Documents_BaseCombat = BaseCombat;
type Documents_BaseCombatant<TParent extends BaseCombat | null> = BaseCombatant<TParent>;
type Documents_BaseDrawing<TParent extends BaseScene | null> = BaseDrawing<TParent>;
type Documents_BaseFogExploration = BaseFogExploration;
type Documents_BaseFolder = BaseFolder;
type Documents_BaseItem<TParent extends BaseActor | null> = BaseItem<TParent>;
type Documents_BaseJournalEntry = BaseJournalEntry;
type Documents_BaseJournalEntryPage<TParent extends BaseJournalEntry | null> = BaseJournalEntryPage<TParent>;
type Documents_BaseMacro = BaseMacro;
type Documents_BaseMeasuredTemplate<TParent extends BaseScene | null> = BaseMeasuredTemplate<TParent>;
type Documents_BaseNote<TParent extends BaseScene | null> = BaseNote<TParent>;
type Documents_BasePlaylist = BasePlaylist;
type Documents_BasePlaylistSound<TParent extends BasePlaylist | null> = BasePlaylistSound<TParent>;
type Documents_BaseRollTable = BaseRollTable;
type Documents_BaseScene = BaseScene;
type Documents_BaseSetting = BaseSetting;
type Documents_BaseTableResult<TParent extends BaseRollTable | null> = BaseTableResult<TParent>;
type Documents_BaseTile<TParent extends BaseScene | null> = BaseTile<TParent>;
type Documents_BaseToken<TParent extends BaseScene | null = BaseScene | null> = BaseToken<TParent>;
type Documents_BaseUser<TCharacter extends BaseActor<null> = BaseActor<null>> = BaseUser<TCharacter>;
type Documents_BaseWall<TParent extends BaseScene | null> = BaseWall<TParent>;
type Documents_CardFaceData = CardFaceData;
type Documents_ChatMessageFlags = ChatMessageFlags;
type Documents_ChatMessageSource = ChatMessageSource;
type Documents_ChatSpeakerData = ChatSpeakerData;
type Documents_CombatSource = CombatSource;
type Documents_CombatantSource = CombatantSource;
type Documents_DrawingSource = DrawingSource;
type Documents_FogExplorationSource = FogExplorationSource;
type Documents_FolderSource = FolderSource;
type Documents_ItemFlags = ItemFlags;
type Documents_ItemSchema<TType extends string = string, TSystemSource extends object = object> = ItemSchema<
  TType,
  TSystemSource
>;
type Documents_ItemSource<TType extends string = string, TSystemSource extends object = object> = ItemSource<
  TType,
  TSystemSource
>;
type Documents_JournalEntrySource = JournalEntrySource;
type Documents_MacroSource = MacroSource;
type Documents_MeasuredTemplateSource = MeasuredTemplateSource;
type Documents_NoteSource = NoteSource;
type Documents_PlaylistSoundSource = PlaylistSoundSource;
type Documents_RollTableSource = RollTableSource;
type Documents_SceneSource = SceneSource;
type Documents_TableResultSource = TableResultSource;
type Documents_TileSource = TileSource;
type Documents_TokenSource = TokenSource;
type Documents_UserSource = UserSource;
type Documents_WallSource = WallSource;
declare namespace Documents {
  export type {
    Documents_ActiveEffectSource as ActiveEffectSource,
    Documents_ActorFlags as ActorFlags,
    Documents_ActorSource as ActorSource,
    Documents_AdventureSource as AdventureSource,
    Documents_AmbientSoundSource as AmbientSoundSource,
    Documents_BaseActiveEffect as BaseActiveEffect,
    Documents_BaseActor as BaseActor,
    Documents_BaseActorDelta as BaseActorDelta,
    Documents_BaseAdventure as BaseAdventure,
    Documents_BaseAmbientLight as BaseAmbientLight,
    Documents_BaseAmbientSound as BaseAmbientSound,
    Documents_BaseCard as BaseCard,
    Documents_BaseCards as BaseCards,
    Documents_BaseChatMessage as BaseChatMessage,
    Documents_BaseCombat as BaseCombat,
    Documents_BaseCombatant as BaseCombatant,
    Documents_BaseDrawing as BaseDrawing,
    Documents_BaseFogExploration as BaseFogExploration,
    Documents_BaseFolder as BaseFolder,
    Documents_BaseItem as BaseItem,
    Documents_BaseJournalEntry as BaseJournalEntry,
    Documents_BaseJournalEntryPage as BaseJournalEntryPage,
    Documents_BaseMacro as BaseMacro,
    Documents_BaseMeasuredTemplate as BaseMeasuredTemplate,
    Documents_BaseNote as BaseNote,
    Documents_BasePlaylist as BasePlaylist,
    Documents_BasePlaylistSound as BasePlaylistSound,
    Documents_BaseRollTable as BaseRollTable,
    Documents_BaseScene as BaseScene,
    Documents_BaseSetting as BaseSetting,
    Documents_BaseTableResult as BaseTableResult,
    Documents_BaseTile as BaseTile,
    Documents_BaseToken as BaseToken,
    Documents_BaseUser as BaseUser,
    Documents_BaseWall as BaseWall,
    Documents_CardFaceData as CardFaceData,
    Documents_ChatMessageFlags as ChatMessageFlags,
    Documents_ChatMessageSource as ChatMessageSource,
    Documents_ChatSpeakerData as ChatSpeakerData,
    Documents_CombatSource as CombatSource,
    Documents_CombatantSource as CombatantSource,
    Documents_DrawingSource as DrawingSource,
    Documents_FogExplorationSource as FogExplorationSource,
    Documents_FolderSource as FolderSource,
    Documents_ItemFlags as ItemFlags,
    Documents_ItemSchema as ItemSchema,
    Documents_ItemSource as ItemSource,
    Documents_JournalEntrySource as JournalEntrySource,
    Documents_MacroSource as MacroSource,
    Documents_MeasuredTemplateSource as MeasuredTemplateSource,
    Documents_NoteSource as NoteSource,
    Documents_PlaylistSoundSource as PlaylistSoundSource,
    Documents_RollTableSource as RollTableSource,
    Documents_SceneSource as SceneSource,
    Documents_TableResultSource as TableResultSource,
    Documents_TileSource as TileSource,
    Documents_TokenSource as TokenSource,
    Documents_UserSource as UserSource,
    Documents_WallSource as WallSource,
  };
}

/**
 * An embedded data object which defines the properties of a light source animation
 * @property type      The animation type which is applied
 * @property speed     The speed of the animation, a number between 1 and 10
 * @property intensity The intensity of the animation, a number between 1 and 10
 */
interface AnimationData {
  type: string;
  speed: number;
  intensity: number;
}

/**
 * An embedded data object which defines the darkness range during which some attribute is active
 * @property [min=0] The minimum darkness level for which activation occurs
 * @property [max=1] The maximum darkness level for which activation occurs
 */
interface DarknessActivation {
  min: number;
  max: number;
}

/**
 * A reusable document structure for the internal data used to render the appearance of a light source.
 * This is re-used by both the AmbientLightData and TokenData classes.
 */
declare class LightData<TParent extends DataModel | null> extends DataModel<TParent, LightDataSchema> {
  static override defineSchema(): LightDataSchema;

  static override migrateData<TSource extends Record<string, JSONValue>>(source: TSource): TSource;
}

interface LightData<TParent extends DataModel | null>
  extends DataModel<TParent, LightDataSchema>,
    ModelPropsFromSchema<LightDataSchema> {}

type LightSource$1 = SourceFromSchema<LightDataSchema>;

type LightDataSchema = {
  /** An opacity for the emitted light, if any */
  alpha: AlphaField;
  /** The angle of emission for this point source */
  angle: AngleField;
  /** The allowed radius of bright vision or illumination */
  bright: NumberField<number, number, true, false, true>;
  /** A tint color for the emitted light, if any */
  color: ColorField;
  /** The coloration technique applied in the shader */
  coloration: NumberField<number, number, true>;
  /** The allowed radius of dim vision or illumination */
  dim: NumberField<number, number, true>;
  /** Fade the difference between bright, dim, and dark gradually? */
  attenuation: NumberField<number, number, true>;
  /** The luminosity applied in the shader */
  luminosity: NumberField<number, number, true, false, true>;
  /** The amount of color saturation this light applies to the background texture */
  saturation: NumberField<number, number, true, false, true>;
  /** The amount of contrast this light applies to the background texture */
  contrast: NumberField<number, number, true, false, true>;
  /** The depth of shadows this light applies to the background texture */
  shadows: NumberField<number, number, true, false, true>;
  /** An animation configuration for the source */
  animation: SchemaField<{
    type: StringField<string, string, true, true, true>;
    speed: NumberField<number, number, true>;
    intensity: NumberField<number, number, true>;
    reverse: BooleanField;
  }>;
  /** A darkness range (min and max) for which the source should be active */
  darkness: SchemaField<{
    min: AlphaField;
    speed: AlphaField;
  }>;
};

/** A data model intended to be used as an inner EmbeddedDataField which defines a geometric shape. */
declare class ShapeData<TParent extends DataModel | null> extends DataModel<TParent, ShapeDataSchema> {
  static override defineSchema(): ShapeDataSchema;

  /** The primitive shape types which are supported */
  static TYPES: {
    RECTANGLE: 'r';
    CIRCLE: 'c';
    ELLIPSE: 'e';
    POLYGON: 'p';
  };
}

interface ShapeData<TParent extends DataModel | null>
  extends DataModel<TParent, ShapeDataSchema>,
    ModelPropsFromSchema<ShapeDataSchema> {}

type ShapeDataSchema = {
  /**
   * The type of shape, a value in ShapeData.TYPES.
   * For rectangles, the x/y coordinates are the top-left corner.
   * For circles, the x/y coordinates are the center of the circle.
   * For polygons, the x/y coordinates are the first point of the polygon.
   */
  type: StringField<ValueOf<typeof ShapeData.TYPES>, ValueOf<typeof ShapeData.TYPES>, true, false, true>;
  /** For rectangles, the pixel width of the shape. */
  width: NumberField;
  /** For rectangles, the pixel height of the shape. */
  height: NumberField;
  /** For circles, the pixel radius of the shape. */
  radius: NumberField;
  /** For polygons, the array of polygon coordinates which comprise the shape. */
  points: ArrayField<NumberField<number, number, true, false>>;
};

/** A {@link fields.SchemaField} subclass used to represent texture data. */
declare class TextureData extends SchemaField<TextureDataSchema> {
  /**
   * @param options    Options which are forwarded to the SchemaField constructor
   * @param srcOptions Additional options for the src field
   */
  constructor(
    options?: DataFieldOptions<SourceFromSchema<TextureDataSchema>, true, false, true>,
    srcOptions?: {
      categories?: ('IMAGE' | 'VIDEO')[];
      initial?: 'IMAGE' | 'VIDEO' | null;
      wildcard?: boolean;
      label?: string;
    },
  );
}

type TextureDataSchema = {
  /** The URL of the texture source. */
  src: FilePathField<ImageFilePath | VideoFilePath, ImageFilePath | VideoFilePath, true, false, true>;
  /** The scale of the texture in the X dimension. */
  scaleX: NumberField<number, number, false, false>;
  /** The scale of the texture in the Y dimension. */
  scaleY: NumberField<number, number, false, false>;
  /** The X offset of the texture with (0,0) in the top left. */
  offsetX: NumberField<number, number, false, false>;
  /** The Y offset of the texture with (0,0) in the top left. */
  offsetY: NumberField<number, number, false, false>;
  /** An angle of rotation by which this texture is rotated around its center. */
  rotation: AngleField;
  /** An optional color string used to tint the texture. */
  tint: ColorField;
};

declare class PrototypeToken<TParent extends BaseActor | null> extends DataModel<TParent, PrototypeTokenSchema> {
  constructor(data: DeepPartial<PrototypeTokenSource>, options?: DataModelConstructionOptions<TParent>);

  static override defineSchema(): PrototypeTokenSchema;

  get actor(): TParent;

  protected override _initialize(): void;

  override toJSON(): this['_source'];
}

interface PrototypeToken<TParent extends BaseActor | null>
  extends DataModel<TParent, PrototypeTokenSchema>,
    ModelPropsFromSchema<PrototypeTokenSchema> {}

type PrototypeTokenSchema = Omit<
  TokenSchema,
  '_id' | 'name' | 'actorId' | 'delta' | 'x' | 'y' | 'elevation' | 'effects' | 'overlayEffect' | 'hidden'
> & {
  name: StringField<string, string, true, false, true>;
  randomImg: BooleanField;
};

type PrototypeTokenSource = SourceFromSchema<PrototypeTokenSchema>;

/**
 * A minimal data model used to represent a tombstone entry inside an {@link EmbeddedCollectionDelta}.
 * @see {EmbeddedCollectionDelta}
 *
 * @property _id        The _id of the base Document that this tombstone represents.
 * @property _tombstone A property that identifies this entry as a tombstone.
 * @property [_stats]   An object of creation and access information.
 */
declare class TombstoneData<
  TParent extends BaseActorDelta<BaseToken<BaseScene | null> | null> | null,
> extends DataModel<TParent, TombstoneDataSchema> {
  static override defineSchema(): TombstoneDataSchema;
}

interface TombstoneData<TParent extends BaseActorDelta<BaseToken<BaseScene | null> | null> | null>
  extends DataModel<TParent, TombstoneDataSchema>,
    SourceFromSchema<TombstoneDataSchema> {
  readonly _source: TombstoneSource;
}

type TombstoneSource<TDocumentId extends string | null = string | null> = Omit<
  SourceFromSchema<TombstoneDataSchema>,
  '_id'
> & {
  _id: TDocumentId;
};

type TombstoneDataSchema = {
  _id: DocumentIdField;
  _tombstone: BooleanField<true, true>;
  _stats: DocumentStatsField;
};

/**
 * An embedded data object which defines the properties of a light source animation
 * @property mode     The occlusion mode from CONST.TILE_OCCLUSION_MODES
 * @property alpha    The occlusion alpha between 0 and 1
 * @property [radius] An optional radius of occlusion used for RADIAL mode
 */
interface TileOcclusion {
  mode: TileOcclusionMode;
  alpha: number;
  radius?: number;
}

/**
 * An inner-object which defines the schema for how Tile video backgrounds are managed
 * @property loop     Automatically loop the video?
 * @property autoplay Should the video play automatically?
 * @property volume   The volume level of any audio that the video file contains
 */
interface VideoData {
  loop: boolean;
  autoplay: boolean;
  volume: boolean;
}

/** A class responsible for recording information about a validation failure. */
declare class DataModelValidationFailure {
  /**
   * @param [invalidValue]   The value that failed validation for this field.
   * @param [fallback]       The value it was replaced by, if any.
   * @param [dropped]        Whether the value was dropped from some parent collection.
   * @param [message]        The validation error message.
   * @param [unresolved]     Whether this failure was unresolved
   */
  constructor({
    invalidValue,
    fallback,
    dropped,
    message,
    unresolved,
  }?: {
    invalidValue?: unknown;
    fallback?: boolean;
    dropped?: boolean;
    message?: string;
    unresolved?: boolean;
  });

  /** The value that failed validation for this field. */
  invalidValue: unknown;

  /** The value it was replaced by, if any. */
  fallback: unknown;

  /** Whether the value was dropped from some parent collection. */
  dropped: boolean;

  /** The validation error message. */
  message?: string;

  /** If this field contains other fields that are validated as part of its validation, their results are recorded here. */
  fields: Record<string, DataModelValidationFailure>;

  /**
   * If this field contains a list of elements that are validated as part of its validation, their results are recorded
   * here.
   */
  elements: ElementValidationFailure[];

  /**
   * Record whether a validation failure is unresolved.
   * This reports as true if validation for this field or any hierarchically contained field is unresolved.
   * A failure is unresolved if the value was invalid and there was no valid fallback value available.
   */
  unresolved: boolean;

  /** Return this validation failure as an Error object. */
  asError(): DataModelValidationError;

  /** Whether this failure contains other sub-failures. */
  isEmpty(): boolean;

  /** Return the base properties of this failure, omitting any nested failures. */
  toObject(): {
    invalidValue: unknown;
    fallback: unknown;
    dropped: boolean;
    message: string;
  };

  /** Represent the DataModelValidationFailure as a string. */
  toString(): string;
}

interface ElementValidationFailure {
  /** Either the element's index or some other identifier for it. */
  id: string | number;
  /** Optionally a user-friendly name for the element. */
  name?: string;
  /** The element's validation failure. */
  failure: DataModelValidationFailure;
}

/** A specialised Error to indicate a model validation failure. */
declare class DataModelValidationError extends Error {
  /**
   * @param failure    The failure that triggered this error or an error message
   * @param [params]   Additional Error constructor parameters
   */
  constructor(failure: DataModelValidationFailure | string, params?: ErrorOptions);

  /**
   * Retrieve the root failure that caused this error, or a specific sub-failure via a path.
   * @param path  The property path to the failure.
   *
   * @example Retrieving a failure.
   * ```js
   * const changes = {
   *   "foo.bar": "validValue",
   *   "foo.baz": "invalidValue"
   * };
   * try {
   *   doc.validate(expandObject(changes));
   * } catch ( err ) {
   *   const failure = err.getFailure("foo.baz");
   *   console.log(failure.invalidValue); // "invalidValue"
   * }
   * ```
   */
  getFailure(path?: string): DataModelValidationFailure;

  /**
   * Retrieve a flattened object of all the properties that failed validation as part of this error.
   *
   * @example Removing invalid changes from an update delta.
   * ```js
   * const changes = {
   *   "foo.bar": "validValue",
   *   "foo.baz": "invalidValue"
   * };
   * try {
   *   doc.validate(expandObject(changes));
   * } catch ( err ) {
   *   const failures = err.getAllFailures();
   *   if ( failures ) {
   *     for ( const prop in failures ) delete changes[prop];
   *     doc.validate(expandObject(changes));
   *   }
   * }
   * ```
   */
  getAllFailures(): Record<string, DataModelValidationFailure>;

  /** Log the validation error as a table. */
  logAsTable(): void;

  /** Generate a nested tree view of the error as an HTML string. */
  asHTML(): string;
}

type validationFailure_d_DataModelValidationError = DataModelValidationError;
declare const validationFailure_d_DataModelValidationError: typeof DataModelValidationError;
type validationFailure_d_DataModelValidationFailure = DataModelValidationFailure;
declare const validationFailure_d_DataModelValidationFailure: typeof DataModelValidationFailure;
declare namespace validationFailure_d {
  export {
    validationFailure_d_DataModelValidationError as DataModelValidationError,
    validationFailure_d_DataModelValidationFailure as DataModelValidationFailure,
  };
}

/* ---------------------------------------- */
/*  Abstract Data Field                     */
/* ---------------------------------------- */

/**
 * @typedef DataFieldOptions
 * @property [required=false]  Is this field required to be populated?
 * @property [nullable=false]  Can this field have null values?
 * @property [initial]         The initial value of a field, or a function which assigns that initial value.
 * @property [validate]        A data validation function which accepts one argument with the current value.
 * @property [choices]         An array of values or an object of values/labels which represent allowed choices for the
 *                             field. A function may be provided which dynamically returns the array of choices.
 * @property [label]           A localizable label displayed on forms which render this field.
 * @property [hint]            Localizable help text displayed on forms which render this field.
 * @property [validationError] A custom validation error string. When displayed will be prepended with the document
 *                             name, field name, and candidate value.
 */
interface DataFieldOptions<
  TSourceProp,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> {
  required?: TRequired;
  nullable?: TNullable;
  initial?: THasInitial extends true
    ?
        | TSourceProp
        | ((data: Record<string, unknown>) => MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>)
        | null
    : THasInitial extends false
      ? undefined
      :
          | TSourceProp
          | ((data: Record<string, unknown>) => MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>)
          | null
          | undefined;
  validate?: (value: unknown) => DataModelValidationFailure | boolean | void;
  choices?:
    | readonly TSourceProp[]
    | Record<string, string>
    | (() => readonly TSourceProp[] | Record<string | number, string>);
  readonly?: boolean;
  label?: string;
  hint?: string;
  validationError?: string;
}

/**
 * @typedef DataFieldValidationOptions
 * @property [partial]              Whether this is a partial schema validation, or a complete one.
 * @property [fallback]             Whether to allow replacing invalid values with valid fallbacks.
 * @property [source]               The full source object being evaluated.
 * @property [dropInvalidEmbedded]  If true, invalid embedded documents will emit a warning and be placed in
 *                                  the invalidDocuments collection rather than causing the parent to be
 *                                  considered invalid.
 */
interface DataFieldValidationOptions {
  partial?: boolean;
  fallback?: boolean;
  source?: object;
  dropInvalidEmbedded?: boolean;
}

/**
 * An abstract class that defines the base pattern for a data field within a data schema.
 *
 * @property name             The name of this data field within the schema that contains it
 * @property [required=false] Is this field required to be populated?
 * @property [nullable=false] Can this field have null values?
 * @property initial          The initial value of a field, or a function which assigns that initial value.
 * @property validate         A data validation function which accepts one argument with the current value.
 * @property [readonly=false] Should the prepared value of the field be read-only, preventing it from being
 *                                        changed unless a change to the _source data is applied.
 * @property {string} label               A localizable label displayed on forms which render this field.
 * @property {string} hint                Localizable help text displayed on forms which render this field.
 * @property {string} validationError     A custom validation error string. When displayed will be prepended with the
 *                                        document name, field name, and candidate value.
 */
declare abstract class DataField<
  TSourceProp extends JSONValue = JSONValue,
  TModelProp = TSourceProp,
  TRequired extends boolean = boolean,
  TNullable extends boolean = boolean,
  THasInitial extends boolean = boolean,
> implements DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>
{
  /** @param options Options which configure the behavior of the field */
  constructor(options?: DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  initial: this['options']['initial'];

  /** The initially provided options which configure the data field */
  options: DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;

  /**
   * The field name of this DataField instance.
   * This is assigned by `SchemaField#initialize`.
   * @internal
   */
  name: string;

  /**
   * A reference to the parent schema to which this DataField belongs.
   * This is assigned by `SchemaField#initialize`.
   * @internal
   */
  parent: DataSchema | undefined;

  /** Whether this field defines part of a Document/Embedded Document hierarchy. */
  static hierarchical: boolean;

  /**
   * Does this field type contain other fields in a recursive structure?
   * Examples of recursive fields are SchemaField, ArrayField, or TypeDataField
   * Examples of non-recursive fields are StringField, NumberField, or ObjectField
   */
  static recursive: boolean;

  /** Default parameters for this field type */
  protected static get _defaults(): DataFieldOptions<unknown, boolean, boolean, boolean>;

  /** A dot-separated string representation of the field path within the parent schema. */
  get fieldPath(): string;

  /**
   * Apply a function to this DataField which propagates through recursively to any contained data schema.
   * @param fn           The function to apply
   * @param value        The current value of this field
   * @param [options={}] Additional options passed to the applied function
   * @returns The results object
   */
  apply(
    fn: string | ((field: this, value?: unknown, options?: Record<string, unknown>) => unknown),
    value?: unknown,
    options?: Record<string, unknown>,
  ): unknown;

  /* -------------------------------------------- */
  /*  Field Cleaning                              */
  /* -------------------------------------------- */

  /**
   * Coerce source data to ensure that it conforms to the correct data type for the field.
   * Data coercion operations should be simple and synchronous as these are applied whenever a DataModel is constructed.
   * For one-off cleaning of user-provided input the sanitize method should be used.
   * @param value     The initial value
   * @param [options] Additional options for how the field is cleaned
   * @param [options.partial] Whether to perform partial cleaning?
   * @param [options.source]  The root data model being cleaned
   * @returns The cast value
   */
  clean(value: unknown, options?: CleanFieldOptions): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  /**
   * Apply any cleaning logic specific to this DataField type.
   * @param value     The appropriately coerced value.
   * @param [options] Additional options for how the field is cleaned.
   * @returns The cleaned value.
   */
  protected _cleanType(value: unknown, options?: CleanFieldOptions): unknown;

  /**
   * Cast a non-default value to ensure it is the correct type for the field
   * @param value The provided non-default value
   * @returns The standardized value
   */
  protected abstract _cast(value?: unknown): unknown;

  /**
   * Attempt to retrieve a valid initial value for the DataField.
   * @param data The source data object for which an initial value is required
   * @returns A valid initial value
   * @throws An error if there is no valid initial value defined
   */
  getInitialValue(data?: object): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  /* -------------------------------------------- */
  /*  Field Validation                            */
  /* -------------------------------------------- */

  /**
   * Validate a candidate input for this field, ensuring it meets the field requirements.
   * A validation failure can be provided as a raised Error (with a string message), by returning false, or by returning
   * a DataModelValidationFailure instance.
   * A validator which returns true denotes that the result is certainly valid and further validations are unnecessary.
   * @param value          The initial value
   * @param [options={}]   Options which affect validation behavior
   * @returns              Returns a DataModelValidationFailure if a validation failure
   *                       occurred.
   */
  validate(value: unknown, options?: DataFieldValidationOptions): DataModelValidationFailure | void;

  /**
   * Special validation rules which supersede regular field validation.
   * This validator screens for certain values which are otherwise incompatible with this field like null or undefined.
   * @param value The candidate value
   * @returns A boolean to indicate with certainty whether the value is valid.
   *                                Otherwise, return void.
   * @throws May throw a specific error if the value is not valid
   */
  protected _validateSpecial(value: unknown): boolean | void;

  /**
   * A default type-specific validator that can be overridden by child classes
   * @param value The candidate value
   * @param [options={}] Options which affect validation behavior
   * @returns A boolean to indicate with certainty whether the value is valid, or specific DataModelValidationFailure
   *          information, otherwise void.
   * @throws May throw a specific error if the value is not valid
   */
  protected _validateType(
    value: unknown,
    options?: DataFieldValidationOptions,
  ): boolean | DataModelValidationFailure | void;

  /**
   * Certain fields may declare joint data validation criteria.
   * This method will only be called if the field is designated as recursive.
   * @param data       Candidate data for joint model validation
   * @param options    Options which modify joint model validation
   * @throws  An error if joint model validation fails
   * @internal
   */
  _validateModel(data: TSourceProp, options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Initialization and Serialization            */
  /* -------------------------------------------- */

  /**
   * Initialize the original source data into a mutable copy for the DataModel instance.
   * @param value     The source value of the field
   * @param model     The DataModel instance that this field belongs to
   * @param [options] Initialization options
   */
  initialize(
    value: unknown,
    model?: ConstructorOf<DataModel>,
    options?: object,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  /**
   * Export the current value of the field into a serializable object.
   * @param value The initialized value of the field
   * @returns An exported representation of the field
   */
  toObject(value: TModelProp): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  /**
   * Recursively traverse a schema and retrieve a field specification by a given path
   * @param path The field path as an array of strings
   */
  protected _getField(path: string[]): this | undefined;
}

/* -------------------------------------------- */
/*  Data Schema Field                           */
/* -------------------------------------------- */

type DataSchema = Record<string, DataField<JSONValue, unknown, boolean>>;

/** A special class of {@link DataField} which defines a data schema. */
declare class SchemaField<
  TDataSchema extends DataSchema,
  TSourceProp extends SourceFromSchema<TDataSchema> = SourceFromSchema<TDataSchema>,
  TModelProp extends NonNullable<JSONValue> = ModelPropsFromSchema<TDataSchema>,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  /**
   * @param fields  The contained field definitions
   * @param options Options which configure the behavior of the field
   */
  constructor(fields: TDataSchema, options?: DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  protected static override get _defaults(): DataFieldOptions<object, boolean, boolean, boolean>;

  /** The contained field definitions. */
  fields: TDataSchema;

  /**
   * Initialize and validate the structure of the provided field definitions.
   * @param fields The provided field definitions
   * @returns The validated schema
   */
  protected _initialize(fields: DataSchema): DataSchema;

  /* -------------------------------------------- */
  /*  Schema Iteration                            */
  /* -------------------------------------------- */

  /** Iterate over a SchemaField by iterating over its fields. */
  [Symbol.iterator](): Generator<DataField<TSourceProp, TRequired, TNullable, THasInitial>>;

  /** An array of field names which are present in the schema. */
  keys(): string[];

  /** An array of DataField instances which are present in the schema. */
  values(): DataField[];

  /** An array of [name, DataField] tuples which define the schema. */
  entries(): [string, DataField][];

  /**
   * Test whether a certain field name belongs to this schema definition.
   * @param fieldName The field name
   * @returns Does the named field exist in this schema?
   */
  has(fieldName: string): boolean;

  /**
   * Get a DataField instance from the schema by name
   * @param fieldName The field name
   * @returns The DataField instance or undefined
   */
  get(fieldName: string): DataField | undefined;

  /* -------------------------------------------- */
  /*  Data Field Methods                          */
  /* -------------------------------------------- */

  protected override _cast(value: unknown): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  protected override _cleanType(
    data: object,
    options?: CleanFieldOptions,
  ): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  override initialize(
    value: unknown,
    model?: ConstructorOf<DataModel>,
    options?: Record<string, unknown>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  protected override _validateType(
    data: object,
    options?: Record<string, unknown>,
  ): boolean | DataModelValidationFailure | void;

  override toObject(value: TModelProp): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  override apply(
    fn: string | ((field: this, value?: unknown, options?: Record<string, unknown>) => unknown),
    data?: object,
    options?: Record<string, unknown>,
  ): unknown;
}

interface CleanFieldOptions {
  partial?: boolean;
  source?: object;
}

/* -------------------------------------------- */
/*  Basic Field Types                           */
/* -------------------------------------------- */

type BooleanFieldOptions<
  TSourceProp extends boolean,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = Omit<DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>, 'choices'>;

/** A subclass of [DataField]{@link DataField} which deals with boolean-typed data. */
declare class BooleanField<
  TSourceProp extends boolean = boolean,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): BooleanFieldOptions<boolean, boolean, boolean, boolean>;

  protected override _cast(value: unknown): unknown;

  protected override _validateType(value: unknown): value is boolean;
}

interface NumberFieldOptions<
  TSourceProp extends number,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> extends DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial> {
  /** A minimum allowed value */
  min?: number;
  /** A maximum allowed value */
  max?: number;
  /** A permitted step size */
  step?: number;
  /** Must the number be an integer? */
  integer?: boolean;
  /** Must the number be positive? */
  positive?: boolean;
}

/** A subclass of [DataField]{@link DataField} which deals with number-typed data. */
declare class NumberField<
    TSourceProp extends number = number,
    TModelProp extends NonNullable<JSONValue> = TSourceProp,
    TRequired extends boolean = false,
    TNullable extends boolean = true,
    THasInitial extends boolean = true,
  >
  extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>
  implements NumberFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>
{
  /** @param options  Options which configure the behavior of the field */
  constructor(options?: NumberFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  protected static override get _defaults(): NumberFieldOptions<number, boolean, boolean, boolean>;

  protected override _cast(value: unknown): unknown;

  protected override _cleanType(
    value: unknown,
    options?: CleanFieldOptions,
  ): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  protected override _validateType(value: unknown): void;
}

interface StringFieldOptions<
  TSourceProp extends string,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> extends DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial> {
  choices?:
    | readonly TSourceProp[]
    | Record<TSourceProp, string>
    | (() => readonly TSourceProp[] | Record<TSourceProp, string>);
  /** [blank=true] Is the string allowed to be blank (empty)? */
  blank?: boolean;
  /** [trim=true]  Should any provided string be trimmed as part of cleaning? */
  trim?: boolean;
}

/** A subclass of `DataField` which deals with string-typed data. */
declare class StringField<
    TSourceProp extends string = string,
    TModelProp extends NonNullable<JSONValue> = TSourceProp,
    TRequired extends boolean = false,
    TNullable extends boolean = false,
    THasInitial extends boolean = true,
  >
  extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>
  implements StringFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>
{
  /** @param options Options which configure the behavior of the field */
  constructor(options?: StringFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  protected static override get _defaults(): StringFieldOptions<string, boolean, boolean, boolean>;

  override clean(
    value: unknown,
    options: CleanFieldOptions,
  ): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  protected override _cast(value: unknown): unknown;

  protected override _validateSpecial(value: unknown): boolean | void;

  protected _validateType(value: unknown): boolean | void;
}

type ObjectFieldOptions<
  TSourceProp extends object,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;

/** A subclass of `DataField` which deals with object-typed data. */
declare class ObjectField<
    TSourceProp extends object,
    TModelProp extends object = TSourceProp,
    TRequired extends boolean = true,
    TNullable extends boolean = false,
    THasInitial extends boolean = true,
  >
  extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>
  implements Omit<ObjectFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>, 'initial'>
{
  protected static override get _defaults(): ObjectFieldOptions<object, boolean, boolean, boolean>;

  protected override _cast(value: unknown): unknown;

  override initialize(
    value: unknown,
    model?: ConstructorOf<DataModel>,
    options?: ObjectFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  override toObject(value: TModelProp): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  protected override _validateType(
    value: unknown,
    options?: DataFieldValidationOptions,
  ): DataModelValidationFailure | boolean | void;
}

type ArrayFieldOptions<
  TSourceProp extends unknown[],
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;

/** A subclass of `DataField` which deals with array-typed data. */
declare class ArrayField<
    TElementField extends DataField,
    TSourceProp extends Partial<SourcePropFromDataField<TElementField>>[] = SourcePropFromDataField<TElementField>[],
    TModelProp extends object = ModelPropFromDataField<TElementField>[],
    TRequired extends boolean = false,
    TNullable extends boolean = false,
    THasInitial extends boolean = true,
  >
  extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>
  implements ArrayFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>
{
  /**
   * @param element A DataField instance which defines the type of element contained in the Array.
   * @param options Options which configure the behavior of the field
   */
  constructor(element: TElementField, options?: ArrayFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  /** The data type of each element in this array */
  element: TElementField;

  /**
   * Validate the contained element type of the ArrayField
   * @param element The type of Array element
   * @returns The validated element type
   * @throws An error if the element is not a valid type
   */
  protected static _validateElementType(element: unknown): unknown;

  override _validateModel(changes: TSourceProp, options?: Record<string, unknown>): void;

  protected static override get _defaults(): ArrayFieldOptions<unknown[], boolean, boolean, boolean>;

  protected override _cast(value: unknown): unknown;

  protected _cleanType(value: unknown, options?: CleanFieldOptions): unknown;

  protected override _validateType(value: unknown, options?: Record<string, unknown>): void;

  /**
   * Validate every element of the ArrayField
   * @param value   The array to validate
   * @param options Validation options
   * @returns An array of element-specific errors
   */
  protected _validateElements(value: unknown[], options?: Record<string, unknown>): DataModelValidationFailure | void;

  override initialize(
    value: JSONValue,
    model: ConstructorOf<DataModel>,
    options: ArrayFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  override toObject(value: TModelProp): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  override apply(
    fn: string | ((field: this, value?: unknown, options?: Record<string, unknown>) => unknown),
    data?: object,
    options?: Record<string, unknown>,
  ): unknown;
}

interface ArrayField<
  TElementField extends DataField,
  TSourceProp extends Partial<SourcePropFromDataField<TElementField>>[] = SourcePropFromDataField<TElementField>[],
  TModelProp extends object = ModelPropFromDataField<TElementField>[],
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  clean(value: unknown, options?: CleanFieldOptions): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;
}

/**
 * A subclass of `ArrayField` which supports a set of contained elements.
 * Elements in this set are treated as fungible and may be represented in any order or discarded if invalid.
 */
declare class SetField<
  TElementField extends DataField,
  TSourceProp extends SourcePropFromDataField<TElementField>[] = SourcePropFromDataField<TElementField>[],
  TModelProp extends Set<ModelPropFromDataField<TElementField>> = Set<ModelPropFromDataField<TElementField>>,
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends ArrayField<TElementField, TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  protected override _validateElements(
    value: unknown[],
    options?: Record<string, unknown>,
  ): DataModelValidationFailure | void;

  override initialize(
    value: TSourceProp,
    model: ConstructorOf<DataModel>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  override toObject(value: TModelProp): TSourceProp;
}

/** A subclass of `SchemaField` which embeds some other DataModel definition as an inner object. */
declare class EmbeddedDataField<
  TModelProp extends DataModel = DataModel,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends SchemaField<
  TModelProp['schema']['fields'],
  SourceFromSchema<TModelProp['schema']['fields']>,
  TModelProp,
  TRequired,
  TNullable,
  THasInitial
> {
  /**
   * @param model   The class of DataModel which should be embedded in this field
   * @param options Options which configure the behavior of the field
   */
  constructor(
    model: ConstructorOf<TModelProp>,
    options?: ObjectFieldOptions<SourceFromSchema<TModelProp['schema']['fields']>, TRequired, TNullable, THasInitial>,
  );

  /** The embedded DataModel definition which is contained in this field. */
  model: ConstructorOf<TModelProp>;

  protected override _initialize(fields: DataSchema): DataSchema;

  override initialize(
    value: MaybeSchemaProp<TModelProp['_source'], TRequired, TNullable, THasInitial>,
    model: ConstructorOf<DataModel>,
    options?: object,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  override toObject(
    value: TModelProp,
  ): MaybeSchemaProp<SourceFromSchema<TModelProp['schema']['fields']>, TRequired, TNullable, THasInitial>;
}

/** A subclass of {@link EmbeddedDataField} which supports a single embedded Document. */
declare class EmbeddedDocumentField<
  TModelProp extends Document$1,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> extends EmbeddedDataField<TModelProp, TRequired, TNullable, THasInitial> {
  /**
   * @param model   The type of Document which is embedded.
   * @param options Options which configure the behavior of the field.
   */
  constructor(
    model: ConstructorOf<TModelProp>,
    options?: DataFieldOptions<TModelProp['_source'], TRequired, TNullable, THasInitial>,
  );

  static override get _defaults(): DataFieldOptions<object, boolean, true, boolean>;

  static override hierarchical: boolean;

  override initialize(
    value: MaybeSchemaProp<TModelProp['_source'], TRequired, TNullable, THasInitial>,
    model: ConstructorOf<TModelProp>,
    options?: Record<string, unknown>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  /* -------------------------------------------- */
  /*  Embedded Document Operations                */
  /* -------------------------------------------- */

  /**
   * Return the embedded document(s) as a Collection.
   * @param parent The parent document.
   */
  getCollection(parent: Document$1): Collection<TModelProp>;
}

/**
 * A subclass of `ArrayField` which supports an embedded Document collection.
 * Invalid elements will be dropped from the collection during validation rather than failing for the field entirely.
 */
declare class EmbeddedCollectionField<
  TDocument extends Document$1<Document$1>,
  TSourceProp extends object[] = SourceFromDocument<TDocument>[],
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends ArrayField<
  TDocument['schema'],
  TSourceProp,
  EmbeddedCollection<TDocument>,
  TRequired,
  TNullable,
  THasInitial
> {
  /**
   * @param element The type of Document which belongs to this embedded collection
   * @param options Options which configure the behavior of the field
   */
  constructor(
    element: ConstructorOf<Document>,
    options?: ArrayFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>,
  );

  static override _validateElementType(element: unknown): Document;

  /** A reference to the DataModel subclass of the embedded document element */
  get model(): ConstructorOf<Document>;

  /** The DataSchema of the contained Document model. */
  get schema(): TDocument['schema'];

  protected override _cleanType(
    value: unknown,
    options?: CleanFieldOptions,
  ): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  protected override _validateElements(
    value: unknown[],
    options?: Record<string, unknown>,
  ): DataModelValidationFailure | void;

  override initialize(
    _value: unknown,
    model: ConstructorOf<DataModel>,
  ): MaybeSchemaProp<EmbeddedCollection<TDocument>, TRequired, TNullable, THasInitial>;

  override toObject(
    value: EmbeddedCollection<TDocument>,
  ): MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>;

  override apply(
    fn: string | ((field: this, value?: unknown, options?: Record<string, unknown>) => unknown),
    data?: object,
    options?: Record<string, unknown>,
  ): unknown;
}

/**
 * A subclass of {@link EmbeddedCollectionField} which manages a collection of delta objects relative to another
 * collection.
 * @todo: fill in
 */
declare class EmbeddedCollectionDeltaField<
  TDocument extends Document$1<Document$1>,
  TSource extends (SourceFromDocument<TDocument> | SourceFromSchema<TombstoneDataSchema>)[] = (
    | SourceFromDocument<TDocument>
    | SourceFromSchema<TombstoneDataSchema>
  )[],
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends EmbeddedCollectionField<TDocument, TSource, TRequired, TNullable, THasInitial> {}

/* -------------------------------------------- */
/*  Special Field Types                         */
/* -------------------------------------------- */

/**
 * A subclass of [StringField]{@link StringField} which provides the primary _id for a Document.
 * The field may be initially null, but it must be non-null when it is saved to the database.
 */
declare class DocumentIdField<
  TModelProp extends string | Document$1 = string,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> extends StringField<string, TModelProp, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): StringFieldOptions<string, boolean, boolean, boolean>;

  protected override _cast(value: unknown): string;

  protected override _validateType(value: unknown): boolean;
}

/**
 * A special class of [StringField]{@link StringField} field which references another DataModel by its id.
 * This field may also be null to indicate that no foreign model is linked.
 */
declare class ForeignDocumentField<
  TModelProp extends string | Document$1 = Document$1,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> extends DocumentIdField<TModelProp, TRequired, TNullable, THasInitial> {
  /**
   * @param model   The foreign DataModel class definition which this field should link to.
   * @param options Options which configure the behavior of the field
   */
  constructor(model: ConstructorOf<DataModel>, options?: StringFieldOptions<string, TRequired, TNullable, THasInitial>);

  /** A reference to the model class which is stored in this field */
  model: DataModel;

  protected static override get _defaults(): StringFieldOptions<string, boolean, boolean, boolean>;

  _cast(value: unknown): string;

  override initialize(
    value: string,
    model: ConstructorOf<DataModel>,
  ): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  toObject(value: TModelProp): MaybeSchemaProp<string, TRequired, TNullable, THasInitial>;
}

/** A special `StringField` which records a standardized CSS color string. */
declare class ColorField<
  TRequired extends boolean = false,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> extends StringField<HexColorString, HexColorString, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): StringFieldOptions<HexColorString, boolean, boolean, boolean>;

  protected override _validateType(value: unknown): boolean;
}

/**
 * @typedef FilePathFieldOptions
 * @property [categories]   A set of categories in CONST.FILE_CATEGORIES which this field supports
 * @property [base64=false] Is embedded base64 data supported in lieu of a file path?
 */
interface FilePathFieldOptions<
  TSourceProp extends FilePath,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> extends StringFieldOptions<TSourceProp, TRequired, TNullable, THasInitial> {
  categories?: FileCategory[];
  base64?: boolean;
}

/** A special `StringField` which records a file path or inline base64 data. */
declare class FilePathField<
  TSourceProp extends FilePath = FilePath,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = false,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> extends StringField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  /** @param options  Options which configure the behavior of the field */
  constructor(options?: FilePathFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>);

  protected static override get _defaults(): FilePathFieldOptions<FilePath, boolean, boolean, boolean>;

  protected override _validateType(value: unknown): void;
}

interface AngleFieldOptions<
  TSourceProp extends number,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> extends NumberFieldOptions<TSourceProp, TRequired, TNullable, THasInitial> {
  min?: number;
  max?: number;
  step?: number;
  integer?: boolean;
  base?: 360 | 0;
}

/**
 * A special `NumberField` which represents an angle of rotation in degrees between 0 and 360.
 * @property base Whether the base angle should be treated as 360 or as 0
 */
declare class AngleField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends NumberField<number, number, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): AngleFieldOptions<number, boolean, boolean, boolean>;

  protected override _cast(value: unknown): number;
}

/** A special `NumberField` represents a number between 0 and 1. */
declare class AlphaField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends NumberField<number, number, TRequired, TNullable, THasInitial> {
  protected static get _defaults(): NumberFieldOptions<number, boolean, boolean, boolean>;
}

/** A special `ObjectField` which captures a mapping of User IDs to Document permission levels. */
declare class DocumentOwnershipField extends ObjectField<{ [K in string]?: DocumentOwnershipLevel }> {
  protected static override get _defaults(): ObjectFieldOptions<
    Record<string, DocumentOwnershipLevel | undefined>,
    true,
    false,
    true
  >;

  protected override _validateType(value: object): boolean | void;
}

/** A special [StringField]{@link StringField} which contains serialized JSON data. */
declare class JSONField<
  TModelProp extends NonNullable<JSONValue> = object,
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = false,
> extends StringField<string, TModelProp, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): StringFieldOptions<string, boolean, boolean, boolean>;

  override clean(
    value: unknown,
    options?: CleanFieldOptions,
  ): MaybeSchemaProp<string, TRequired, TNullable, THasInitial>;

  protected override _validateType(value: unknown): boolean;

  override initialize(value: string): MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>;

  toObject(value: TModelProp): MaybeSchemaProp<string, TRequired, TNullable, THasInitial>;
}

/**
 * A subclass of [StringField]{@link StringField} which contains a sanitized HTML string.
 * This class does not override any StringField behaviors, but is used by the server-side to identify fields which
 * require sanitization of user input.
 */
declare class HTMLField<
  TSourceProp extends string = string,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends StringField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): StringFieldOptions<string, boolean, boolean, boolean>;
}

/** A subclass of `NumberField` which is used for storing integer sort keys. */
declare class IntegerSortField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> extends NumberField<number, number, TRequired, TNullable, THasInitial> {
  protected static override get _defaults(): NumberFieldOptions<number, boolean, boolean, boolean>;
}

/** @typedef DocumentStats
 * @property systemId       The package name of the system the Document was created in.
 * @property systemVersion  The version of the system the Document was created in.
 * @property coreVersion    The core version the Document was created in.
 * @property createdTime    A timestamp of when the Document was created.
 * @property modifiedTime   A timestamp of when the Document was last modified.
 * @property lastModifiedBy The ID of the user who last modified the Document.
 */

/**
 * A subclass of {@link SchemaField} which stores document metadata in the _stats field.
 * @mixes DocumentStats
 */
declare class DocumentStatsField extends SchemaField<DocumentStatsSchema> {
  constructor(options?: ObjectFieldOptions<DocumentStatsSchema, true, false, true>);
}

type DocumentStatsSchema = {
  systemId: StringField<string, string, true, false, true>;
  systemVersion: StringField<string, string, true, false, true>;
  coreVersion: StringField<string, string, true, false, true>;
  createdTime: NumberField;
  modifiedTime: NumberField;
  lastModifiedBy: ForeignDocumentField<string>;
};

/** A subclass of `ObjectField` which supports a system-level data object. */
declare class TypeDataField<
  TSourceProp extends object = object,
  TModelProp extends object = TSourceProp,
  TDocument extends Document$1 = Document$1,
> extends ObjectField<TSourceProp, TModelProp> {
  /**
   * @param document The base document class which belongs in this field
   * @param options  Options which configure the behavior of the field
   */
  constructor(document: ConstructorOf<TDocument>, options?: ObjectFieldOptions<TSourceProp, true, false, true>);

  /** The canonical document name of the document type which belongs in this field */
  document: ConstructorOf<TDocument>;

  protected static override get _defaults(): ObjectFieldOptions<object, true, false, true>;

  static override recursive: boolean;

  /**
   * Return the package that provides the sub-type for the given model.
   * @param {DataModel} model       The model instance created for this sub-type.
   * @returns {System|Module|null}
   */
  static getModelProvider(model: DataModel): DataModel | null;

  /** A convenience accessor for the name of the document type associated with this TypeDataField */
  get documentName(): TDocument['documentName'];

  /**
   * Get the DataModel definition that should be used for this type of document.
   * @param type The Document instance type
   * @returns {typeof DataModel|null}  The DataModel class or null
   */
  getModelForType(type: string): typeof DataModel | null;

  override getInitialValue(data: object): TSourceProp;

  protected override _cleanType(value: unknown, options?: CleanFieldOptions): TSourceProp;

  override initialize(
    value: TSourceProp,
    model?: ConstructorOf<TDocument>,
    options?: Record<string, unknown>,
  ): MaybeSchemaProp<TModelProp, true, false, true>;

  protected override _validateType(data: unknown, options?: Record<string, unknown>): void | DataModelValidationFailure;

  override _validateModel(changes: TSourceProp, options?: Record<string, unknown>): void;

  override toObject(value: TModelProp): TSourceProp;

  /**
   * Migrate this field's candidate source data.
   * @param sourceData Candidate source data of the root model
   * @param fieldData  The value of this field within the source data
   */
  migrateSource(sourceData: Record<string, unknown>, fieldData: Record<string, unknown>): void;
}

// System utility types

type SourcePropFromDataField<T> =
  T extends DataField<infer TSourceProp, infer _TModelProp, infer TRequired, infer TNullable, infer THasInitial>
    ? MaybeSchemaProp<TSourceProp, TRequired, TNullable, THasInitial>
    : never;

type SourceFromDocument<T extends Document$1> = SourcePropFromDataField<T['schema']>;
type ModelPropFromDataField<T> =
  T extends DataField<infer _TSourceProp, infer TModelProp, infer TRequired, infer TNullable, infer THasInitial>
    ? MaybeSchemaProp<TModelProp, TRequired, TNullable, THasInitial>
    : never;

type MaybeSchemaProp<
  TProp,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = TRequired extends true
  ? TNullable extends true
    ? TProp | null
    : TProp
  : TNullable extends true
    ? THasInitial extends true
      ? TProp | null
      : TProp | null | undefined
    : THasInitial extends true
      ? TProp
      : TProp | undefined;

declare global {
  type ModelPropsFromSchema<TDataSchema extends DataSchema> = {
    [K in keyof TDataSchema]: ModelPropFromDataField<TDataSchema[K]>;
  };

  type SourceFromSchema<TDataSchema extends DataSchema> = {
    [K in keyof TDataSchema]: SourcePropFromDataField<TDataSchema[K]>;
  };

  type DocumentSourceFromSchema<TDataSchema extends DataSchema, THasId extends boolean = boolean> = {
    [K in keyof TDataSchema]: K extends '_id'
      ? THasId extends true
        ? string
        : THasId extends false
          ? null
          : string | null
      : SourcePropFromDataField<TDataSchema[K]>;
  };

  type HexColorString = `#${string}`;
  type AudioFilePath = `${string}.${AudioFileExtension}`;
  type ImageFilePath = `${string}.${ImageFileExtension}`;
  type VideoFilePath = `${string}.${VideoFileExtension}`;
  type FilePath = AudioFilePath | ImageFilePath | VideoFilePath;
}

type fields_d_AlphaField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = AlphaField<TRequired, TNullable, THasInitial>;
declare const fields_d_AlphaField: typeof AlphaField;
type fields_d_AngleField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = AngleField<TRequired, TNullable, THasInitial>;
declare const fields_d_AngleField: typeof AngleField;
type fields_d_AngleFieldOptions<
  TSourceProp extends number,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = AngleFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_ArrayField<
  TElementField extends DataField,
  TSourceProp extends Partial<SourcePropFromDataField<TElementField>>[] = SourcePropFromDataField<TElementField>[],
  TModelProp extends object = ModelPropFromDataField<TElementField>[],
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = ArrayField<TElementField, TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
type fields_d_ArrayFieldOptions<
  TSourceProp extends unknown[],
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = ArrayFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_BooleanField<
  TSourceProp extends boolean = boolean,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = BooleanField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_BooleanField: typeof BooleanField;
type fields_d_BooleanFieldOptions<
  TSourceProp extends boolean,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = BooleanFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_CleanFieldOptions = CleanFieldOptions;
type fields_d_ColorField<
  TRequired extends boolean = false,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = ColorField<TRequired, TNullable, THasInitial>;
declare const fields_d_ColorField: typeof ColorField;
type fields_d_DataField<
  TSourceProp extends JSONValue = JSONValue,
  TModelProp = TSourceProp,
  TRequired extends boolean = boolean,
  TNullable extends boolean = boolean,
  THasInitial extends boolean = boolean,
> = DataField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_DataField: typeof DataField;
type fields_d_DataFieldOptions<
  TSourceProp,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = DataFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_DataSchema = DataSchema;
type fields_d_DocumentIdField<
  TModelProp extends string | Document$1 = string,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = DocumentIdField<TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_DocumentIdField: typeof DocumentIdField;
type fields_d_DocumentOwnershipField = DocumentOwnershipField;
declare const fields_d_DocumentOwnershipField: typeof DocumentOwnershipField;
type fields_d_DocumentStatsField = DocumentStatsField;
declare const fields_d_DocumentStatsField: typeof DocumentStatsField;
type fields_d_DocumentStatsSchema = DocumentStatsSchema;
type fields_d_EmbeddedCollectionDeltaField<
  TDocument extends Document$1<Document$1>,
  TSource extends (SourceFromDocument<TDocument> | SourceFromSchema<TombstoneDataSchema>)[] = (
    | SourceFromDocument<TDocument>
    | SourceFromSchema<TombstoneDataSchema>
  )[],
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = EmbeddedCollectionDeltaField<TDocument, TSource, TRequired, TNullable, THasInitial>;
declare const fields_d_EmbeddedCollectionDeltaField: typeof EmbeddedCollectionDeltaField;
type fields_d_EmbeddedCollectionField<
  TDocument extends Document$1<Document$1>,
  TSourceProp extends object[] = SourceFromDocument<TDocument>[],
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = EmbeddedCollectionField<TDocument, TSourceProp, TRequired, TNullable, THasInitial>;
declare const fields_d_EmbeddedCollectionField: typeof EmbeddedCollectionField;
type fields_d_EmbeddedDataField<
  TModelProp extends DataModel = DataModel,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = EmbeddedDataField<TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_EmbeddedDataField: typeof EmbeddedDataField;
type fields_d_EmbeddedDocumentField<
  TModelProp extends Document$1,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = EmbeddedDocumentField<TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_EmbeddedDocumentField: typeof EmbeddedDocumentField;
type fields_d_FilePathField<
  TSourceProp extends FilePath = FilePath,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = false,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = FilePathField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_FilePathField: typeof FilePathField;
type fields_d_FilePathFieldOptions<
  TSourceProp extends FilePath,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = FilePathFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_ForeignDocumentField<
  TModelProp extends string | Document$1 = Document$1,
  TRequired extends boolean = true,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = ForeignDocumentField<TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_ForeignDocumentField: typeof ForeignDocumentField;
type fields_d_HTMLField<
  TSourceProp extends string = string,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = HTMLField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_HTMLField: typeof HTMLField;
type fields_d_IntegerSortField<
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = IntegerSortField<TRequired, TNullable, THasInitial>;
declare const fields_d_IntegerSortField: typeof IntegerSortField;
type fields_d_JSONField<
  TModelProp extends NonNullable<JSONValue> = object,
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = false,
> = JSONField<TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_JSONField: typeof JSONField;
type fields_d_MaybeSchemaProp<
  TProp,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = MaybeSchemaProp<TProp, TRequired, TNullable, THasInitial>;
type fields_d_ModelPropFromDataField<T> = ModelPropFromDataField<T>;
type fields_d_NumberField<
  TSourceProp extends number = number,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = false,
  TNullable extends boolean = true,
  THasInitial extends boolean = true,
> = NumberField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_NumberField: typeof NumberField;
type fields_d_NumberFieldOptions<
  TSourceProp extends number,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = NumberFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_ObjectField<
  TSourceProp extends object,
  TModelProp extends object = TSourceProp,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = ObjectField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_ObjectField: typeof ObjectField;
type fields_d_ObjectFieldOptions<
  TSourceProp extends object,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = ObjectFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_SchemaField<
  TDataSchema extends DataSchema,
  TSourceProp extends SourceFromSchema<TDataSchema> = SourceFromSchema<TDataSchema>,
  TModelProp extends NonNullable<JSONValue> = ModelPropsFromSchema<TDataSchema>,
  TRequired extends boolean = true,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = SchemaField<TDataSchema, TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_SchemaField: typeof SchemaField;
type fields_d_SetField<
  TElementField extends DataField,
  TSourceProp extends SourcePropFromDataField<TElementField>[] = SourcePropFromDataField<TElementField>[],
  TModelProp extends Set<ModelPropFromDataField<TElementField>> = Set<ModelPropFromDataField<TElementField>>,
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = SetField<TElementField, TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_SetField: typeof SetField;
type fields_d_SourceFromDocument<T extends Document$1> = SourceFromDocument<T>;
type fields_d_SourcePropFromDataField<T> = SourcePropFromDataField<T>;
type fields_d_StringField<
  TSourceProp extends string = string,
  TModelProp extends NonNullable<JSONValue> = TSourceProp,
  TRequired extends boolean = false,
  TNullable extends boolean = false,
  THasInitial extends boolean = true,
> = StringField<TSourceProp, TModelProp, TRequired, TNullable, THasInitial>;
declare const fields_d_StringField: typeof StringField;
type fields_d_StringFieldOptions<
  TSourceProp extends string,
  TRequired extends boolean,
  TNullable extends boolean,
  THasInitial extends boolean,
> = StringFieldOptions<TSourceProp, TRequired, TNullable, THasInitial>;
type fields_d_TypeDataField<
  TSourceProp extends object = object,
  TModelProp extends object = TSourceProp,
  TDocument extends Document$1 = Document$1,
> = TypeDataField<TSourceProp, TModelProp, TDocument>;
declare const fields_d_TypeDataField: typeof TypeDataField;
declare namespace fields_d {
  export {
    fields_d_AlphaField as AlphaField,
    fields_d_AngleField as AngleField,
    type fields_d_AngleFieldOptions as AngleFieldOptions,
    type fields_d_ArrayField as ArrayField,
    type fields_d_ArrayFieldOptions as ArrayFieldOptions,
    fields_d_BooleanField as BooleanField,
    type fields_d_BooleanFieldOptions as BooleanFieldOptions,
    type fields_d_CleanFieldOptions as CleanFieldOptions,
    fields_d_ColorField as ColorField,
    fields_d_DataField as DataField,
    type fields_d_DataFieldOptions as DataFieldOptions,
    type fields_d_DataSchema as DataSchema,
    fields_d_DocumentIdField as DocumentIdField,
    fields_d_DocumentOwnershipField as DocumentOwnershipField,
    fields_d_DocumentStatsField as DocumentStatsField,
    type fields_d_DocumentStatsSchema as DocumentStatsSchema,
    fields_d_EmbeddedCollectionDeltaField as EmbeddedCollectionDeltaField,
    fields_d_EmbeddedCollectionField as EmbeddedCollectionField,
    fields_d_EmbeddedDataField as EmbeddedDataField,
    fields_d_EmbeddedDocumentField as EmbeddedDocumentField,
    fields_d_FilePathField as FilePathField,
    type fields_d_FilePathFieldOptions as FilePathFieldOptions,
    fields_d_ForeignDocumentField as ForeignDocumentField,
    fields_d_HTMLField as HTMLField,
    fields_d_IntegerSortField as IntegerSortField,
    fields_d_JSONField as JSONField,
    type fields_d_MaybeSchemaProp as MaybeSchemaProp,
    type fields_d_ModelPropFromDataField as ModelPropFromDataField,
    fields_d_NumberField as NumberField,
    type fields_d_NumberFieldOptions as NumberFieldOptions,
    fields_d_ObjectField as ObjectField,
    type fields_d_ObjectFieldOptions as ObjectFieldOptions,
    fields_d_SchemaField as SchemaField,
    fields_d_SetField as SetField,
    type fields_d_SourceFromDocument as SourceFromDocument,
    type fields_d_SourcePropFromDataField as SourcePropFromDataField,
    fields_d_StringField as StringField,
    type fields_d_StringFieldOptions as StringFieldOptions,
    fields_d_TypeDataField as TypeDataField,
  };
}

/** Used for the specific task of containing embedded Document instances within a parent Document. */
declare class EmbeddedCollection<TDocument extends Document$1<Document$1>> extends Collection<TDocument> {
  constructor(
    /** The name of this collection in the parent Document. */
    name: string,
    /** The parent DataModel instance to which this collection belongs. */
    parent: ConstructorOf<TDocument>,
    /** The source data array for the collection in the parent Document data. */
    sourceArray: PreCreate<TDocument['_source']>[],
  );

  /** The Document implementation used to construct instances within this collection. */
  documentClass: ConstructorOf<TDocument>;

  /** The name of this collection in the parent Document. */
  name: string;

  /** The parent DataModel to which this EmbeddedCollection instance belongs. */
  model: TDocument['parent'];

  /** Has this embedded collection been initialized as a one-time workflow? */
  protected _initialized: boolean;

  /** The source data array from which the embedded collection is created */
  private _source: PreCreate<TDocument['_source']>[];

  /** Record the set of document ids where the Document was not initialized because of invalid source data */
  invalidDocumentIds: Set<string>;

  /**
   * Instantiate a Document for inclusion in the Collection.
   * @param data    The Document data.
   * @param context Document creation context.
   */
  createDocument(
    data: PreCreate<TDocument['_source']>,
    context?: DocumentConstructionContext<TDocument['parent']>,
  ): TDocument;

  /**
   * Initialize the EmbeddedCollection object by constructing its contained Document instances
   * @param options Initialization options.
   * @param options.strict Whether to log an error or a warning when encountering invalid embedded documents.
   */
  initialize(options?: { strict?: boolean }): void;

  /**
   * Initialize an embedded document and store it in the collection.
   * @param data    The Document data.
   * @param options Options to configure Document initialization.
   * @param options.strict Whether to log an error or warning if the Document fails to initialize.
   */
  protected _initializeDocument(data: PreCreate<TDocument['_source']>, options?: { strict?: boolean }): void;

  /**
   * Log warnings or errors when a Document is found to be invalid.
   * @param id             The invalid Document's ID.
   * @param err            The validation error.
   * @param options        Options to configure invalid Document handling.
   * @param options.strict Whether to throw an error or only log a warning.
   */
  protected _handleInvalidDocument(id: string, err: string, options?: { strict?: boolean }): void;

  /**
   * Get an element from the EmbeddedCollection by its ID.
   * @param id        The ID of the Embedded Document to retrieve.
   * @param [options] Additional options to configure retrieval.
   * @param [options.strict=false]  Throw an Error if the requested Embedded Document does not exist.
   * @param [options.invalid=false] Allow retrieving an invalid Embedded Document.
   * @throws If strict is true and the Embedded Document cannot be found.
   */
  override get<T extends TDocument = TDocument>(key: Maybe<string>, options: { strict: true; invalid?: boolean }): T;
  override get<T extends TDocument = TDocument>(key: string, options?: EmbeddedCollectionGetOptions): T | undefined;

  /**
   * Add an item to the collection.
   * @param {string} key                           The embedded Document ID.
   * @param {Document} value                       The embedded Document instance.
   * @param {object} [options]                     Additional options to the set operation.
   * @param {boolean} [options.modifySource=true]  Whether to modify the collection's source as part of the operation.
   */
  override set(key: string, value: TDocument, { modifySource }?: { modifySource?: boolean }): this;

  /**
   * Modify the underlying source array to include the Document.
   * @param key   The Document ID key.
   * @param value The Document.
   */
  protected _set(key: string, value: TDocument): void;

  /**
   * @param {string} key                           The embedded Document ID.
   * @param {object} [options]                     Additional options to the delete operation.
   * @param {boolean} [options.modifySource=true]  Whether to modify the collection's source as part of the operation.
   */
  override delete(key: string, { modifySource }?: { modifySource?: boolean }): boolean;

  /**
   * Remove the value from the underlying source array.
   * @param key       The Document ID key.
   * @param [options] Additional options to configure deletion behavior.
   */
  protected _delete(key: string, options?: object): void;

  /**
   * Update an EmbeddedCollection using an array of provided document data.
   * @param {DataModel[]} changes         An array of provided Document data
   * @param {object} [options={}]         Additional options which modify how the collection is updated
   */
  update(changes?: { _id: string; [key: string]: unknown }[], options?: DocumentSourceUpdateContext): void;

  /**
   * Create or update an embedded Document in this collection.
   * @param data         The update delta.
   * @param [options={}] Additional options which modify how the collection is updated.
   */
  protected _createOrUpdate(data: { _id: string; [key: string]: unknown }, options?: DocumentSourceUpdateContext): void;

  /**
   * Obtain a temporary Document instance for a document id which currently has invalid source data.
   * @param id        A document ID with invalid source data.
   * @param [options] Additional options to configure retrieval.
   * @param [options.strict=true] Throw an Error if the requested ID is not in the set of invalid IDs for this
   *                              collection.
   * @returns An in-memory instance for the invalid Document
   * @throws If strict is true and the requested ID is not in the set of invalid IDs for this collection.
   */
  getInvalid(id: string, options?: { strict?: boolean }): TDocument | undefined;

  /**
   * Convert the EmbeddedCollection to an array of simple objects.
   * @param [source=true] Draw data for contained Documents from the underlying data source?
   * @returns The extracted array of primitive objects
   */
  toObject<T extends true>(source?: T): TDocument['_source'][];
  toObject<T extends false>(source: T): RawObject<TDocument>[];
  toObject<T extends boolean>(source?: T): TDocument['_source'][] | RawObject<TDocument>[];
}

interface EmbeddedCollectionGetOptions extends CollectionGetOptions {
  invalid?: boolean;
}

/** The abstract base interface for all Document types. */
declare abstract class Document$1<
  TParent extends Document$1 | null = _Document | null,
  TSchema extends DataSchema = DataSchema,
> extends DataModel<TParent, TSchema> {
  protected override _configure(options?: { pack?: string | null; parentCollection?: string | null }): void;

  /**
   * An immutable reverse-reference to the name of the collection that this Document exists in on its parent, if any.
   */
  readonly parentCollection: string | null;

  /** An immutable reference to a containing Compendium collection to which this Document belongs. */
  readonly pack: string | null;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Model Configuration                         */
  /* -------------------------------------------- */

  /** Default metadata which applies to each instance of this Document type. */
  static get metadata(): DocumentMetadata;

  /**
   * The database backend used to execute operations and handle results.
   * @type {abstract.DatabaseBackend}
   */
  static get database(): DatabaseBackend;

  /** Return a reference to the implemented subclass of this base document type. */
  static get implementation(): ConstructorOf<Document$1>;

  /** The named collection to which this Document belongs. */
  static get collectionName(): string;
  /** The named collection to which this Document belongs. */
  get collectionName(): string;

  /** The canonical name of this Document type, for example "Actor". */
  static get documentName(): string;
  /** The canonical name of this Document type, for example "Actor". */
  get documentName(): string;

  /** Does this Document support additional sub-types? */
  static get hasTypeData(): boolean;

  /* -------------------------------------------- */
  /*  Model Properties                            */
  /* -------------------------------------------- */

  /** The Embedded Document hierarchy for this Document. */
  static get hierarchy(): Record<string, DataField>;

  /**
   * Determine the collection this Document exists in on its parent, if any.
   * @param [parentCollection]  An explicitly provided parent collection name.
   */
  protected _getParentCollection(parentCollection: string): string | null;

  /** The canonical identifier for this Document. */
  get id(): string;

  /** Test whether this Document is embedded within a parent Document */
  get isEmbedded(): boolean;

  /* ---------------------------------------- */
  /*  Model Permissions                       */
  /* ---------------------------------------- */

  /**
   * Test whether a given User has a sufficient role in order to create Documents of this type in general.
   * @param user The User being tested
   * @return Does the User have a sufficient role to create?
   */
  static canUserCreate(user: BaseUser): boolean;

  /**
   * Get the explicit permission level that a User has over this Document, a value in CONST.DOCUMENT_OWNERSHIP_LEVELS.
   * This method returns the value recorded in Document ownership, regardless of the User's role.
   * To test whether a user has a certain capability over the document, testUserPermission should be used.
   * @param {documents.BaseUser} user     The User being tested
   * @returns {number|null}               A numeric permission level from CONST.DOCUMENT_OWNERSHIP_LEVELS or null
   */
  getUserLevel(user: BaseUser): DocumentOwnershipLevel | null;

  /**
   * Test whether a certain User has a requested permission level (or greater) over the Document
   * @param user       The User being tested
   * @param permission The permission level from DOCUMENT_PERMISSION_LEVELS to test
   * @param options    Additional options involved in the permission test
   * @param [options.exact=false] Require the exact permission level requested?
   * @return Does the user have this permission level over the Document?
   */
  testUserPermission(
    user: BaseUser,
    permission: DocumentOwnershipString | DocumentOwnershipLevel,
    { exact }?: { exact?: boolean },
  ): boolean;

  /**
   * Test whether a given User has permission to perform some action on this Document
   * @param user   The User attempting modification
   * @param action The attempted action
   * @param [data] Data involved in the attempted action
   * @return Does the User have permission?
   */
  canUserModify(user: BaseUser, action: UserAction, data?: Record<string, unknown>): boolean;

  /* ---------------------------------------- */
  /*  Model Methods                           */
  /* ---------------------------------------- */

  /**
   * Clone a document, creating a new document by combining current data with provided overrides.
   * The cloned document is ephemeral and not yet saved to the database.
   * @param [data={}]              Additional data which overrides current document data at the time of creation
   * @param [context={}]           Additional options which customize the creation workflow
   * @param [context.save=false]   Save the clone to the World database?
   * @param [context.keepId=false] Keep the original Document ID? Otherwise the ID will become undefined
   * @returns The cloned Document instance
   */
  override clone(
    data: Record<string, unknown> | undefined,
    context: DocumentCloneContext & { save: true },
  ): Promise<this>;
  override clone(data?: Record<string, unknown>, context?: DocumentCloneContext & { save?: false }): this;
  override clone(data?: Record<string, unknown>, context?: DocumentCloneContext): this | Promise<this>;

  /**
   * For Documents which include game system data, migrate the system data object to conform to its latest data model.
   * The data model is defined by the template.json specification included by the game system.
   * @returns The migrated system data object
   */
  migrateSystemData(): Record<string, JSONValue>;

  /* -------------------------------------------- */
  /*  Database Operations                         */
  /* -------------------------------------------- */

  /**
   * Validate the data contained in the document to check for type and content
   * This function throws an error if data within the document is not valid
   *
   * @param options Optional parameters which customize how validation occurs.
   * @param [options.changes]        A specific set of proposed changes to validate, rather than the full
   *                                 source data of the model.
   * @param [options.clean=false]    If changes are provided, attempt to clean the changes before validating
   *                                 them?
   * @param [options.fallback=false] Allow replacement of invalid values with valid defaults?
   * @param [options.strict=true]    Throw if an invalid value is encountered, otherwise log a warning?
   * @param [options.fields=true]    Perform validation on individual fields?
   * @param [options.joint]          Perform joint validation on the full data model?
   *                                 Joint validation will be performed by default if no changes are passed.
   *                                 Joint validation will be disabled by default if changes are passed.
   *                                 Joint validation can be performed on a complete set of changes (for
   *                                 example testing a complete data model) by explicitly passing true.
   * @return An indicator for whether the document contains valid data
   */
  validate(options?: DataModelValidationOptions): boolean;

  /**
   * Get the explicit permission level that a User has over this Document, a value in CONST.DOCUMENT_OWNERSHIP_LEVELS.
   * This method returns the value recorded in Document ownership, regardless of the User's role.
   * To test whether a user has a certain capability over the document, testUserPermission should be used.
   * @param user The User being tested
   * @returns A numeric permission level from CONST.DOCUMENT_OWNERSHIP_LEVELS or null
   */
  getUserLevel(user: BaseUser): DocumentOwnershipLevel | null;

  /* -------------------------------------------- */
  /*  Database Operations                         */
  /* -------------------------------------------- */

  /**
   * Create multiple Documents using provided input data.
   * Data is provided as an array of objects where each individual object becomes one new Document.
   *
   * @param data An array of data objects used to create multiple documents
   * @param [context={}] Additional context which customizes the creation workflow
   * @return An array of created Document instances
   *
   * @example <caption>Create a single Document</caption>
   * const data = [{name: "New Actor", type: "character", img: "path/to/profile.jpg"}];
   * const created = await Actor.createDocuments(data);
   *
   * @example <caption>Create multiple Documents</caption>
   * const data = [{name: "Tim", type: "npc"], [{name: "Tom", type: "npc"}];
   * const created = await Actor.createDocuments(data);
   *
   * @example <caption>Create multiple embedded Documents within a parent</caption>
   * const actor = game.actors.getName("Tim");
   * const data = [{name: "Sword", type: "weapon"}, {name: "Breastplate", type: "equipment"}];
   * const created = await Item.createDocuments(data, {parent: actor});
   *
   * @example <caption>Create a Document within a Compendium pack</caption>
   * const data = [{name: "Compendium Actor", type: "character", img: "path/to/profile.jpg"}];
   * const created = await Actor.createDocuments(data, {pack: "mymodule.mypack"});
   */
  static createDocuments<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    data?: (TDocument | PreCreate<TDocument['_source']>)[],
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument[]>;

  /**
   * Update multiple Document instances using provided differential data.
   * Data is provided as an array of objects where each individual object updates one existing Document.
   *
   * @param updates An array of differential data objects, each used to update a single Document
   * @param [context={}] Additional context which customizes the update workflow
   * @return An array of updated Document instances
   *
   * @example <caption>Update a single Document</caption>
   * const updates = [{_id: "12ekjf43kj2312ds", name: "Timothy"}];
   * const updated = await Actor.updateDocuments(updates);
   *
   * @example <caption>Update multiple Documents</caption>
   * const updates = [{_id: "12ekjf43kj2312ds", name: "Timothy"}, {_id: "kj549dk48k34jk34", name: "Thomas"}]};
   * const updated = await Actor.updateDocuments(updates);
   *
   * @example <caption>Update multiple embedded Documents within a parent</caption>
   * const actor = game.actors.getName("Timothy");
   * const updates = [{_id: sword.id, name: "Magic Sword"}, {_id: shield.id, name: "Magic Shield"}];
   * const updated = await Item.updateDocuments(updates, {parent: actor});
   *
   * @example <caption>Update Documents within a Compendium pack</caption>
   * const actor = await pack.getDocument(documentId);
   * const updated = await Actor.updateDocuments([{_id: actor.id, name: "New Name"}], {pack: "mymodule.mypack"});
   */
  static updateDocuments<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    updates?: Record<string, unknown>[],
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument[]>;

  /**
   * Delete one or multiple existing Documents using an array of provided ids.
   * Data is provided as an array of string ids for the documents to delete.
   *
   * @param ids           An array of string ids for the documents to be deleted
   * @param [context={}] Additional context which customizes the deletion workflow
   * @return An array of deleted Document instances
   *
   * @example <caption>Delete a single Document</caption>
   * const tim = game.actors.getName("Tim");
   * const deleted = await Actor.deleteDocuments([tim.id]);
   *
   * @example <caption>Delete multiple Documents</caption>
   * const tim = game.actors.getName("Tim");
   * const tom = game.actors.getName("Tom");
   * const deleted = await Actor.deleteDocuments([tim.id, tom.id]);
   *
   * @example <caption>Delete multiple embedded Documents within a parent</caption>
   * const tim = game.actors.getName("Tim");
   * const sword = tim.items.getName("Sword");
   * const shield = tim.items.getName("Shield");
   * const deleted = await Item.deleteDocuments([sword.id, shield.id], parent: actor});
   *
   * @example <caption>Delete Documents within a Compendium pack</caption>
   * const actor = await pack.getDocument(documentId);
   * const deleted = await Actor.deleteDocuments([actor.id], {pack: "mymodule.mypack"});
   */
  static deleteDocuments<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    ids?: string[],
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument[]>;

  /**
   * Create a new Document using provided input data, saving it to the database.
   * @see {@link Document.createDocuments}
   * @param [data={}]    Initial data used to create this Document
   * @param [context={}] Additional context which customizes the creation workflow
   * @return The created Document instance
   *
   * @example <caption>Create a World-level Item</caption>
   * const data = [{name: "Special Sword", type: "weapon"}];
   * const created = await Item.create(data);
   *
   * @example <caption>Create an Actor-owned Item</caption>
   * const data = [{name: "Special Sword", type: "weapon"}];
   * const actor = game.actors.getName("My Hero");
   * const created = await Item.create(data, {parent: actor});
   *
   * @example <caption>Create an Item in a Compendium pack</caption>
   * const data = [{name: "Special Sword", type: "weapon"}];
   * const created = await Item.create(data, {pack: "mymodule.mypack"});
   */
  static create<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    data: PreCreate<TDocument['_source']>,
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument | undefined>;
  static create<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    data: PreCreate<TDocument['_source']>[],
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument[]>;
  static create<TDocument extends Document$1>(
    this: ConstructorOf<TDocument>,
    data: PreCreate<TDocument['_source']> | PreCreate<TDocument['_source']>[],
    context?: DocumentModificationContext<TDocument['parent']>,
  ): Promise<TDocument[] | TDocument | undefined>;

  /**
   * Update this Document using incremental data, saving it to the database.
   * @see {@link Document.updateDocuments}
   * @param [data={}]    Differential update data which modifies the existing values of this document data
   * @param [context={}] Additional context which customizes the update workflow
   * @returns The updated Document instance
   */
  update(data: Record<string, unknown>, context?: DocumentModificationContext<TParent>): Promise<this | undefined>;

  /**
   * Delete the current Document.
   * @see {Document.delete}
   * @param context Options which customize the deletion workflow
   * @return The deleted Document
   */
  delete(context?: DocumentModificationContext<TParent>): Promise<this | undefined>;

  /* -------------------------------------------- */
  /*  Embedded Operations                         */
  /* -------------------------------------------- */

  /**
   * A compatibility method that returns the appropriate name of an embedded collection within this Document.
   * @param name An existing collection name or a document name.
   * @returns The provided collection name if it exists, the first available collection for the
   *          document name provided, or null if no appropriate embedded collection could be found.
   * @example Passing an existing collection name.
   * ```js
   * Actor.getCollectionName("items");
   * // returns "items"
   * ```
   *
   * @example Passing a document name.
   * ```js
   * Actor.getCollectionName("Item");
   * // returns "items"
   * ```
   */
  static getCollectionName(name: string): string | null;

  /**
   * Obtain a reference to the Array of source data within the data object for a certain embedded Document name
   * @param embeddedName The name of the embedded Document type
   * @return The Collection instance of embedded Documents of the requested type
   */
  getEmbeddedCollection(embeddedName: string): EmbeddedCollection<Document$1<Document$1>>;

  /**
   * Get an embedded document by it's id from a named collection in the parent document.
   * @param embeddedName The name of the embedded Document type
   * @param id The id of the child document to retrieve
   * @param [options] Additional options which modify how embedded documents are retrieved
   * @param [options.strict=false] Throw an Error if the requested id does not exist. See Collection#get
   * @return The retrieved embedded Document instance, or undefined
   */
  getEmbeddedDocument(embeddedName: string, id: string, { strict }: { strict: true }): Document$1;
  getEmbeddedDocument(embeddedName: string, id: string, { strict }: { strict: false }): Document$1 | undefined;
  getEmbeddedDocument(embeddedName: string, id: string, { strict }?: { strict?: boolean }): Document$1 | undefined;

  /**
   * Create multiple embedded Document instances within this parent Document using provided input data.
   * @see {@link Document.createDocuments}
   * @param embeddedName The name of the embedded Document type
   * @param data An array of data objects used to create multiple documents
   * @param [context={}] Additional context which customizes the creation workflow
   * @return An array of created Document instances
   */
  createEmbeddedDocuments(
    embeddedName: string,
    data: object[],
    context?: DocumentModificationContext<this>,
  ): Promise<Document$1[]>;

  /**
                 * Update one or multiple existing entities using provided input data.
                 * Data may be provided as a single object to update one Document, or as an Array of Objects.
                 /**
                 * Update multiple embedded Document instances within a parent Document using provided differential data.
                 * @see {@link Document.updateDocuments}
                 * @param embeddedName               The name of the embedded Document type
                 * @param updates An array of differential data objects, each used to update a single Document
                 * @param [context={}] Additional context which customizes the update workflow
                 * @return An array of updated Document instances
                 */
  updateEmbeddedDocuments(
    embeddedName: string,
    updateData: EmbeddedDocumentUpdateData[],
    context?: DocumentUpdateContext<this>,
  ): Promise<Document$1[]>;

  /**
   * Delete multiple embedded Document instances within a parent Document using provided string ids.
   * @see {@link Document.deleteDocuments}
   * @param embeddedName               The name of the embedded Document type
   * @param ids                      An array of string ids for each Document to be deleted
   * @param [context={}] Additional context which customizes the deletion workflow
   * @return An array of deleted Document instances
   */
  deleteEmbeddedDocuments(
    embeddedName: string,
    dataId: string[],
    context?: DocumentModificationContext<this>,
  ): Promise<Document$1<this>[]>;

  /* -------------------------------------------- */
  /*  Flag Operations                             */
  /* -------------------------------------------- */

  /**
   * Get the value of a "flag" for this document
   * See the setFlag method for more details on flags
   *
   * @param scope The flag scope which namespaces the key
   * @param key   The flag key
   * @return The flag value
   */
  getFlag(scope: string, key: string): unknown;

  /**
   * Assign a "flag" to this document.
   * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
   * the core software, game systems, or user-created modules.
   *
   * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
   *
   * Flags set by the core software use the "core" scope.
   * Flags set by game systems or modules should use the canonical name attribute for the module
   * Flags set by an individual world should "world" as the scope.
   *
   * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
   *
   * @param scope The flag scope which namespaces the key
   * @param key The flag key
   * @param value The flag value
   * @return A Promise resolving to the updated document
   */
  setFlag(scope: string, key: string, value: unknown): Promise<this>;

  /**
   * Remove a flag assigned to the Document
   * @param scope The flag scope which namespaces the key
   * @param key   The flag key
   * @return A Promise resolving to the updated Document
   */
  unsetFlag(scope: string, key: string): Promise<this>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * Perform preliminary operations before a Document of this type is created.
   * Pre-creation operations only occur for the client which requested the operation.
   * Modifications to the pending document before it is persisted should be performed with this.updateSource().
   * @param data    The initial data object provided to the document creation request
   * @param options Additional options which modify the creation request
   * @param user    The User requesting the document creation
   * @returns A return value of false indicates the creation operation should be cancelled.
   */
  protected _preCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    user: BaseUser,
  ): Promise<boolean | void>;

  /**
   * Perform preliminary operations before a Document of this type is updated.
   * Pre-update operations only occur for the client which requested the operation.
   * @param changed The differential data that is changed relative to the documents prior values
   * @param options Additional options which modify the update request
   * @param user    The User requesting the document update
   * @returns A return value of false indicates the update operation should be cancelled.
   */
  protected _preUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    user: BaseUser,
  ): Promise<boolean | void>;

  /**
   * Perform preliminary operations before a Document of this type is deleted.
   * Pre-delete operations only occur for the client which requested the operation.
   * @param options Additional options which modify the deletion request
   * @param user    The User requesting the document deletion
   * @returns A return value of false indicates the deletion operation should be cancelled.
   */
  protected _preDelete(options: DocumentModificationContext<TParent>, user: BaseUser): Promise<boolean | void>;

  /**
   * Perform follow-up operations after a Document of this type is created.
   * Post-creation operations occur for all clients after the creation is broadcast.
   * @param data    The initial data object provided to the document creation request
   * @param options Additional options which modify the creation request
   */
  protected _onCreate(data: this['_source'], options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Perform follow-up operations after a Document of this type is updated.
   * Post-update operations occur for all clients after the update is broadcast.
   * @param changed The differential data that was changed relative to the documents prior values
   * @param options Additional options which modify the update request
   * @param userId  The ID of the User requesting the document update
   */
  protected _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * Perform follow-up operations after a Document of this type is deleted.
   * Post-deletion operations occur for all clients after the deletion is broadcast.
   * @param options Additional options which modify the deletion request
   * @param userId The ID of the User requesting the document deletion
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Perform follow-up operations when a set of Documents of this type are created.
   * This is where side effects of creation should be implemented.
   * Post-creation side effects are performed only for the client which requested the operation.
   * @param documents The Document instances which were created
   * @param context   The context for the modification operation
   */
  protected static _onCreateDocuments(
    documents: Document$1[],
    context: DocumentModificationContext<Document$1 | null>,
  ): void;

  /**
   * Perform follow-up operations when a set of Documents of this type are updated.
   * This is where side effects of updates should be implemented.
   * Post-update side effects are performed only for the client which requested the operation.
   * @param documents The Document instances which were updated
   * @param context   The context for the modification operation
   */
  protected static _onUpdateDocuments(
    documents: Document$1[],
    context: DocumentModificationContext<Document$1 | null>,
  ): void;

  /**
   * Perform follow-up operations when a set of Documents of this type are deleted.
   * This is where side effects of deletion should be implemented.
   * Post-deletion side effects are performed only for the client which requested the operation.
   * @param documents The Document instances which were deleted
   * @param context   The context for the modification operation
   */
  protected static _onDeleteDocuments(
    documents: Document$1[],
    context: DocumentModificationContext<Document$1 | null>,
  ): void;

  /* ---------------------------------------- */
  /*  Serialization and Storage               */
  /* ---------------------------------------- */

  /**
   * Transform the Document instance into a plain object.
   * The created object is an independent copy of the original data.
   * See DocumentData#toObject
   * @param [source=true] Draw values from the underlying data source rather than transformed values
   * @returns The extracted primitive object
   */
  toObject(source?: true): this['_source'];
  toObject(source: false): RawObject<this>;
  toObject(source?: boolean): this['_source'] | RawObject<this>;

  /**
   * Serializing an Document should simply serialize its inner data, not the entire instance
   */
  toJSON(): RawObject<this>;
}

type MetadataPermission = keyof typeof USER_ROLES | keyof typeof USER_PERMISSIONS | ((...args: unknown[]) => boolean);

interface DocumentMetadata {
  name: string;
  collection: string;
  indexed: boolean;
  compendiumIndexFields: string[];
  label: string;
  coreTypes: string[] | number[];
  embedded: Record<string, string>;
  permissions: {
    create: MetadataPermission;
    update: MetadataPermission;
    delete: MetadataPermission;
  };
  preserveOnImport: string[];
}

type _Document = Document$1<_Document | null>;

declare global {
  type PreCreate<T extends SourceFromSchema<DataSchema>> = T extends { name: string; type: string }
    ? Omit<DeepPartial<T>, '_id' | 'name' | 'type'> & { _id?: Maybe<string>; name: string; type: T['type'] }
    : DeepPartial<T>;

  type EmbeddedDocumentUpdateData = {
    _id: string;
    [key: string]: unknown;
  };

  interface DocumentRenderOptions extends RenderOptions {
    data?: {
      permission?: boolean;
    };
  }

  type DocumentFlags = Record<string, Record<string, unknown> | undefined>;

  interface DocumentCloneContext extends Omit<DocumentConstructionContext<null>, 'parent'> {
    save?: boolean;
    keepId?: boolean;
  }

  interface DocumentSourceUpdateContext extends Omit<DocumentModificationContext<null>, 'parent'> {
    dryRun?: boolean;
    fallback?: boolean;
  }
}

/**
 * An interface shared by both the client and server-side which defines how creation, update, and deletion operations are transacted.
 */
declare abstract class DatabaseBackend {
  /* -------------------------------------------- */
  /*  Get Operations                              */
  /* -------------------------------------------- */

  /**
   * Retrieve Documents based on provided query parameters
   * @param documentClass   The Document definition
   * @param context         Context for the requested operation
   * @param [user]          The requesting User
   * @returns               The created Document instances
   */
  get(
    documentClass: typeof Document$1,
    context: Partial<DatabaseBackendGetContext>,
    user?: BaseUser,
  ): Promise<Document$1[]>;

  /** Get primary Document instances */
  protected abstract _getDocuments(
    documentClass: typeof Document$1,
    request: DatabaseBackendGetContext,
    user: BaseUser,
  ): Promise<CompendiumIndexData[] | Document$1[]>;

  /* -------------------------------------------- */
  /*  Create Operations                           */
  /* -------------------------------------------- */

  /**
   * Perform document creation operations
   * @param documentClass    The Document definition
   * @param context          Context for the requested operation
   * @param [user]           The requesting User
   * @returns                The created Document instances
   */
  create(
    documentClass: typeof Document$1,
    context: DatabaseBackendCreateContext<Document$1>,
    user?: BaseUser,
  ): Promise<Document$1[]>;

  /** Create primary Document instances */
  protected abstract _createDocuments(
    documentClass: typeof Document$1,
    context: DatabaseBackendCreateContext<Document$1>,
    user: BaseUser,
  ): Promise<Document$1[]>;

  /* -------------------------------------------- */
  /*  Update Operations                           */
  /* -------------------------------------------- */

  /**
   * Perform document update operations
   * @param documentClass    The Document definition
   * @param context          Context for the requested operation
   * @param [user]           The requesting User
   * @returns                The updated Document instances
   */
  update(
    documentClass: typeof Document$1,
    context: DatabaseBackendUpdateContext<Document$1>,
    user?: User,
  ): Promise<Document$1[]>;

  /** Update primary Document instances */
  protected abstract _updateDocuments(
    documentClass: typeof Document$1,
    context: DatabaseBackendUpdateContext<Document$1>,
    user: BaseUser,
  ): Promise<Document$1[]>;

  /* -------------------------------------------- */
  /*  Delete Operations                           */
  /* -------------------------------------------- */

  /**
   * Perform document deletion operations
   * @param documentClass   The Document definition
   * @param context         Context for the requested operation
   * @param [user]          The requesting User
   * @returns               The deleted Document instances
   */
  delete(
    documentClass: ConstructorOf<Document$1>,
    context: DatabaseBackendDeleteContext,
    user: BaseUser,
  ): Promise<Document$1>;

  /** Delete primary Document instances */
  protected abstract _deleteDocuments(
    documentClass: typeof Document$1,
    context: DatabaseBackendDeleteContext,
    user: BaseUser,
  ): Promise<Document$1[]>;

  /* -------------------------------------------- */
  /*  Helper Methods                              */
  /* -------------------------------------------- */

  /** Describe the scopes which are suitable as the namespace for a flag key */
  abstract getFlagScopes(): string[];

  /** Describe the scopes which are suitable as the namespace for a flag key */
  abstract getCompendiumScopes(): string[];

  /** Provide the Logger implementation that should be used for database operations */
  protected _getLogger(): Console;

  /**
   * Log a database operation for an embedded document, capturing the action taken and relevant IDs
   * @param action                 The action performed
   * @param type                   The document type
   * @param documents              The documents modified
   * @param [options]
   * @param [options.level=info]   The logging level
   * @param [options.parent]       A parent document
   * @param [options.pack]         A compendium pack within which the operation occurred
   */
  protected _logOperation(
    action: string,
    type: string,
    documents: foundry.abstract.Document[],
    options?: { level?: string; parent?: foundry.abstract.Document; pack: string },
  ): void;

  /** Construct a standardized error message given the context of an attempted operation */
  protected _logError(
    user: User,
    action: string,
    subject: string,
    options?: { parent: foundry.abstract.Document; pack?: string },
  ): string;
}

declare global {
  interface DatabaseBackendBaseContext {
    query?: Record<string, unknown>;
    options?: object;
    pack?: string;
  }

  interface DatabaseBackendGetContext extends DatabaseBackendBaseContext {
    options?: {
      broadcast?: boolean;
      index?: boolean;
      indexFields?: string[];
    };
  }

  interface DatabaseBackendCreateContext<TDocument extends foundry.abstract.Document>
    extends DatabaseBackendBaseContext {
    data?: DeepPartial<TDocument['_source']>[];
    options?: {
      temporary?: boolean;
      renderSheet?: boolean;
      render?: boolean;
      noHook?: boolean;
    };
  }

  interface DatabaseBackendUpdateContext<TDocument extends foundry.abstract.Document>
    extends DatabaseBackendBaseContext {
    updates?: DeepPartial<TDocument['_source']>[];
    options?: {
      diff?: boolean;
      render?: boolean;
    };
  }

  interface DatabaseBackendDeleteContext extends DatabaseBackendBaseContext {
    ids?: string[];
    options?: {
      render?: boolean;
    };
  }
}

/**
 * A special `ObjectField` available to packages which configures any additional Document sub-types
 * provided by the package.
 */
declare class AdditionalTypesField extends ObjectField<object, object, false, false, true> {
  static get _defaults(): ObjectFieldOptions<object, false, false, true>;

  protected override _validateType(value: unknown, options?: Record<string, unknown>): void;
}

/**
 * The data schema used to define Module manifest files.
 * Extends the basic PackageData schema with some additional module-specific fields.
 * @property [coreTranslation] Does this module provide a translation for the core software?
 * @property [library]         A library module provides no user-facing functionality and is solely
 *                             for use by other modules. Loaded before any system or module scripts.
 * @property [documentTypes] Additional document sub-types provided by this module.
 */
declare class BaseModule extends BasePackage<ModuleSchema> {
  static override defineSchema(): ModuleSchema;

  static override type: 'module';

  /** The default icon used for this type of Package. */
  static icon: string;
}

interface BaseModule extends BasePackage<ModuleSchema>, ModelPropsFromSchema<ModuleSchema> {}

type ModuleSchema = BasePackageSchema & {
  coreTranslation: BooleanField;
  library: BooleanField;
  documentTypes: AdditionalTypesField;
};

/** A custom SchemaField for defining package compatibility versions. */
declare class PackageCompatibility extends SchemaField<PackageCompatibilitySchema> {
  constructor(options: DataFieldOptions<SourceFromSchema<PackageCompatibilitySchema>, true, false, true>);
}

type PackageCompatibilitySchema = {
  /** The Package will not function before this version */
  minimum: StringField<string, string, false, false, false>;
  /** Verified compatible up to this version */
  verified: StringField<string, string, false, false, false>;
  /** The Package will not function after this version */
  maximum: StringField<string, string, false, false, false>;
};

/** A custom SchemaField for defining package relationships. */
declare class PackageRelationships extends SchemaField<PackageRelationshipsSchema> {
  constructor(options?: DataFieldOptions<SourceFromSchema<PackageRelationshipsSchema>, true, false, true>);
}

type PackageRelationshipsSchema = {
  /** Systems that this Package supports */
  systems: SetField<RelatedPackage>;
  /** Packages that are required for base functionality */
  requires: SetField<RelatedPackage>;
  /** Packages that are recommended for optimal functionality */
  recommends: SetField<RelatedPackage>;
  conflicts: SetField<RelatedPackage>;
  flags: ObjectField<DocumentFlags>;
};

/**
 * A custom SchemaField for defining a related Package.
 * It may be required to be a specific type of package, by passing the packageType option to the constructor.
 */
declare class RelatedPackage extends SchemaField<RelatedPackageSchema> {
  constructor(options?: DataFieldOptions<SourceFromSchema<RelatedPackageSchema>, true, false, true>);
}

type RelatedPackageSchema = {
  id: StringField<string, string, true, false, false>;
  type: StringField<PackageType>;
  manifest: StringField<string, string, false, false, false>;
  compatibility: PackageCompatibility;
  reason: StringField<string, string, false, false, false>;
};

/** A custom SchemaField for defining the folder structure of the included compendium packs. */
declare class PackageCompendiumFolder extends SchemaField<PackageCompendiumFolderSchema> {
  constructor(options?: DataFieldOptions<PackageCompendiumFolderSchema, true, false, true>);
}

type PackageCompendiumFolderSchema = {
  name: StringField<string, string, true, false, false>;
  sorting: StringField<'a' | 'm'>;
  color: ColorField;
  packs: SetField<StringField<string, string, true, false, false>>;
};

/** A special ObjectField which captures a mapping of USER_ROLES to DOCUMENT_OWNERSHIP_LEVELS. */
declare class CompendiumOwnershipField extends ObjectField<Record<UserRole, DocumentOwnershipLevel>> {
  static override get _defaults(): ObjectFieldOptions<
    Record<UserRole, DocumentOwnershipLevel>,
    boolean,
    boolean,
    boolean
  >;

  protected override _validateType(value: unknown, options?: Record<string, unknown>): void;
}

/** A special SetField which provides additional validation and initialization behavior specific to compendium packs. */
declare class PackageCompendiumPacks<TSchema extends PackageCompendiumSchema> extends SetField<SchemaField<TSchema>> {
  protected override _cleanType(value: Record<string, unknown>[], options?: Record<string, unknown>): void;

  override initialize(
    value: SourceFromSchema<TSchema>[],
    model: ConstructorOf<DataModel>,
    options?: Record<string, unknown>,
  ): Set<ModelPropsFromSchema<TSchema>>;

  /** Extend the logic for validating the complete set of packs to ensure uniqueness. */
  protected override _validateElements(value: unknown[], options?: Record<string, unknown>): void;

  /** Validate each individual compendium pack, ensuring its name and path are unique. */
  protected _validateElement(value: unknown, options?: Record<string, unknown>): void;
}

/**
 * The data schema used to define a Package manifest.
 * Specific types of packages extend this schema with additional fields.
 */
declare abstract class BasePackage<TDataSchema extends BasePackageSchema> extends DataModel<null, TDataSchema> {
  /** An availability code in PACKAGE_AVAILABILITY_CODES which defines whether this package can be used. */
  availability: PackageAvailabilityCode;

  /** A flag which tracks whether this package is currently locked. */
  locked: boolean;

  /** A flag which tracks whether this package is a free Exclusive pack */
  exclusive: boolean;

  /** A flag which tracks whether this package is owned, if it is protected. */
  owned: boolean | null;

  /** A set of Tags that indicate what kind of Package this is, provided by the Website */
  tags: string[];

  /** A flag which tracks if this package has files stored in the persistent storage folder */
  hasStorage: boolean;

  /**
   * @param data         Source data for the package
   * @param [options={}] Options which affect DataModel construction
   */
  constructor(data: PackageManifestData, options?: DataModelConstructionOptions<null>);

  /**
   * Define the package type in CONST.PACKAGE_TYPES that this class represents.
   * Each BasePackage subclass must define this attribute.
   */
  static type: PackageType;

  /** The type of this package instance. A value in CONST.PACKAGE_TYPES. */
  get type(): PackageType;

  /** A flag which defines whether this package is unavailable to be used. */
  get unavailable(): boolean;

  /** Is this Package incompatible with the currently installed core Foundry VTT software version? */
  get incompatibleWithCoreVersion(): boolean;

  /**
   * Test if a given availability is incompatible with the core version.
   * @param availability The availability value to test.
   */
  static isIncompatibleWithCoreVersion(availability: PackageAvailabilityCode): boolean;

  /** The named collection to which this package type belongs */
  static get collection(): string;

  static override defineSchema(): BasePackageSchema;

  /**
   * Check the given compatibility data against the current installation state and determine its availability.
   * @param data      The compatibility data to test.
   * @param [release] A specific software release for which to test availability.
   *                  Tests against the current release by default.
   */
  static testAvailability(data?: Partial<PackageManifestData>, release?: ReleaseData): PackageAvailabilityCode;

  /**
   *
   * @param compatibility The compatibility range declared for the dependency, if any
   * @param dependency    The known dependency package
   * @returns Is the dependency compatible with the required range?
   */
  static testDependencyCompatibility(
    compatibility: PackageCompatibility,
    dependency: BasePackage<BasePackageSchema>,
  ): boolean;

  static override cleanData(
    source?: Record<string, unknown>,
    options?: Record<string, unknown>,
  ): SourceFromSchema<BasePackageSchema>;

  /**
   * Validate that a Package ID is allowed.
   * @param id The candidate ID
   * @throws An error if the candidate ID is invalid
   */
  static validateId(id: string): void;

  static override migrateData(source: Record<string, unknown>): SourceFromSchema<DataSchema>;

  /**
   * Retrieve the latest Package manifest from a provided remote location.
   * @param manifestUrl A remote manifest URL to load
   * @param options     Additional options which affect package construction
   * @param [options.strict=true]   Whether to construct the remote package strictly
   * @return A Promise which resolves to a constructed ServerPackage instance
   * @throws An error if the retrieved manifest data is invalid
   */
  static fromRemoteManifest<T extends BasePackage<BasePackageSchema>>(
    this: ConstructorOf<T>,
    manifestUrl: string,
    options?: { strict?: boolean },
  ): Promise<T | null>;
}

interface BasePackage<TDataSchema extends BasePackageSchema>
  extends DataModel<null, TDataSchema>,
    ModelPropsFromSchema<BasePackageSchema> {}

/**
 * The data structure of a package manifest. This data structure is extended by BasePackage subclasses to add additional
 * type-specific fields.
 */
type BasePackageSchema = {
  /** The machine-readable unique package id, should be lower-case with no spaces or special characters */
  id: StringField<string, string, true, false, false>;
  /** The human-readable package title, containing spaces and special characters */
  title: StringField<string, string, true, false, false>;
  /** An optional package description, may contain HTML */
  description: StringField<string, string, true, false, true>;
  /** An array of author objects who are co-authors of this package. Preferred to the singular author field. */
  authors: SetField<SchemaField<PackageAuthorSchema>>;
  /** A web url where more details about the package may be found */
  url: StringField<string, string, false, false, false>;
  /** A web url or relative file path where license details may be found */
  license: StringField<string, string, false, false, false>;
  /** A web url or relative file path where readme instructions may be found */
  readme: StringField<string, string, false, false, false>;
  /** A web url where bug reports may be submitted and tracked */
  bugs: StringField<string, string, false, false, false>;
  /** A web url where notes detailing package updates are available */
  changelog: StringField<string, string, false, false, false>;
  flags: ObjectField<DocumentFlags>;
  media: SetField<
    SchemaField<{
      type: StringField<string, string, false, false, false>;
      url: StringField<string, string, false, false, false>;
      caption: StringField<string, string, false, false, false>;
      loop: BooleanField;
      thumbnail: StringField<string, string, false, false, false>;
      flags: ObjectField<DocumentFlags>;
    }>
  >;

  /** The current package version */
  version: StringField<string, string, true, boolean, true>;
  /** The compatibility of this version with the core Foundry software */
  compatibility: PackageCompatibility;
  /** An array of urls or relative file paths for JavaScript files which should be included */
  scripts: SetField<StringField<string, string, true, false, false>>;
  /** An array of urls or relative file paths for ESModule files which should be included */
  esmodules: SetField<StringField<string, string, true, false, false>>;
  /** An array of urls or relative file paths for CSS stylesheet files which should be included */
  styles: SetField<StringField<string, string, true, false, false>>;
  /** An array of language data objects which are included by this package */
  languages: SetField<SchemaField<PackageLanguageSchema>>;
  /** An array of compendium packs which are included by this package */
  packs: PackageCompendiumPacks<PackageCompendiumSchema>;
  packFolders: SetField<PackageCompendiumFolder>;
  /** An organized object of relationships to other Packages */
  relationships: PackageRelationships;
  /** Whether to require a package-specific socket namespace for this package */
  socket: BooleanField;
  /** A publicly accessible web URL which provides the latest available package manifest file. Required in order to support module updates. */
  manifest: StringField;
  /** A publicly accessible web URL where the source files for this package may be downloaded. Required in order to support module installation. */
  download: StringField<string, string, false, false, false>;
  /** Whether this package uses the protected content access system. */
  protected: BooleanField;
  exclusive: BooleanField;
  persistentStorage: BooleanField;
};

type PackageAuthorSchema = {
  /** The author name */
  name: StringField<string, string, true, false, false>;
  /** The author email address */
  email: StringField<string, string, false, false, false>;
  /** A website url for the author */
  url: StringField<string, string, false, false, false>;
  /** A Discord username for the author */
  discord: StringField<string, string, false, false, false>;
  flags: ObjectField<DocumentFlags>;
};
type PackageAuthorData = ModelPropsFromSchema<PackageAuthorSchema>;

type PackageCompendiumSchema = {
  /** The canonical compendium name. This should contain no spaces or special characters */
  name: StringField<string, string, true, false, false>;
  /** The human-readable compendium name */
  label: StringField<string, string, true, false, false>;
  banner: StringField<string, string, false, false, false>;
  /** The local relative path to the compendium source directory. The filename should match the name attribute */
  path: StringField<string, string, false, false, true>;
  /** The specific document type that is contained within this compendium pack */
  type: StringField<CompendiumDocumentType, CompendiumDocumentType, true, false, false>;
  /** Denote that this compendium pack requires a specific game system to function properly */
  system: StringField<string, string, false, false, false>;
  ownership: CompendiumOwnershipField;
  flags: ObjectField<DocumentFlags>;
};
type PackageCompendiumData = ModelPropsFromSchema<PackageCompendiumSchema>;

type PackageLanguageSchema = {
  /** A string language code which is validated by Intl.getCanonicalLocales */
  lang: StringField<string, string, true, false, false>;
  /** The human-readable language name */
  name: StringField<string, string, false, false, true>;
  /** The relative path to included JSON translation strings */
  path: StringField<string, string, true, false, false>;
  /** Only apply this set of translations when a specific system is being used */
  system: StringField<string, string, false, false, false>;
  /** Only apply this set of translations when a specific module is active */
  module: StringField<string, string, false, false, false>;
  flags: ObjectField<DocumentFlags>;
};
type PackageLanguageData = ModelPropsFromSchema<PackageLanguageSchema>;
type PackageManifestData = SourceFromSchema<BasePackageSchema>;
type ReleaseData = object;

/**
 * The data schema used to define System manifest files.
 * Extends the basic PackageData schema with some additional system-specific fields.
 * @property {string} [background]        A web URL or local file path which provides a default background banner for
 *                                        worlds which are created using this system
 * @property {string} [initiative]        A default initiative formula used for this system
 * @property {number} [gridDistance]      A default distance measurement to use for Scenes in this system
 * @property {string} [gridUnits]         A default unit of measure to use for distance measurement in this system
 * @property {string} [primaryTokenAttribute] An Actor data attribute path to use for Token primary resource bars
 * @property {string} [primaryTokenAttribute] An Actor data attribute path to use for Token secondary resource bars
 */
declare class BaseSystem extends BasePackage<BaseSystemSchema> {
  static override type: 'system';

  /** The default icon used for this type of Package. */
  static icon: string;

  /** An alias for the document types available in the currently active World. */
  get documentTypes(): Record<string, string[]>;

  /** An alias for the raw template JSON loaded from the game System. */
  get template(): object;

  /** An alias for the structured data model organized by document class and type. */
  get model(): Record<'Actor' | 'Card' | 'Cards' | 'Item' | 'JournalEntryPage', object>;
}

interface BaseSystem extends BasePackage<BaseSystemSchema>, ModelPropsFromSchema<BaseSystemSchema> {
  version: string;
}

type BaseSystemSchema = BasePackageSchema & {
  background: StringField<string, string, false, false, false>;
  initiative: StringField;
  gridDistance: NumberField;
  gridUnits: StringField;
  primaryTokenAttribute: StringField;
  secondaryTokenAttribute: StringField;
};

declare class BaseWorld extends BasePackage<WorldSchema> {
  static override defineSchema(): WorldSchema;

  static override type: 'world';

  /** The default icon used for this type of Package. */
  static icon: string;

  static override migrateData(data: Record<string, unknown>): SourceFromSchema<WorldSchema>;

  static testAvailability(data?: Partial<PackageManifestData>, release?: ReleaseData): PackageAvailabilityCode;
}

interface BaseWorld extends BasePackage<WorldSchema>, ModelPropsFromSchema<WorldSchema> {}

/**
 * The data schema used to define World manifest files.
 * Extends the basic PackageData schema with some additional world-specific fields.
 */
type WorldSchema = Omit<BasePackageSchema, 'version'> & {
  /** The game system name which this world relies upon */
  system: StringField<string, string, true, false, false>;
  /** A web URL or local file path which provides a background banner image */
  background: StringField<string, string, false, false, false>;
  /** The theme to use for this world's join page. */
  joinTheme: StringField<string, string, false, false, false>;
  /** The version of the core software for which this world has been migrated */
  coreVersion: StringField<string, string, true, false, false>;
  /** The version of the game system for which this world has been migrated */
  systemVersion: StringField<string, string, true>;
  lastPlayed: StringField;
  playtime: NumberField;
  /** An ISO datetime string when the next game session is scheduled to occur */
  nextSession: StringField<string, string, false, true, true>;
  /** Should user access keys be reset as part of the next launch? */
  resetKeys: BooleanField<boolean, boolean, false, false, false>;
  /** Should the world launch in safe mode? */
  safeMode: BooleanField<boolean, boolean, false, false, false>;
  version: StringField<string, string, true, true, true>;
};

type Packages_AdditionalTypesField = AdditionalTypesField;
declare const Packages_AdditionalTypesField: typeof AdditionalTypesField;
type Packages_BaseModule = BaseModule;
type Packages_BasePackage<TDataSchema extends BasePackageSchema> = BasePackage<TDataSchema>;
type Packages_BasePackageSchema = BasePackageSchema;
type Packages_BaseSystem = BaseSystem;
type Packages_BaseWorld = BaseWorld;
type Packages_CompendiumOwnershipField = CompendiumOwnershipField;
declare const Packages_CompendiumOwnershipField: typeof CompendiumOwnershipField;
type Packages_PackageAuthorData = PackageAuthorData;
type Packages_PackageAuthorSchema = PackageAuthorSchema;
type Packages_PackageCompatibility = PackageCompatibility;
declare const Packages_PackageCompatibility: typeof PackageCompatibility;
type Packages_PackageCompatibilitySchema = PackageCompatibilitySchema;
type Packages_PackageCompendiumData = PackageCompendiumData;
type Packages_PackageCompendiumFolder = PackageCompendiumFolder;
declare const Packages_PackageCompendiumFolder: typeof PackageCompendiumFolder;
type Packages_PackageCompendiumFolderSchema = PackageCompendiumFolderSchema;
type Packages_PackageCompendiumPacks<TSchema extends PackageCompendiumSchema> = PackageCompendiumPacks<TSchema>;
declare const Packages_PackageCompendiumPacks: typeof PackageCompendiumPacks;
type Packages_PackageCompendiumSchema = PackageCompendiumSchema;
type Packages_PackageLanguageData = PackageLanguageData;
type Packages_PackageLanguageSchema = PackageLanguageSchema;
type Packages_PackageManifestData = PackageManifestData;
type Packages_PackageRelationships = PackageRelationships;
declare const Packages_PackageRelationships: typeof PackageRelationships;
type Packages_PackageRelationshipsSchema = PackageRelationshipsSchema;
type Packages_RelatedPackage = RelatedPackage;
declare const Packages_RelatedPackage: typeof RelatedPackage;
type Packages_RelatedPackageSchema = RelatedPackageSchema;
type Packages_ReleaseData = ReleaseData;
declare namespace Packages {
  export {
    Packages_AdditionalTypesField as AdditionalTypesField,
    type Packages_BaseModule as BaseModule,
    type Packages_BasePackage as BasePackage,
    type Packages_BasePackageSchema as BasePackageSchema,
    type Packages_BaseSystem as BaseSystem,
    type Packages_BaseWorld as BaseWorld,
    Packages_CompendiumOwnershipField as CompendiumOwnershipField,
    type Packages_PackageAuthorData as PackageAuthorData,
    type Packages_PackageAuthorSchema as PackageAuthorSchema,
    Packages_PackageCompatibility as PackageCompatibility,
    type Packages_PackageCompatibilitySchema as PackageCompatibilitySchema,
    type Packages_PackageCompendiumData as PackageCompendiumData,
    Packages_PackageCompendiumFolder as PackageCompendiumFolder,
    type Packages_PackageCompendiumFolderSchema as PackageCompendiumFolderSchema,
    Packages_PackageCompendiumPacks as PackageCompendiumPacks,
    type Packages_PackageCompendiumSchema as PackageCompendiumSchema,
    type Packages_PackageLanguageData as PackageLanguageData,
    type Packages_PackageLanguageSchema as PackageLanguageSchema,
    type Packages_PackageManifestData as PackageManifestData,
    Packages_PackageRelationships as PackageRelationships,
    type Packages_PackageRelationshipsSchema as PackageRelationshipsSchema,
    Packages_RelatedPackage as RelatedPackage,
    type Packages_RelatedPackageSchema as RelatedPackageSchema,
    type Packages_ReleaseData as ReleaseData,
  };
}

/**
 * A specialized subclass of DataModel, intended to represent a Document's type-specific data.
 * Systems or Modules that provide DataModel implementations for sub-types of Documents (such as Actors or Items)
 * should subclass this class instead of the base DataModel class.
 *
 * @see {@link Document}
 * @extends {DataModel}
 * @abstract
 *
 * @example Registering a custom sub-type for a Module.
 *
 * **module.json**
 * ```json
 * {
 *   "id": "my-module",
 *   "esmodules": ["main.mjs"],
 *   "documentTypes": {
 *     "Actor": {
 *       "sidekick": {},
 *       "villain": {}
 *     },
 *     "JournalEntryPage": {
 *       "dossier": {},
 *       "quest": {
 *         "htmlFields": ["description"]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * **main.mjs**
 * ```js
 * Hooks.on("init", () => {
 *   Object.assign(CONFIG.Actor.dataModels, {
 *     "my-module.sidekick": SidekickModel,
 *     "my-module.villain": VillainModel
 *   });
 *   Object.assign(CONFIG.JournalEntryPage.dataModels, {
 *     "my-module.dossier": DossierModel,
 *     "my-module.quest": QuestModel
 *   });
 * });
 *
 * class QuestModel extends foundry.abstract.TypeDataModel {
 *   static defineSchema() {
 *     const fields = foundry.data.fields;
 *     return {
 *       description: new fields.HTMLField({required: false, blank: true, initial: ""}),
 *       steps: new fields.ArrayField(new fields.StringField())
 *     };
 *   }
 *
 *   prepareDerivedData() {
 *     this.totalSteps = this.steps.length;
 *   }
 * }
 * ```
 */
declare class TypeDataModel extends DataModel {
  /** The package that is providing this DataModel for the given sub-type. */
  readonly modelProvider: BaseSystem | BaseModule | null;

  constructor(data?: object, options?: DataModelConstructionOptions<Document$1 | null>);

  /** Prepare data related to this DataModel itself, before any derived data is computed. */
  prepareBaseData(): void;

  /**
   * Apply transformations of derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;
}

type Abstract_DataModel<
  TParent extends DataModel | null = _DataModel | null,
  TSchema extends DataSchema = DataSchema,
> = DataModel<TParent, TSchema>;
declare const Abstract_DataModel: typeof DataModel;
type Abstract_DatabaseBackend = DatabaseBackend;
declare const Abstract_DatabaseBackend: typeof DatabaseBackend;
type Abstract_DocumentMetadata = DocumentMetadata;
type Abstract_EmbeddedCollection<TDocument extends Document$1<Document$1>> = EmbeddedCollection<TDocument>;
declare const Abstract_EmbeddedCollection: typeof EmbeddedCollection;
type Abstract_MetadataPermission = MetadataPermission;
type Abstract_TypeDataModel = TypeDataModel;
declare const Abstract_TypeDataModel: typeof TypeDataModel;
declare namespace Abstract {
  export {
    Abstract_DataModel as DataModel,
    Abstract_DatabaseBackend as DatabaseBackend,
    Document$1 as Document,
    type Abstract_DocumentMetadata as DocumentMetadata,
    Abstract_EmbeddedCollection as EmbeddedCollection,
    type Abstract_MetadataPermission as MetadataPermission,
    Abstract_TypeDataModel as TypeDataModel,
  };
}

/** The JournalEntryPage document model. */
declare class BaseJournalEntryPage<TParent extends BaseJournalEntry | null> extends Document$1<
  TParent,
  JournalEntryPageSchema
> {
  static override get metadata(): JournalEntryPageMetadata;

  static override defineSchema(): JournalEntryPageSchema;

  override getUserLevel(user: BaseUser): DocumentOwnershipLevel | null;
}

interface BaseJournalEntryPage<TParent extends BaseJournalEntry | null>
  extends Document$1<TParent, JournalEntryPageSchema>,
    ModelPropsFromSchema<JournalEntryPageSchema> {
  get documentName(): (typeof BaseJournalEntryPage)['metadata']['name'];
}

interface JournalEntryPageMetadata extends DocumentMetadata {
  name: 'JournalEntryPage';
  collection: 'pages';
  indexed: true;
  label: 'DOCUMENT.JournalEntryPage';
  labelPlural: 'DOCUMENT.JournalEntryPages';
  coreTypes: ['image', 'pdf', 'text', 'video'];
}

type JournalEntryPageSchema<
  TType extends string = string,
  TSystemSource extends object = object,
  TSystemData extends object = TSystemSource,
> = {
  _id: DocumentIdField;
  /** The text name of this page. */
  name: StringField<string, string, true, false, false>;
  /** The type of this page, in {@link BaseJournalEntryPage.TYPES}. */
  type: StringField<TType, TType, true, false, true>;
  /** Data that control's the display of this page's title. */
  title: SchemaField<{
    show: BooleanField;
    level: NumberField<number, number, true, false, true>;
  }>;
  /** Data particular to image journal entry pages. */
  image: SchemaField<{
    caption: StringField<string, string, false, false, false>;
  }>;
  /** Data particular to text journal entry pages. */
  text: SchemaField<{
    content: HTMLField<string, string, false, false, false>;
    markdown: StringField<string, string, false, false, false>;
    format: NumberField<JournalEntryPageFormat>;
  }>;
  /** Data particular to video journal entry pages. */
  video: SchemaField<{
    controls: BooleanField;
    loop: BooleanField<boolean, boolean, false, false, false>;
    autoplay: BooleanField<boolean, boolean, false, false, false>;
    volume: AlphaField<true, false, true>;
    timestamp: NumberField<number, number, false, false, false>;
    width: NumberField<number, number, true, false, false>;
    height: NumberField<number, number, false, false, false>;
  }>;
  /** The URI of the image or other external media to be used for this page. */
  src: StringField<string, string, false, true, true>;
  /** System-specific data. */
  system: TypeDataField<TSystemSource, TSystemData>;
  /** The numeric sort value which orders this page relative to its siblings. */
  sort: IntegerSortField;
  /** An object which configures the ownership of this page. */
  ownership: DocumentOwnershipField;
  /** An object of optional key/value flags. */
  flags: ObjectField<DocumentFlags>;
  _stats: DocumentStatsField;
};

type JournalEntryPageSource = SourceFromSchema<JournalEntryPageSchema>;

declare global {
  /**
   * The Application responsible for displaying and editing a single JournalEntry document.
   * @param object The JournalEntry instance which is being edited
   * @param [options] Application options
   */
  class JournalSheet<TJournalEntry extends JournalEntry> extends DocumentSheet<TJournalEntry> {
    static override get defaultOptions(): DocumentSheetOptions;

    /**
     * The cached list of processed page entries.
     * This array is populated in the getData method.
     */
    protected _pages: JournalEntryPage<TJournalEntry>['_source'][];

    /**
     * Get the journal entry's current view mode.
     * @see {@link JournalSheet.VIEW_MODES}
     * @returns {number}
     */
    get mode(): JournalSheetViewMode;

    /** The current search mode for this journal */
    get searchMode(): DirectorySearchMode;

    /** Toggle the search mode for this journal between "name" and "full" text search */
    toggleSearchMode(): void;

    /** The pages that are currently scrolled into view and marked as 'active' in the sidebar. */
    get pagesInView(): HTMLElement[];

    /** The index of the currently viewed page. */
    get pageIndex(): number;

    /** The currently active IntersectionObserver. */
    get observer(): IntersectionObserver;

    /** Is the table-of-contents sidebar currently collapsed? */
    get sidebarCollapsed(): boolean;

    /** Available view modes for journal entries. */
    static VIEW_MODES: { SINGLE: 1; MULTIPLE: 2 };

    /**
     * The minimum amount of content that must be visible before the next page is marked as in view. Cannot be less than
     * 25% without also modifying the IntersectionObserver threshold.
     */
    static INTERSECTION_RATIO: number;

    /** Icons for page ownership. */
    static OWNERSHIP_ICONS: Record<DocumentOwnershipLevel, string | undefined>;

    get title(): string;

    protected override _getHeaderButtons(): ApplicationHeaderButton[];

    override getData(
      options?: Partial<DocumentSheetOptions>,
    ): JournalSheetData<TJournalEntry> | Promise<JournalSheetData<TJournalEntry>>;

    override get template(): string;

    /** Guess the default view mode for the sheet based on the player's permissions to the Entry */
    protected _inferDefaultMode(): string;

    protected override _render(force?: boolean, options?: JournalSheetRenderOptions): Promise<void>;

    protected override _getHeaderButtons(): ApplicationHeaderButton[];

    /**
     * Prepare pages for display.
     * @returns The sorted list of pages.
     */
    protected _getPageData(): JournalEntryPage<TJournalEntry>[];

    /**
     * Identify which page of the journal sheet should be currently rendered.
     * This can be controlled by options passed into the render method or by a subclass override.
     * @param options Sheet rendering options
     * @param [options.pageIndex] A numbered index of page to render
     * @param [options.pageId]    The ID of a page to render
     * @returns The currently displayed page index
     */
    protected _getCurrentPage(options?: { pageIndex?: number; pageId?: string }): number;

    override activateListeners(html: JQuery): void;

    /** Activate listeners after page content has been injected. */
    protected _activatePageListeners(): void;

    /**
     * @param [options.mode]       Render the sheet in a given view mode, see {@link JournalSheet.VIEW_MODES}.
     * @param [options.pageId]     Render the sheet with the page with the given ID in view.
     * @param [options.pageIndex]  Render the sheet with the page at the given index in view.
     * @param [options.anchor]     Render the sheet with the given anchor for the given page in view.
     * @param [options.tempOwnership] Whether the journal entry or one of its pages is being shown to players
     *                                who might otherwise not have permission to view it.
     * @param [options.collapsed] Render the sheet with the TOC sidebar collapsed?
     */
    protected override _render(force?: boolean, options?: JournalSheetRenderOptions): Promise<void>;

    /** Update child views inside the main sheet. */
    protected _renderPageViews(): Promise<void>;

    /**
     * Add headings to the table of contents for the given page node.
     * @param pageNode The HTML node of the page's rendered contents.
     * @param toc      The page's table of contents.
     */
    protected _renderHeadings(pageNode: HTMLElement, toc: Record<string, JournalEntryPageHeading>): void;

    /**
     * Create an intersection observer to maintain a list of headings that are in view. This is much more performant than
     * calling getBoundingClientRect on all headings whenever we want to determine this list.
     * @protected
     */
    protected _observeHeadings(): void;

    override close(options?: { force?: boolean }): Promise<void>;

    /**
     * Handle clicking the previous and next page buttons.
     * @param event  The button click event.
     */
    protected _onAction(event: JQuery.TriggeredEvent): void;

    /** Prompt the user with a Dialog for creation of a new JournalEntryPage */
    createPage(): Promise<JournalEntryPage<TJournalEntry> | null>;

    /** Turn to the previous page. */
    previousPage(): Promise<this> | void;

    /** Turn to the next page. */
    nextPage(): Promise<this> | void;

    /**
     * Turn to a specific page.
     * @param pageId   The ID of the page to turn to.
     * @param [anchor] Optionally an anchor slug to focus within that page.
     */
    goToPage(pageId: string, anchor?: string): void;

    /**
     * Retrieve the sheet instance for rendering this page inline.
     * @param pageId The ID of the page.
     */
    getPageSheet(pageId: string): JournalEntryPage<TJournalEntry> | undefined;

    /**
     * Determine whether a page is visible to the current user.
     * @param page  The page.
     */
    isPageVisible(page: JournalEntryPage<TJournalEntry>): boolean;

    /** Toggle the collapsed or expanded state of the Journal Entry table-of-contents sidebar. */
    toggleSidebar(): void;

    /** Update the disabled state of the previous and next page buttons. */
    protected _updateButtonState(): void;

    /**
     * Edit one of this JournalEntry's JournalEntryPages.
     * @param event  The originating page edit event.
     */
    protected _onEditPage(event: JQuery.TriggeredEvent): Promise<this> | undefined;

    /**
     * Handle clicking an entry in the sidebar to scroll that heading into view.
     * @param event The originating click event.
     */
    protected _onClickPageLink(event: JQuery.TriggeredEvent): void;

    /**
     * Handle clicking an image to pop it out for fullscreen view.
     * @param event The click event.
     */
    protected _onClickImage(event: MouseEvent): void;

    /**
     * Handle new pages scrolling into view.
     * @param entries  An Array of elements that have scrolled into or out of view.
     * @param observer The IntersectionObserver that invoked this callback.
     */
    protected _onPageScroll(entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;

    /** Highlights the currently viewed page in the sidebar. */
    protected _activatePagesInView(): void;

    /**
     * If the set of active pages has changed, various elements in the sidebar will expand and collapse. For particularly
     * long ToCs, this can leave the scroll position of the sidebar in a seemingly random state. We try to do our best to
     * sync the sidebar scroll position with the current journal viewport.
     */
    protected _synchronizeSidebar(): void;

    protected _contextMenu(html: JQuery): void;

    /**
     * Handle opening the context menu.
     * @param target The element the context menu has been triggered for.
     */
    protected _onContextMenuOpen(target: HTMLElement): void;

    /**
     * Handle closing the context menu.
     * @param target The element the context menu has been triggered for.
     */
    protected _onContextMenuClose(target: HTMLElement): void;

    /**
     * Get the set of ContextMenu options which should be used for JournalEntryPages in the sidebar.
     * @returns {ContextMenuEntry[]}  The Array of context options passed to the ContextMenu instance.
     */
    protected _getEntryContextOptions(): ContextMenuEntry[];

    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<void>;

    /**
     * Handle requests to show the referenced Journal Entry to other Users
     * Save the form before triggering the show request, in case content has changed
     * @param event The triggering click event
     */
    protected _onShowPlayers(event: Event): Promise<void>;

    protected override _canDragStart(selector: string): boolean;

    protected override _canDragDrop(selector: string): boolean;

    protected override _onDragStart(event: DragEvent): void;

    protected override _onDrop(event: DragEvent): Promise<void>;

    protected override _onSearchFilter(
      event: KeyboardEvent,
      query: string,
      rgx: RegExp,
      html: HTMLElement | null,
    ): void;
  }

  type JournalSheetViewMode = (typeof JournalSheet.VIEW_MODES)[keyof typeof JournalSheet.VIEW_MODES];

  interface JournalSheetRenderOptions extends DocumentRenderOptions {
    pageId?: string;
    pageIndex?: number;
  }

  interface JournalSheetData<TDocument extends JournalEntry> extends DocumentSheetData<TDocument> {
    collapseMode: {
      label: string;
      icon: string;
    };
    searchIcon: string;
    searchTooltip: string;
    toc: JournalSheetPageData[];
  }

  interface JournalSheetPageData extends JournalEntryPageSource {
    number: 0;
    ownershipCls: string;
  }
}

declare global {
  /** An application for configuring data across all installed and active packages. */
  abstract class PackageConfiguration extends FormApplication {
    static get categoryOrder(): string[];

    /** The name of the currently active tab. */
    get activeCategory(): string;

    static override get defaultOptions(): FormApplicationOptions;

    override getData(options?: FormApplicationOptions): FormApplicationData;

    /** Prepare the structure of category data which is rendered in this configuration form. */
    protected abstract _prepareCategoryData(): { categories: object[]; total: number };

    /**
     * Classify what Category an Action belongs to
     * @param namespace The entry to classify
     * @returns The category the entry belongs to
     */
    protected _categorizeEntry(namespace: string): { id: string; title: string };

    /** Reusable logic for how categories are sorted in relation to each other. */
    protected _sortCategories(a: object, b: object): number;

    protected override _render(force?: boolean, options?: RenderOptions): Promise<void>;

    override activateListeners(html: JQuery): void;

    protected override _onChangeTab(event: MouseEvent | null, tabs: Tabs, active: string): void;

    protected override _onSearchFilter(event: KeyboardEvent, query: string, rgx: RegExp, html: HTMLElement): void;

    /**
     * Handle button click to reset default settings
     * @param event The initial button click event
     */
    protected abstract _onResetDefaults(event: Event): void;
  }
}

declare global {
  /** Allows for viewing and editing of Keybinding Actions */
  class KeybindingsConfig extends PackageConfiguration {
    static override get defaultOptions(): FormApplicationOptions;

    static override get categoryOrder(): string[];

    protected _categorizeEntry(namespace: string): { id: string; title: string };

    protected _prepareCategoryData(): { categories: object[]; total: number };

    /**
     * Add faux-keybind actions that represent the possible Mouse Controls
     * @param categories The current Map of Categories to add to
     * @returns The number of Actions added
     */
    protected _addMouseControlsReference(categories: Map<string, object>): number;

    /** Given an Binding and its parent Action, detects other Actions that might conflict with that binding */
    _detectConflictingActions(
      actionId: string,
      action: KeybindingActionConfig,
      binding: KeybindingAction,
    ): KeybindingAction[];

    /** Transforms a Binding into a human-readable string representation */
    static _humanizeBinding(binding: KeybindingActionBinding): string;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    override activateListeners(html: JQuery): void;

    protected override _onResetDefaults(event: Event): Promise<void>;

    /** Handle Control clicks */
    protected _onClickBindingControl(event: MouseEvent): void;

    /** Handle left-click events to show / hide a certain category */
    protected _onClickAdd(event: MouseEvent): Promise<void>;

    /** Handle left-click events to show / hide a certain category */
    protected _onClickDelete(event: MouseEvent): Promise<void>;

    /** Inserts a Binding into the Pending Edits object, creating a new Map entry as needed */
    protected _addPendingEdit(
      namespace: string,
      action: string,
      bindingIndex: number,
      binding: KeybindingActionBinding,
    ): void;

    /** Toggle visibility of the Edit / Save UI */
    protected _onClickEditableBinding(event: MouseEvent): void;

    /** Toggle visibility of the Edit UI */
    protected _onDoubleClickKey(event: MouseEvent): void;

    /** Save the new Binding value and update the display of the UI */
    protected _onClickSaveBinding(event: MouseEvent): Promise<void>;

    /** Given a clicked Action element, finds the parent Action */
    protected _getParentAction(event: MouseEvent | KeyboardEvent): object;

    /** Given a Clicked binding control element, finds the parent Binding */
    protected _getParentBinding(event: MouseEvent | KeyboardEvent): {
      bindingHTML: HTMLElement | null;
      bindingId: string | undefined;
    };

    /** Iterates over all Pending edits, merging them in with unedited Bindings and then saving and resetting the UI */
    protected _savePendingEdits(): Promise<void>;

    /** Processes input from the keyboard to form a list of pending Binding edits */
    protected _onKeydownBindingInput(event: KeyboardEvent): void;

    // Not actually implemented but requires by `FormApplication`
    protected override _updateObject(event: Event, formData: Record<string, unknown>): Promise<unknown>;
  }
}

declare global {
  interface Config<
    TAmbientLightDocument extends AmbientLightDocument<TScene | null>,
    TActiveEffect extends ActiveEffect<TActor | TItem | null>,
    TActor extends Actor<TTokenDocument | null>,
    TActorDelta extends ActorDelta<TTokenDocument | null>,
    TChatLog extends ChatLog,
    TChatMessage extends ChatMessage,
    TCombat extends Combat,
    TCombatant extends Combatant<TCombat | null, TTokenDocument | null>,
    TCombatTracker extends CombatTracker<TCombat | null>,
    TCompendiumDirectory extends CompendiumDirectory,
    THotbar extends Hotbar,
    TItem extends Item<TActor | null>,
    TMacro extends Macro,
    TMeasuredTemplateDocument extends MeasuredTemplateDocument<TScene | null>,
    TTileDocument extends TileDocument<TScene | null>,
    TTokenDocument extends TokenDocument<TScene | null>,
    TWallDocument extends WallDocument<TScene | null>,
    TScene extends Scene,
    TUser extends User<Actor<null>>,
    TEffectsCanvasGroup extends EffectsCanvasGroup,
  > {
    /** Configure debugging flags to display additional information */
    debug: {
      dice: boolean;
      documents: boolean;
      fog: boolean;
      hooks: boolean;
      sight: boolean;
      sightRays: boolean;
      av: boolean;
      avclient: boolean;
      mouseInteraction: boolean;
      time: boolean;
    };

    /** Configure the DatabaseBackend used to perform Document operations */
    DatabaseBackend: ClientDatabaseBackend;

    /** Configuration for the Actor document */
    Actor: {
      documentClass: {
        new (data: PreCreate<TActor['_source']>, context?: DocumentConstructionContext<TActor['parent']>): TActor;
      };
      collection: ConstructorOf<Actors<Actor<null>>>;
      sheetClasses: Record<
        string,
        Record<
          string,
          {
            id: string;
            cls: typeof ActorSheet;
            default: boolean;
            label: string;
            canConfigure: boolean;
            canBeDefault: boolean;
          }
        >
      >;
      typeIcons: Record<string, string>;
      typeLabels: Record<string, string | undefined>;
    };

    /** Configuration for the Cards primary Document type */
    Cards: {
      collection: WorldCollection<Cards>;
      documentClass: ConstructorOf<Cards>;
      sidebarIcon: string;
      presets: Record<string, { type: string; label: string; source: string }>;
    };

    /** Configuration for the FogExploration document */
    FogExploration: {
      documentClass: typeof FogExploration;
      collection: typeof WorldCollection;
    };

    /** Configuration for the Folder document */
    Folder: {
      documentClass: typeof Folder;
      collection: typeof Folders;
    };

    /** Configuration for the ChatMessage document */
    ChatMessage: {
      batchSize: number;
      collection: typeof Messages;
      documentClass: {
        new (data: PreCreate<TChatMessage['_source']>, context?: DocumentConstructionContext<null>): TChatMessage;
      };
      sidebarIcon: string;
      template: string;
    };

    /** Configuration for Item document */
    Item: {
      documentClass: {
        new (data: PreCreate<TItem['_source']>, context?: DocumentConstructionContext<TItem['parent']>): TItem;
      };
      collection: typeof Items;
      sheetClasses: Record<
        string,
        Record<
          string,
          {
            id: string;
            cls: typeof ItemSheet;
            default: boolean;
            label: string;
            canConfigure: boolean;
            canBeDefault: boolean;
          }
        >
      >;
      typeIcons: Record<string, string>;
      typeLabels: Record<string, string | undefined>;
    };

    /** Configuration for the Combat document */
    Combat: {
      documentClass: {
        new (data: PreCreate<TCombat['_source']>, context?: DocumentConstructionContext<null>): TCombat;
      };
      collection: typeof CombatEncounters;
      defeatedStatusId: string;
      sidebarIcon: string;
      initiative: {
        formula: ((combatant: TCombat['turns'][number]) => string) | null;
        decimals: number;
      };
    };

    /** Configuration for the JournalEntry entity */
    JournalEntry: {
      documentClass: typeof JournalEntry;
      noteIcons: {
        Anchor: string;
        [key: string]: string;
      };
      sheetClasses: Record<
        string,
        Record<
          string,
          {
            id: string;
            cls: typeof JournalSheet;
            default: boolean;
            label: string;
            canConfigure: boolean;
            canBeDefault: boolean;
          }
        >
      >;
      sidebarIcon: string;
    };

    /** Configuration for the Macro document */
    Macro: {
      documentClass: ConstructorOf<TMacro>;
      collection: typeof Macros;
      sidebarIcon: string;
    };

    /** Configuration for Scene document */
    Scene: {
      documentClass: ConstructorOf<TScene>;
      collection: typeof Scenes;
      sidebarIcon: string;
    };

    /** Configuration for the Playlist document */
    Playlist: {
      documentClass: typeof Playlist;
      sidebarIcon: string;
    };

    /** Configuration for RollTable random draws */
    RollTable: {
      documentClass: typeof RollTable;
      sidebarIcon: string;
      resultIcon: string;
    };

    /** Configuration for the User document */
    User: {
      documentClass: ConstructorOf<TUser>;
      collection: typeof Users;
      permissions: undefined;
    };

    /* -------------------------------------------- */
    /*  Embedded Documents                          */
    /* -------------------------------------------- */

    /** Configuration for the AmbientLight embedded document type and its representation on the game Canvas */
    AmbientLight: {
      documentClass: ConstructorOf<TAmbientLightDocument>;
      objectClass: ConstructorOf<NonNullable<TAmbientLightDocument['object']>>;
      layerClass: ConstructorOf<NonNullable<TAmbientLightDocument['object']>['layer']>;
    };

    /** Configuration for the ActiveEffect embedded document type */
    ActiveEffect: {
      documentClass: {
        new (
          data: PreCreate<TActiveEffect['_source']>,
          context?: DocumentConstructionContext<TActiveEffect['parent']>,
        ): TActiveEffect;
      };
    };

    /** Configuration for the ActorDelta embedded document type. */
    ActorDelta: {
      documentClass: ConstructorOf<TActorDelta>;
    };

    /** Configuration for the Combatant document */
    Combatant: {
      documentClass: new (
        data: PreCreate<TCombatant['_source']>,
        context?: DocumentConstructionContext<TCombatant['parent']>,
      ) => TCombatant;
    };

    /** Configuration for the MeasuredTemplate embedded document type and its representation on the game Canvas */
    MeasuredTemplate: {
      defaults: {
        angle: number;
        width: number;
      };
      types: {
        circle: string;
        cone: string;
        rect: string;
        ray: string;
      };
      documentClass: ConstructorOf<TMeasuredTemplateDocument>;
      objectClass: ConstructorOf<NonNullable<TMeasuredTemplateDocument['object']>>;
      layerClass: ConstructorOf<NonNullable<TMeasuredTemplateDocument['object']>['layer']>;
    };

    /** Configuration for the Tile embedded document type and its representation on the game Canvas */
    Tile: {
      documentClass: ConstructorOf<TTileDocument>;
      objectClass: ConstructorOf<NonNullable<TTileDocument['object']>>;
      layerClass: ConstructorOf<TilesLayer<NonNullable<TTileDocument['object']>>>;
    };

    /** Configuration for the Token embedded document type and its representation on the game Canvas */
    Token: {
      documentClass: ConstructorOf<TTokenDocument>;
      objectClass: ConstructorOf<NonNullable<TTokenDocument['object']>>;
      layerClass: ConstructorOf<NonNullable<TTokenDocument['object']>['layer']>;
      prototypeSheetClass: ConstructorOf<TTokenDocument['sheet']>;
    };

    /** Configuration for the Wall embedded document type and its representation on the game Canvas */
    Wall: {
      documentClass: ConstructorOf<TWallDocument>;
      objectClass: ConstructorOf<Wall<TWallDocument>>;
      layerClass: ConstructorOf<NonNullable<TWallDocument['object']>['layer']>;
    };

    /* -------------------------------------------- */
    /*  Canvas                                      */
    /* -------------------------------------------- */

    /** Configuration settings for the Canvas and its contained layers and objects */
    Canvas: {
      blurStrength: number;
      darknessColor: number;
      darknessLightPenalty: number;
      daylightColor: number;
      dragSpeedModifier: number;
      dispositionColors: {
        HOSTILE: number;
        NEUTRAL: number;
        FRIENDLY: number;
        INACTIVE: number;
        PARTY: number;
        CONTROLLED: number;
        SECRET: number;
      };
      exploredColor: number;
      unexploredColor: number;
      groups: {
        hidden: {
          groupClass: ConstructorOf<PIXI.Container>;
          parent: 'stage';
        };
        rendered: {
          groupClass: ConstructorOf<PIXI.Container>;
          parent: 'stage';
        };
        environment: {
          groupClass: ConstructorOf<PIXI.Container>;
          parent: 'rendered';
        };
        primary: {
          groupClass: ConstructorOf<PIXI.Container>;
          parent: 'environment';
        };
        effects: {
          groupClass: ConstructorOf<TEffectsCanvasGroup>;
          parent: 'environment';
        };
        interface: {
          groupClass: ConstructorOf<InterfaceCanvasGroup>;
          parent: 'rendered';
        };
      };
      layers: {
        drawings: {
          group: 'primary';
          layerClass: typeof DrawingsLayer;
        };
        grid: {
          group: 'primary';
          layerClass: typeof GridLayer;
        };
        walls: {
          group: 'effects';
          layerClass: ConstructorOf<NonNullable<TWallDocument['object']>['layer']>;
        };
        templates: {
          group: 'primary';
          layerClass: ConstructorOf<NonNullable<TMeasuredTemplateDocument['object']>['layer']>;
        };
        notes: {
          group: 'interface';
          layerClass: typeof NotesLayer;
        };
        tokens: {
          group: 'primary';
          layerClass: ConstructorOf<NonNullable<TTokenDocument['object']>['layer']>;
        };
        tiles: {
          group: 'primary';
          layerClass: typeof TilesLayer;
        };
        sounds: {
          group: 'interface';
          layerClass: typeof SoundsLayer;
        };
        lighting: {
          group: 'effects';
          layerClass: ConstructorOf<NonNullable<TAmbientLightDocument['object']>['layer']>;
        };
        controls: {
          group: 'interface';
          layerClass: typeof ControlsLayer;
        };
      };
      lightLevels: {
        dark: number;
        halfdark: number;
        dim: number;
        bright: number;
      };

      polygonBackends: {
        sight: typeof ClockwiseSweepPolygon;
        light: typeof ClockwiseSweepPolygon;
        sound: typeof ClockwiseSweepPolygon;
        move: typeof ClockwiseSweepPolygon;
      };

      normalLightColor: number;
      maxZoom: number;
      objectBorderThickness: number;
      lightAnimations: {
        torch: {
          label: 'LIGHT.AnimationTorch';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTorch'];
          illuminationShader: typeof PIXI.Shader;
          colorationShader: typeof PIXI.Shader;
        };
        pulse: {
          label: 'LIGHT.AnimationPulse';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animatePulse'];
          illuminationShader: typeof PIXI.Shader;
          colorationShader: typeof PIXI.Shader;
        };
        chroma: {
          label: 'LIGHT.AnimationChroma';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        wave: {
          label: 'LIGHT.AnimationWave';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          illuminationShader: typeof PIXI.Shader;
          colorationShader: typeof PIXI.Shader;
        };
        fog: {
          label: 'LIGHT.AnimationFog';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        sunburst: {
          label: 'LIGHT.AnimationSunburst';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          illuminationShader: typeof PIXI.Shader;
          colorationShader: typeof PIXI.Shader;
        };
        dome: {
          label: 'LIGHT.AnimationLightDome';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        emanation: {
          label: 'LIGHT.AnimationEmanation';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        hexa: {
          label: 'LIGHT.AnimationHexaDome';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        ghost: {
          label: 'LIGHT.AnimationGhostLight';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          illuminationShader: typeof PIXI.Shader;
          colorationShader: typeof PIXI.Shader;
        };
        energy: {
          label: 'LIGHT.AnimationEnergyField';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          colorationShader: typeof PIXI.Shader;
        };
        roiling: {
          label: 'LIGHT.AnimationRoilingMass';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          illuminationShader: typeof PIXI.Shader;
        };
        hole: {
          label: 'LIGHT.AnimationBlackHole';
          animation: LightSource<TAmbientLightDocument['object'] | TTokenDocument['object']>['animateTime'];
          illuminationShader: typeof PIXI.Shader;
        };
      };

      /** The set of VisionMode definitions which are available to be used for Token vision. */
      visionModes: {
        // Default (Basic) Vision
        basic: VisionMode;

        // Darkvision
        darkvision: VisionMode;

        // Monochromatic
        monochromatic: VisionMode;

        // Blindness
        blindness: VisionMode;

        // Tremorsense
        tremorsense: VisionMode;

        // Light Amplification
        lightAmplification: VisionMode;

        [key: string]: VisionMode;
      };

      /** The set of DetectionMode definitions which are available to be used for visibility detection. */
      detectionModes: {
        basicSight: DetectionModeBasicSight;
        seeInvisibility: DetectionModeInvisibility;
        senseInvisibility: DetectionModeInvisibility;
        feelTremor: DetectionModeTremor;
        seeAll: DetectionModeAll;
        senseAll: DetectionModeAll;
      } & Record<string, DetectionMode | undefined>;
    };

    /** Configure the default Token text style so that it may be reused and overridden by modules */
    canvasTextStyle: PIXI.TextStyle;

    /** Available Weather Effects implemntations */
    weatherEffects: Record<string, SpecialEffect>;

    /** Configuration for dice rolling behaviors in the Foundry VTT client */
    Dice: {
      types: (typeof Die | typeof DiceTerm)[];
      rollModes: Record<RollMode, string>;
      rolls: ConstructorOf<Roll>[];
      termTypes: Record<string, ConstructorOf<RollTerm> & { fromData(data: object): RollTerm }>;
      terms: {
        c: typeof Coin;
        d: typeof Die;
        f: typeof FateDie;
        [key: string]: ConstructorOf<DiceTerm>;
      };
      randomUniform: Function;
    };

    /** The control icons used for rendering common HUD operations */
    controlIcons: ControlIconsConfig;

    /** A collection of fonts to load either from the user's local system, or remotely. */
    fontDefinitions: Record<string, FontFamilyDefinition>;

    /** deprecated since v10. */
    _fontFamilies: string[];

    /** The default font family used for text labels on the PIXI Canvas */
    defaultFontFamily: string;

    /** An array of status effect icons which can be applied to Tokens */
    statusEffects: StatusEffect[];

    /** A mapping of status effect IDs which provide some additional mechanical integration. */
    specialStatusEffects: {
      DEFEATED: string;
      INVISIBLE: string;
      BLIND: string;
      [key: string]: string;
    };

    /** A mapping of core audio effects used which can be replaced by systems or mods */
    sounds: {
      dice: AudioFilePath;
      lock: string;
      notification: string;
      combat: string;
    };

    /** Define the set of supported languages for localization */
    supportedLanguages: {
      en: string;
      [key: string]: string;
    };

    /** Maximum canvas zoom scale */
    maxCanvasZoom: number;

    /** Custom enrichers for TextEditor.enrichHTML */
    TextEditor: {
      enrichers: {
        pattern: RegExp;
        enricher: (match: RegExpMatchArray, options: EnrichmentOptions) => Promise<HTMLElement | null>;
      }[];
    };

    /* -------------------------------------------- */
    /*  Integrations                                */
    /* -------------------------------------------- */

    /** Default configuration options for TinyMCE editors */
    // See https://www.tiny.cloud/docs/configure/content-appearance/
    TinyMCE: Omit<TinyMCE.EditorOptions, 'style_formats'> & {
      style_formats: NonNullable<TinyMCE.EditorOptions['style_formats']>;
    };

    ui: {
      actors: ConstructorOf<ActorDirectory<Actor<null>>>;
      chat: ConstructorOf<TChatLog>;
      combat: ConstructorOf<TCombatTracker>;
      compendium: ConstructorOf<TCompendiumDirectory>;
      controls: typeof SceneControls;
      hotbar: ConstructorOf<THotbar>;
      items: ConstructorOf<ItemDirectory<Item<null>>>;
      // journal: typeof JournalDirectory;
      // macros: typeof MacroDirectory;
      menu: typeof MainMenu;
      nav: typeof SceneNavigation;
      notifications: typeof Notifications;
      pause: typeof Pause;
      players: typeof PlayerList;
      // playlists: typeof PlaylistDirectory;
      // scenes: typeof SceneDirectory;
      settings: typeof Settings;
      sidebar: typeof Sidebar;
      tables: typeof RollTableDirectory;
      // webrtc: typeof CameraViews;
    };
  }

  interface ControlIconsConfig {
    combat: ImageFilePath | VideoFilePath;
    visibility: ImageFilePath | VideoFilePath;
    effects: ImageFilePath | VideoFilePath;
    lock: ImageFilePath | VideoFilePath;
    up: ImageFilePath | VideoFilePath;
    down: ImageFilePath | VideoFilePath;
    defeated: ImageFilePath | VideoFilePath;
    [key: string]: ImageFilePath | VideoFilePath | undefined;
  }

  interface StatusEffect {
    id: string;
    label: string;
    icon: ImageFilePath | VideoFilePath;
  }

  interface FontFamilyDefinition {
    /** Whether the font is available in the rich text editor. This will also enable it for notes and drawings. */
    editor: boolean;
    fonts: FontDefinition[];
  }

  interface FontDefinition extends FontFaceDescriptors {
    /**
     * Individual font face definitions for this font family. If this is empty, the font family may only be loaded
     * from the client's OS-installed fonts.
     */
    urls: string[];
  }
}

declare global {
  /**
   * A helper class to provide common functionality for working with HTML5 audio and Howler instances
   * A singleton instance of this class is available as ``game.audio``
   */
  class AudioHelper {
    constructor();

    /**
     * The primary Audio Context used to play client-facing sounds.
     * The context is undefined until the user's first gesture is observed.
     */
    context: AudioContext;

    /** The set of AudioBuffer objects which are cached for different audio paths */
    buffers: Map<string, AudioBuffer>;

    /** The set of singleton Sound instances which are cached for different audio paths */
    sounds: Map<string, Sound>;

    /** Get a map of the Sound objects which are currently playing. */
    playing: Map<number, Sound>;

    /**
     * A user gesture must be registered before audio can be played.
     * This Array contains the Sound instances which are requested for playback prior to a gesture.
     * Once a gesture is observed, we begin playing all elements of this Array.
     */
    pending: Function[];

    /** A flag for whether video playback is currently locked by awaiting a user gesture */
    locked: boolean;

    /**
     * Audio Context singleton used for analysing audio levels of each stream
     * Only created if necessary to listen to audio streams.
     */
    protected _audioContext: AudioContext | null;

    /**
     * Map of all streams that we listen to for determining the decibel levels.
     * Used for analyzing audio levels of each stream.
     * Format of the object stored is :
     * {id:
     *   {
     *     stream: MediaStream,
     *     analyser: AudioAnalyser,
     *     interval: Number,
     *     callback: Function
     *   }
     * }
     */
    protected _analyserStreams: Record<string, AnalyserStream>;

    /**
     * Interval ID as returned by setInterval for analysing the volume of streams
     * When set to 0, means no timer is set.
     */
    protected _analyserInterval: number;

    /**
     * Fast Fourier Transform Array.
     * Used for analysing the decibel level of streams. The array is allocated only once
     * then filled by the analyser repeatedly. We only generate it when we need to listen to
     * a stream's level, so we initialize it to null.
     */
    protected _fftArray: Float32Array;

    /**
     * The Native interval for the AudioHelper to analyse audio levels from streams
     * Any interval passed to startLevelReports() would need to be a multiple of this value.
     */
    static levelAnalyserNativeInterval: number;

    static registerSettings(): void;

    /**
     * Create a Howl instance
     */
    create({
      src,
      preload,
      autoplay,
      volume,
      loop,
    }: {
      src: string;
      preload: boolean;
      autoplay: boolean;
      volume: number;
      loop: boolean;
    }): void;

    /**
     * Play a single audio effect by it's source path and Howl ID
     */
    play(src: string, id: number): void;

    /**
     * Register an event listener to await the first mousemove gesture and begin playback once observed
     */
    awaitFirstGesture(): void;

    /**
     * Request that other connected clients begin preloading a certain sound path.
     * @param src The source file path requested for preload
     * @returns A Promise which resolves once the preload is complete
     */
    preload(): Promise<Sound>;

    /**
     * Play a one-off sound effect which is not part of a Playlist
     *
     * @param data          An object configuring the audio data to play
     * @param data.src      The audio source file path, either a public URL or a local path relative to the public directory
     * @param data.volume   The volume level at which to play the audio, between 0 and 1.
     * @param data.autoplay Begin playback of the audio effect immediately once it is loaded.
     * @param data.loop     Loop the audio effect and continue playing it until it is manually stopped.
     * @param push          Push the audio sound effect to other connected clients?
     *
     * @return              A Howl instance which controls audio playback.
     *
     * @example
     * // Play the sound of a locked door for all players
     * Audio.play({src: "sounds/lock.wav", volume: 0.8, autoplay: true, loop: false}, true);
     */
    static play(data: { src: string; autoplay: boolean; volume: number; loop: boolean }, push: boolean): void;

    /**
     * Returns the volume value based on a range input volume control's position.
     * This is using an exponential approximation of the logarithmic nature of audio level perception
     * Based on https://www.dr-lex.be/info-stuff/volumecontrols.html
     * We're using x^3 by default instead of x^4 otherwise the audio becomes nearly silent around the 40% mark.
     * @param control   Value between [0, 1] of the range input
     * @param order     (optional) the exponent of the curve (default: 3)
     */
    static inputToVolume(control: number, order: number): number;

    /**
     * Counterpart to inputToVolume()
     * Returns the input range value based on a volume
     * @param control   Value between [0, 1] of the volume level
     * @param order     (optional) the exponent of the curve (default: 3)
     */
    static volumeToInput(volume: number, order: number): number;
  }
}

interface AnalyserStream {
  stream: MediaStream;
  analyser: object;
  interval: number;
  callback: Function;
}

declare global {
  /**
   * A leaf entry in the tree.
   * @typedef WordTreeEntry
   * @property entry        An object that this entry represents.
   * @property documentName The document type.
   * @property uuid         The document's UUID.
   * @property [pack]       The pack ID.
   */
  interface WordTreeEntry {
    entry: foundry.abstract.Document | object;
    documentName: WorldDocument['documentName'];
    uuid: string;
    pack?: string;
  }

  /**
   * A word tree node consists of zero or more 1-character keys, and a leaves property that contains any objects that
   * terminate at the current string prefix.
   * @typedef WordTreeNode
   * @property leaves Any leaves at this node.
   */
  interface WordTreeNode {
    leaves: WordTreeEntry[];
  }

  /**
   * A data structure for quickly retrieving objects by a string prefix.
   * Note that this works well for languages with alphabets (latin, cyrillic, korean, etc.), but may need more nuanced
   * handling for languages that compose characters and letters.
   */
  class WordTree {
    /** Create a new node. */
    get node(): WordTreeNode;

    /**
     * Insert an entry into the tree.
     * @param string The string key for the entry.
     * @param entry  The entry to store.
     * @returns The node the entry was added to.
     */
    addLeaf(string: string, entry: WordTreeEntry): WordTreeNode;

    /**
     * Return entries that match the given string prefix.
     * @param prefix             The prefix.
     * @param [options]          Additional options to configure behaviour.
     * @param [options.limit=10] The maximum number of items to retrieve. It is important to set this value as
     *                           very short prefixes will naturally match large numbers of entries.
     * @returns A number of entries that have the given prefix.
     */
    lookup(prefix: string, options?: { limit?: number }): WordTreeEntry;

    /**
     * Returns the node at the given prefix.
     * @param prefix The prefix.
     */
    nodeAtPrefix(prefix: string): WordTreeNode | void;

    /**
     * Perform a breadth-first search starting from the given node and retrieving any entries along the way, until we
     * reach the limit.
     * @param node      The starting node.
     * @param entries   The accumulated entries.
     * @param queue     The working queue of nodes to search.
     * @param [options] Additional options for the search.
     * @param [options.limit=10] The maximum number of entries to retrieve before stopping.
     */
    protected _breadthFirstSearch(
      node: WordTreeNode,
      entries: WordTreeEntry[],
      queue: WordTreeNode[],
      options?: { limit?: number },
    ): void;
  }

  /**
   * This class is responsible for indexing all documents available in the world and storing them in a word tree
   * structure that allows for fast searching.
   */
  class DocumentIndex {
    constructor();
    /** A collection of WordTree structures for each document type. */
    trees: Record<string, WordTree>;

    /** A reverse-lookup of a document's UUID to its parent node in the word tree. */
    uuids: Record<string, WordTreeNode>;

    /** Returns a Promise that resolves when the indexing process is complete. */
    get ready(): void | null;

    /** Index all available documents in the world and store them in a word tree. */
    index(): Promise<void>;

    /**
     * Return entries that match the given string prefix.
     * @param prefix                  The prefix.
     * @param [options]               Additional options to configure behaviour.
     * @param [options.documentTypes] Optionally provide an array of document types. Only entries of that type
     *                                will be searched for.
     * @param [options.limit=10]      The maximum number of items per document type to retrieve. It is
     *                                important to set this value as very short prefixes will naturally match
     *                                large numbers of entries.
     * @returns A number of entries that have the given prefix, grouped by document type.
     */
    lookup(prefix: string, options?: { limit?: number; documentTypes?: string[] }): Record<string, WordTreeEntry[]>;

    /**
     * Add an entry to the index.
     * @param doc The document entry.
     */
    addDocument(doc: foundry.abstract.Document): void;

    /**
     * Remove an entry from the index.
     * @param doc The document entry.
     */
    removeDocument(doc: foundry.abstract.Document): void;

    /**
     * Replace an entry in the index with an updated one.
     * @param doc The document entry.
     */
    replaceDocument(doc: foundry.abstract.Document): void;

    /**
     * Add a leaf node to the word tree index.
     * @param doc            The document or compendium index entry to add.
     * @param [options]      Additional information for indexing.
     * @param [options.pack] The compendium that the index belongs to.
     */
    protected _addLeaf(doc: WorldDocument | object, options?: { pack?: CompendiumCollection }): void;

    /**
     * Aggregate the compendium index and add it to the word tree index.
     * @param pack The compendium pack.
     */
    protected _indexCompendium(pack: CompendiumCollection): void;

    /**
     * Add all of a parent document's embedded documents to the index.
     * @param parent The parent document.
     */
    protected _indexEmbeddedDocuments(parent: WorldDocument): void;

    /**
     * Aggregate all documents and embedded documents in a world collection and add them to the index.
     * @param documentName  The name of the documents to index.
     */
    protected _indexWorldCollection(documentName: WorldDocument['documentName']): void;
  }
}

declare global {
  type HookCallback<P extends unknown[]> = (...args: P) => boolean | void | Promise<boolean | void>;
  type HookParameters<H extends string, C extends unknown[]> = [hook: H, callback: HookCallback<C>];

  // Sequence of hooks called on world load
  type HookParamsInit = HookParameters<'init', never>;
  type HookParamsSetup = HookParameters<'setup', never>;
  type HookParamsI18nInit = HookParameters<'i18nInit', never>;
  type HookParamsCanvasInit = HookParameters<'canvasInit', [DrawnCanvas]>;
  type HookParamsCanvasReady = HookParameters<'canvasReady', [DrawnCanvas]>;
  type HookParamsReady = HookParameters<'ready', never>;

  type HookParamsClose<T extends Application, N extends string> = HookParameters<`close${N}`, [T, JQuery]>;
  type HookParamsDeleteCombat = HookParameters<'deleteCombat', [Combat, { [key: string]: unknown }, string]>;
  type HookParamsDropCanvasData = HookParameters<'dropCanvasData', [Canvas, DropCanvasData]>;
  type HookParamsGetChatLogEntryContext = HookParameters<'getChatLogEntryContext', [JQuery, EntryContextOption[]]>;
  type HookParamsGetSceneControlButtons = HookParameters<'getSceneControlButtons', [SceneControl[]]>;
  type HookParamsHotbarDrop = HookParameters<'hotbarDrop', [Hotbar, unknown, string]>;
  type HookParamsLightingRefresh = HookParameters<'lightingRefresh', [LightingLayer]>;
  type HookParamsPreCreateItem = HookParameters<
    'preCreateItem',
    [PreCreate<foundry.documents.ItemSource>, DocumentModificationContext<Actor | null>, string]
  >;
  type HooksParamsPreUpdateCombat = HookParameters<
    'preUpdateCombat',
    [Combat, object, { diff: boolean; advanceTime: number; [key: string]: unknown }, string]
  >;
  type HookParamsPreUpdateToken = HookParameters<
    'preUpdateToken',
    [
      Scene,
      foundry.documents.TokenSource,
      DeepPartial<foundry.documents.TokenSource>,
      { diff: boolean; [key: string]: unknown },
      string,
    ]
  >;
  type HookParamsRender<T extends Application, N extends string> = HookParameters<
    `render${N}`,
    [T, JQuery, Awaited<ReturnType<T['getData']>>]
  >;
  type HookParamsRenderChatMessage = HookParameters<
    'renderChatMessage',
    [ChatMessage, JQuery, foundry.documents.ChatMessageSource]
  >;
  type HookParamsTargetToken = HookParameters<'targetToken', [User, Token<TokenDocument<Scene>>, boolean]>;
  type HookParamsUpdate<T extends foundry.abstract.Document, N extends string> = HookParameters<
    `update${N}`,
    [T, Record<string, unknown>, DocumentModificationContext<T['parent']>]
  >;
  type HookParamsUpdateWorldTime = HookParameters<'updateWorldTime', [number, number]>;

  class Hooks {
    /**
     * Register a callback handler which should be triggered when a hook is triggered.
     *
     * @param hook The unique name of the hooked event
     * @param fn   The callback function which should be triggered when the hook event occurs
     */
    static on(...args: HookParamsSetup): number;
    static on(...args: HookParamsInit): number;
    static on(...args: HookParamsReady): number;
    static on(...args: HookParamsI18nInit): number;
    static on(...args: HookParamsCanvasInit): number;
    static on(...args: HookParamsCanvasReady): number;
    static on(...args: HookParamsClose<CombatTrackerConfig, 'CombatTrackerConfig'>): number;
    static on(...args: HookParamsDropCanvasData): number;
    static on(...args: HookParamsGetChatLogEntryContext): number;
    static on(...args: HookParamsGetSceneControlButtons): number;
    static on(...args: HookParamsHotbarDrop): number;
    static on(...args: HookParamsLightingRefresh): number;
    static on(...args: HookParamsPreCreateItem): number;
    static on(...args: HooksParamsPreUpdateCombat): number;
    static on(...args: HookParamsPreUpdateToken): number;
    static on(...args: HookParamsRenderChatMessage): number;
    static on(...args: HookParamsRender<ChatLog, 'ChatLog'>): number;
    static on(...args: HookParamsRender<ChatPopout, 'ChatPopout'>): number;
    static on(...args: HookParamsRender<CombatTrackerConfig, 'CombatTrackerConfig'>): number;
    static on(...args: HookParamsRender<CompendiumDirectory, 'CompendiumDirectory'>): number;
    static on(...args: HookParamsRender<Dialog, 'Dialog'>): number;
    static on(...args: HookParamsRender<ActorDirectory<Actor<null>>, 'ActorDirectory'>): number;
    static on(...args: HookParamsRender<ItemDirectory<Item<null>>, 'ItemDirectory'>): number;
    static on(...args: HookParamsRender<SceneControls, 'SceneControls'>): number;
    static on(...args: HookParamsRender<Settings, 'Settings'>): number;
    static on(...args: HookParamsRender<TokenHUD, 'TokenHUD'>): number;
    static on(
      ...args: HookParamsRender<JournalPageSheet<JournalEntryPage<JournalEntry | null>>, 'JournalPageSheet'>
    ): number;
    static on(
      ...args: HookParamsRender<JournalTextPageSheet<JournalEntryPage<JournalEntry | null>>, 'JournalTextPageSheet'>
    ): number;
    static on(...args: HookParamsTargetToken): number;
    static on(...args: HookParamsUpdate<Combat, 'Combat'>): number;
    static on(...args: HookParamsUpdate<Scene, 'Scene'>): number;
    static on(...args: HookParamsUpdateWorldTime): number;
    static on(...args: HookParameters<string, unknown[]>): number;

    /**
     * Register a callback handler for an event which is only triggered once the first time the event occurs.
     * After a "once" hook is triggered the hook is automatically removed.
     *
     * @param hook  The unique name of the hooked event
     * @param fn    The callback function which should be triggered when the hook event occurs
     */
    static once(...args: HookParamsSetup): number;
    static once(...args: HookParamsInit): number;
    static once(...args: HookParamsReady): number;
    static once(...args: HookParamsCanvasInit): number;
    static once(...args: HookParamsCanvasReady): number;
    static once(...args: HookParamsClose<CombatTrackerConfig, 'CombatTrackerConfig'>): number;
    static once(...args: HookParamsDropCanvasData): number;
    static once(...args: HookParamsGetChatLogEntryContext): number;
    static once(...args: HookParamsGetSceneControlButtons): number;
    static once(...args: HookParamsHotbarDrop): number;
    static once(...args: HookParamsLightingRefresh): number;
    static once(...args: HookParamsPreCreateItem): number;
    static once(...args: HookParamsPreUpdateToken): number;
    static once(...args: HookParamsRenderChatMessage): number;
    static once(...args: HookParamsRender<ActorDirectory<Actor<null>>, 'ActorDirectory'>): number;
    static once(...args: HookParamsRender<ChatLog, 'ChatLog'>): number;
    static once(...args: HookParamsRender<ChatPopout, 'ChatPopout'>): number;
    static once(...args: HookParamsRender<CombatTrackerConfig, 'CombatTrackerConfig'>): number;
    static once(...args: HookParamsRender<CompendiumDirectory, 'CompendiumDirectory'>): number;
    static once(...args: HookParamsRender<Dialog, 'Dialog'>): number;
    static once(...args: HookParamsRender<ItemDirectory<Item<null>>, 'ItemDirectory'>): number;
    static once(
      ...args: HookParamsRender<JournalPageSheet<JournalEntryPage<JournalEntry | null>>, 'JournalPageSheet'>
    ): number;
    static once(
      ...args: HookParamsRender<JournalTextPageSheet<JournalEntryPage<JournalEntry | null>>, 'JournalTextPageSheet'>
    ): number;
    static once(...args: HookParamsRender<SceneControls, 'SceneControls'>): number;
    static once(...args: HookParamsRender<Settings, 'Settings'>): number;
    static once(...args: HookParamsRender<TokenHUD, 'TokenHUD'>): number;
    static once(...args: HookParamsTargetToken): number;
    static once(...args: HookParamsUpdate<Combat, 'Combat'>): number;
    static once(...args: HookParamsUpdate<Scene, 'Scene'>): number;
    static once(...args: HookParamsUpdateWorldTime): number;
    static once(...args: HookParamsI18nInit): number;
    static once(...args: HookParameters<string, unknown[]>): number;

    /**
     * Unregister a callback handler for a particular hook event
     *
     * @param hook  The unique name of the hooked event
     * @param fn    The function that should be removed from the set of hooked callbacks
     */
    static off(hook: string, fn: Function): void;

    /**
     * Call all hook listeners in the order in which they were registered
     * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
     *
     * @param hook  The hook being triggered
     * @param args  Arguments passed to the hook callback functions
     */
    static callAll(hook: string, ...args: unknown[]): boolean;

    /**
     * Call hook listeners in the order in which they were registered.
     * Continue calling hooks until either all have been called or one returns `false`.
     *
     * Hook listeners which return `false` denote that the original event has been adequately handled and no further
     * hooks should be called.
     *
     * @param hook  The hook being triggered
     * @param args  Arguments passed to the hook callback functions
     */
    static call(hook: string, ...args: unknown[]): boolean;
  }

  interface DropCanvasData<T extends string = string, D extends object = object> {
    type?: T;
    data?: D extends foundry.abstract.Document ? D['_source'] : D;
    uuid?: DocumentUUID;
    id?: string;
    pack?: string;
    x: number;
    y: number;
    documentName?: string;
    actorId?: string;
    tokenId?: string;
  }
}

/**
 * @ignore
 */
declare class ClientBaseModule extends BaseModule {
  /**
   * Is this package marked as a favorite?
   * This boolean is currently only populated as true in the /setup view of the software.
   */
  favorite: boolean;

  /** Associate package availability with certain badge for client-side display. */
  getVersionBadge(): PackageCompatibilityBadge | null;

  /**
   * Determine a version badge for the provided compatibility data.
   * @param availability The availability level.
   * @param data         The compatibility data.
   */
  static getVersionBadge(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
  ): PackageCompatibilityBadge | null;

  /**
   * List missing dependencies and format them for display.
   * @param availability The availability value.
   * @param data         The compatibility data.
   * @param deps         The dependencies to format.
   */
  protected static _formatBadDependenciesTooltip(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
    deps: Iterable<RelatedPackage>,
  ): string;

  /** When a package has been installed, add it to the local game data. */
  install(): void;

  /** When a package has been uninstalled, remove it from the local game data. */
  uninstall(): void;

  /**
   * Remove a package from the local game data when it has been uninstalled.
   * @param id The package ID.
   */
  static uninstall(id: string): void;

  /**
   * Retrieve the latest Package manifest from a provided remote location.
   * @param manifest A remote manifest URL to load
   * @param options  Additional options which affect package construction
   * @param [options.strict=true]   Whether to construct the remote package strictly
   * @returns A Promise which resolves to a constructed ServerPackage instance
   * @throws An error if the retrieved manifest data is invalid
   */
  static fromRemoteManifest<T extends BasePackage<BasePackageSchema>>(
    this: ConstructorOf<T>,
    manifest: string,
    options?: { strict?: boolean },
  ): Promise<T | null>;
}

/**
 * @ignore
 */
declare class ClientBaseSystem extends BaseSystem {
  /**
   * Is this package marked as a favorite?
   * This boolean is currently only populated as true in the /setup view of the software.
   */
  favorite: boolean;

  /** Associate package availability with certain badge for client-side display. */
  getVersionBadge(): PackageCompatibilityBadge | null;

  /**
   * Determine a version badge for the provided compatibility data.
   * @param availability The availability level.
   * @param data         The compatibility data.
   */
  static getVersionBadge(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
  ): PackageCompatibilityBadge | null;

  /**
   * List missing dependencies and format them for display.
   * @param availability The availability value.
   * @param data         The compatibility data.
   * @param deps         The dependencies to format.
   */
  protected static _formatBadDependenciesTooltip(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
    deps: Iterable<RelatedPackage>,
  ): string;

  /** When a package has been installed, add it to the local game data. */
  install(): void;

  /** When a package has been uninstalled, remove it from the local game data. */
  uninstall(): void;

  /**
   * Remove a package from the local game data when it has been uninstalled.
   * @param id The package ID.
   */
  static uninstall(id: string): void;

  /**
   * Retrieve the latest Package manifest from a provided remote location.
   * @param manifest A remote manifest URL to load
   * @param options  Additional options which affect package construction
   * @param [options.strict=true]   Whether to construct the remote package strictly
   * @returns A Promise which resolves to a constructed ServerPackage instance
   * @throws An error if the retrieved manifest data is invalid
   */
  static fromRemoteManifest<T extends BasePackage<BasePackageSchema>>(
    this: ConstructorOf<T>,
    manifest: string,
    options?: { strict?: boolean },
  ): Promise<T | null>;
}

/**
 * @ignore
 */
declare class ClientBaseWorld extends BaseWorld {
  /**
   * Is this package marked as a favorite?
   * This boolean is currently only populated as true in the /setup view of the software.
   */
  favorite: boolean;

  /** Associate package availability with certain badge for client-side display. */
  getVersionBadge(): PackageCompatibilityBadge | null;

  /**
   * Determine a version badge for the provided compatibility data.
   * @param availability The availability level.
   * @param data         The compatibility data.
   */
  static getVersionBadge(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
  ): PackageCompatibilityBadge | null;

  /**
   * List missing dependencies and format them for display.
   * @param availability The availability value.
   * @param data         The compatibility data.
   * @param deps         The dependencies to format.
   */
  protected static _formatBadDependenciesTooltip(
    availability: PackageAvailabilityCode,
    data: Partial<PackageManifestData>,
    deps: Iterable<RelatedPackage>,
  ): string;

  /** When a package has been installed, add it to the local game data. */
  install(): void;

  /** When a package has been uninstalled, remove it from the local game data. */
  uninstall(): void;

  /**
   * Remove a package from the local game data when it has been uninstalled.
   * @param id The package ID.
   */
  static uninstall(id: string): void;

  /**
   * Retrieve the latest Package manifest from a provided remote location.
   * @param manifest A remote manifest URL to load
   * @param options  Additional options which affect package construction
   * @param [options.strict=true]   Whether to construct the remote package strictly
   * @returns A Promise which resolves to a constructed ServerPackage instance
   * @throws An error if the retrieved manifest data is invalid
   */
  static fromRemoteManifest<T extends BasePackage<BasePackageSchema>>(
    this: ConstructorOf<T>,
    manifest: string,
    options?: { strict?: boolean },
  ): Promise<T | null>;
}

interface PackageCompatibilityBadge {
  /** A type in "safe", "unsafe", "warning", "neutral" applied as a CSS class */
  type: 'safe' | 'unsafe' | 'warning' | 'neutral';
  /** A tooltip string displayed when hovering over the badge */
  tooltip: string;
  /** An optional text label displayed in the badge */
  label?: string;
  /** An optional icon displayed in the badge */
  icon?: string;
}

declare global {
  /**
   * @category Packages
   */
  class Module extends ClientBaseModule {
    readonly active: boolean;

    constructor(data: SourceFromSchema<BaseModule['schema']['fields']>, options?: DataModelConstructionOptions<null>);
  }

  /**
   * @category Packages
   */
  class System extends ClientBaseSystem {}

  /**
   * @category  Packages
   */
  class World extends ClientBaseWorld {
    static override getVersionBadge(
      availability: PackageAvailabilityCode,
      data: Partial<PackageManifestData>,
    ): PackageCompatibilityBadge | null;

    /** Provide data for a system badge displayed for the world which reflects the system ID and its availability */
    getSystemBadge(): PackageCompatibilityBadge | null;

    protected static override _formatBadDependenciesTooltip(
      availability: PackageAvailabilityCode,
      data: Partial<PackageManifestData>,
      deps: Iterable<RelatedPackage>,
    ): string;
  }

  /** A mapping of allowed package types and the classes which implement them. */
  const PACKAGE_TYPES: {
    world: World;
    system: System;
    module: Module;
  };
}

declare global {
  interface ClientSettingsStorage extends Map<string, Storage | WorldSettingsStorage> {
    get(key: 'client'): Storage;
    get(key: 'world'): WorldSettingsStorage;
  }

  /**
   * An abstract interface for defining setting storage patterns
   * Each setting is a key/value pair
   */
  class ClientSettings {
    /** An object of registered game settings for this scope */
    settings: ClientSettingsMap;

    /** Registered settings menus which trigger secondary applications */
    menus: Map<string, { type: SettingsMenuConstructor }>;

    /**
     * The storage interfaces used for persisting settings
     * Each storage interface shares the same API as window.localStorage
     */
    storage: ClientSettingsStorage;

    constructor(worldSettings: SettingConfig);

    /** Return a singleton instance of the Game Settings Configuration app */
    get sheet(): SettingsConfig;

    /**
     * Register a new game setting under this setting scope
     *
     * @param module   The namespace under which the setting is registered
     * @param key      The key name for the setting under the namespace module
     * @param data     Configuration for setting data
     *
     * @example
     * // Register a client setting
     * game.settings.register("myModule", "myClientSetting", {
     *   name: "Register a Module Setting with Choices",
     *   hint: "A description of the registered setting and its behavior.",
     *   scope: "client",     // This specifies a client-stored setting
     *   config: true,        // This specifies that the setting appears in the configuration view
     *   type: String,
     *   choices: {           // If choices are defined, the resulting setting will be a select menu
     *     "a": "Option A",
     *     "b": "Option B"
     *   },
     *   default: "a",        // The default value for the setting
     *   onChange: value => { // A callback function which triggers when the setting is changed
     *     console.log(value)
     *   }
     * });
     *
     * @example
     * // Register a world setting
     * game.settings.register("myModule", "myWorldSetting", {
     *   name: "Register a Module Setting with a Range slider",
     *   hint: "A description of the registered setting and its behavior.",
     *   scope: "world",      // This specifies a world-level setting
     *   config: true,        // This specifies that the setting appears in the configuration view
     *   type: Number,
     *   range: {             // If range is specified, the resulting setting will be a range slider
     *     min: 0,
     *     max: 100,
     *     step: 10
     *   }
     *   default: 50,         // The default value for the setting
     *   onChange: value => { // A callback function which triggers when the setting is changed
     *     console.log(value)
     *   }
     * });
     */
    register<TChoices extends Record<string, unknown> | undefined>(
      module: string,
      key: string,
      data: SettingRegistration<TChoices>,
    ): void;

    /**
     * Register a new sub-settings menu
     *
     * @param module   The namespace under which the menu is registered
     * @param key      The key name for the setting under the namespace module
     * @param data     Configuration for setting data
     *
     * @example
     * // Define a settings submenu which handles advanced configuration needs
     * game.settings.registerMenu("myModule", "mySettingsMenu", {
     *   name: "My Settings Submenu",
     *   label: "Settings Menu Label",      // The text label used in the button
     *   hint: "A description of what will occur in the submenu dialog.",
     *   icon: "fas fa-bars",               // A Font Awesome icon used in the submenu button
     *   type: MySubmenuApplicationClass,   // A FormApplication subclass which should be created
     *   restricted: true                   // Restrict this submenu to gamemaster only?
     * });
     */
    registerMenu(module: string, key: string, data: SettingSubmenuConfig): void;

    /**
     * Get the value of a game setting for a certain module and setting key
     * @param module    The module namespace under which the setting is registered
     * @param key       The setting key to retrieve
     */
    get(module: 'core', key: 'compendiumConfiguration'): Record<string, { private: boolean; locked: boolean }>;
    get(module: 'core', key: 'defaultToken'): Partial<foundry.data.PrototypeTokenSource>;
    get(module: 'core', key: 'fontSize'): number;
    get(module: 'core', key: 'noCanvas'): boolean;
    get(module: 'core', key: 'rollMode'): RollMode;
    get(module: string, key: string): unknown;

    /**
     * Get the value of a game setting for a certain module and setting key
     * @param module    The module namespace under which the setting is registered
     * @param key   The setting key to retrieve
     * @param value The data to assign to the setting key
     */
    set(module: string, key: string, value: unknown): Promise<unknown>;
  }

  interface SettingRegistration<
    TChoices extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,
  > extends Omit<SettingConfig<TChoices>, 'config' | 'key' | 'namespace' | 'scope'> {
    config?: boolean;
    scope?: 'client' | 'world';
  }

  interface ClientSettingsMap extends Map<string, SettingConfig> {
    get(key: 'core.chatBubblesPan'): SettingConfig & { default: boolean };
    get(key: 'core.defaultToken'): SettingConfig & { default: PreCreate<foundry.data.PrototypeTokenSource> };
    get(key: 'core.notesDisplayToggle'): SettingConfig & { default: boolean };
  }

  /** A simple interface for World settings storage which imitates the API provided by localStorage */
  class WorldSettingsStorage extends Collection<Setting> {
    constructor(settings: object);

    getItem(key: string): string | null;

    setItem(key: string, value: unknown): void;
  }
}

declare global {
  class SocketInterface {
    /**
     * Standardize the way that socket messages are dispatched and their results are handled
     * @param eventName The socket event name being handled
     * @param request Data provided to the Socket event
     * @return A Promise which resolves to the SocketResponse
     */
    static dispatch(eventName: string, request: SocketRequest): Promise<SocketResponse>;

    /**
     * Handle an error returned from the database, displaying it on screen and in the console
     * @param err The provided Error message
     */
    protected static _handleError(err: Error): Error;
  }
}

/** The client-side database backend implementation which handles Document modification operations. */
declare global {
  class ClientDatabaseBackend extends DatabaseBackend {
    /* -------------------------------------------- */
    /*  Document Modification Operations            */
    /* -------------------------------------------- */

    protected override _getDocuments(
      documentClass: typeof Document$1,
      request: DatabaseBackendGetContext,
      user: User,
    ): Promise<CompendiumIndexData[] | Document$1[]>;

    protected override _createDocuments(
      documentClass: typeof Document$1,
      context: DatabaseBackendCreateContext<Document$1>,
      user: User,
    ): Promise<ClientDocument[]>;

    protected override _updateDocuments(
      documentClass: typeof Document$1,
      context: DatabaseBackendUpdateContext<Document$1>,
      user: User,
    ): Promise<Document$1[]>;

    protected override _deleteDocuments(
      documentClass: typeof Document$1,
      context: DatabaseBackendDeleteContext,
      user: User,
    ): Promise<Document$1[]>;

    /* -------------------------------------------- */
    /*  Socket Workflows                            */
    /* -------------------------------------------- */

    /** Activate the Socket event listeners used to receive responses from events which modify database documents */
    activateSocketListeners(socket: Socket): void;

    /* -------------------------------------------- */
    /*  Helper Methods                              */
    /* -------------------------------------------- */

    override getFlagScopes(): string[];

    override getCompendiumScopes(): string[];
  }
}

declare global {
  /**
   * A singleton Collection of world-level Document objects within the Foundry Virtual Tabletop.
   * Each primary Document type has an associated subclass of WorldCollection which contains them.
   * @param data An array of data objects from which to create Document instances
   */
  abstract class WorldCollection<TDocument extends WorldDocument> extends DocumentCollection<TDocument> {
    constructor(data?: TDocument['_source'][]);

    /** The source data is, itself, a mapping of IDs to data objects */
    protected readonly _source: TDocument['_source'];

    /** An Array of application references which will be automatically updated when the collection content changes */
    apps: Application[];

    /**
     * Initialize the WorldCollection object by constructing its contained Document instances
     * @param data
     */
    protected _initialize(data: TDocument['_source'][]): void;

    /* -------------------------------------------- */
    /*  Directory Collection Mixin                  */
    /* -------------------------------------------- */

    /** The built tree structure of the DocumentCollection */
    get tree(): object;

    /** The current search mode for this collection */
    get searchMode(): 'full' | 'name';

    /** Toggle the search mode for this collection between "name" and "full" text search */
    toggleSearchMode(): void;

    /** The current sort mode used to order the top level entries in this collection */
    get sortingMode(): 'a' | 'm';

    /** Toggle the sorting mode for this collection between "a" (Alphabetical) and "m" (Manual by sort property) */
    toggleSortingMode(): void;

    /** The maximum depth of folder nesting which is allowed in this collection */
    get maxFolderDepth(): number;

    /** Return a reference to list of entries which are visible to the User in this tree */
    _getVisibleTreeContents(): TDocument[];

    initializeTree(): void;

    /** Sort two Entries by name, alphabetically. */
    static _sortAlphabetical(a: Document, b: Document): number;

    /** Sort two Entries using their numeric sort fields. */
    static _sortStandard(a: Document, b: Document): number;

    /* -------------------------------------------- */
    /*  Collection Properties                       */
    /* -------------------------------------------- */

    override get documentName(): string | null;

    /** The base Document type which is contained within this WorldCollection */
    static documentName: string | null;

    /** Reference the set of Folders which contain documents in this collection */
    get folders(): Collection<Folder>;

    /**
     * Return a reference to the SidebarDirectory application for this WorldCollection, or null if it has not yet
     * been created.
     */
    get directory(): DocumentDirectory<TDocument> | null;

    /** Return a reference to the singleton instance of this WorldCollection, or null if it has not yet been created. */
    static get instance(): WorldCollection<WorldDocument>;

    /* -------------------------------------------- */
    /*  Collection Methods                          */
    /* -------------------------------------------- */

    override set(id: string, document: TDocument): this;

    override delete(id: string): boolean;

    /**
     * Import a Document from a Compendium collection, adding it to the current World.
     * @param pack         The CompendiumCollection instance from which to import
     * @param id           The ID of the compendium entry to import
     * @param [updateData] Optional additional data used to modify the imported Document before it is created
     * @param [options]    Optional arguments passed to the Document.create method
     * @return The imported Document instance
     */
    importFromCompendium(
      pack: CompendiumCollection,
      id: string,
      updateData?: Record<string, unknown>,
      options?: DocumentModificationContext<null>,
    ): Promise<TDocument | null>;

    /**
     * Apply data transformations when importing a Document from a Compendium pack
     * @param document  The source Document, or a plain data object
     * @param [options] Additional options which modify how the document is imported
     * @param [options.addFlags=false]        Add flags which track the import source
     * @param [options.clearSort=true]        Clear the currently assigned folder and sort order
     * @param [options.clearPermissions=true] Clear document permissions
     * @param [options.keepId=false]          Retain the Document id from the source Compendium
     * @return The processed data ready for world Document creation
     */
    fromCompendium(document: TDocument | TDocument['_source'], options?: FromCompendiumOptions): TDocument['_source'];

    /* -------------------------------------------- */
    /*  Sheet Registration Methods                  */
    /* -------------------------------------------- */

    /**
     * Register a Document sheet class as a candidate which can be used to display Documents of a given type.
     * See {@link DocumentSheetConfig.registerSheet} for details.
     * @static
     * @param args Arguments forwarded to the DocumentSheetConfig.registerSheet method
     *
     * @example Register a new ActorSheet subclass for use with certain Actor types.
     * ```js
     * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character], makeDefault: true });
     * ```
     */
    static registerSheet(...args: DropFirst<Parameters<(typeof DocumentSheetConfig)['registerSheet']>>): void;

    /**
     * Unregister a Document sheet class, removing it from the list of available sheet Applications to use.
     * See {@link DocumentSheetConfig.unregisterSheet} for detauls.
     * @static
     * @param args Arguments forwarded to the DocumentSheetConfig.unregisterSheet method
     *
     * @example Deregister the default ActorSheet subclass to replace it with others.
     * ```js
     * Actors.unregisterSheet("core", ActorSheet);
     * ```
     */
    static unregisterSheet(...args: DropFirst<Parameters<(typeof DocumentSheetConfig)['unregisterSheet']>>): void;

    static get registeredSheets(): DocumentSheet[];
  }

  interface FromCompendiumOptions {
    addFlags?: boolean;
    clearSort?: boolean;
    clearPermissions?: boolean;
    keepId?: boolean;
  }
}

declare global {
  /**
   * A singleton Collection of Compendium-level Document objects within the Foundry Virtual Tabletop.
   * Each Compendium pack has its own associated instance of the CompendiumCollection class which contains its contents.
   * @param metadata The compendium metadata, an object provided by game.data
   */
  abstract class CompendiumCollection<
    TDocument extends CompendiumDocument = CompendiumDocument,
  > extends DocumentCollection<TDocument> {
    constructor(metadata: CompendiumMetadata<TDocument>, options?: ApplicationOptions);

    /** The compendium metadata which defines the compendium content and location */
    metadata: CompendiumMetadata<TDocument>;

    /** A subsidiary collection which contains the more minimal index of the pack */
    index: CompendiumIndex;

    /** A debounced function which will clear the contents of the Compendium pack if it is not accessed frequently. */
    protected _flush: () => unknown;

    /** Has this Compendium pack been fully indexed? */
    indexed: boolean;

    /**
     * The amount of time that Document instances within this CompendiumCollection are held in memory.
     * Accessing the contents of the Compendium pack extends the duration of this lifetime.
     */
    static CACHE_LIFETIME_SECONDS: number;

    /** The named game setting which contains Compendium configurations. */
    static CONFIG_SETTING: 'compendiumConfiguration';

    /** The default index fields which should be retrieved for each Compendium document type */
    static INDEX_FIELDS: Record<CompendiumDocumentType, string[]>;

    /**
     * Create a new Compendium Collection using provided metadata.
     * @param metadata The compendium metadata used to create the new pack
     * @param options  Additional options which modify the Compendium creation request
     */
    static createCompendium<T extends CompendiumDocument>(
      metadata: CompendiumMetadata<T>,
      options?: Record<string, unknown>,
    ): Promise<CompendiumCollection<T>>;

    /** The canonical Compendium name - comprised of the originating package and the pack name */
    get collection(): string;

    /** Access the compendium configuration data for this pack */
    get config(): Record<string, unknown>;

    override get documentName(): TDocument['documentName'];

    /** Track whether the Compendium Collection is locked for editing */
    get locked(): boolean;

    /** A convenience reference to the label which should be used as the title for the Compendium pack. */
    get title(): string;

    override get(key: string, options?: Record<string, unknown>): TDocument | undefined;

    override set(id: string, document: TDocument): this;

    override delete(id: string): boolean;

    /** Load the Compendium index and cache it as the keys and values of the Collection. */
    getIndex(options?: { fields: string[] }): Promise<CompendiumIndex>;

    /**
     * Get a single Document from this Compendium by ID.
     * The document may already be locally cached, otherwise it is retrieved from the server.
     * @param id The requested Document id
     * @returns The retrieved Document instance
     */
    getDocument(id: string): Promise<TDocument | undefined>;

    /**
     * Load multiple documents from the Compendium pack using a provided query object.
     * @param query A database query used to retrieve documents from the underlying database
     * @returns The retrieved Document instances
     */
    getDocuments(query?: Record<string, unknown>): Promise<TDocument[]>;

    /**
     * Import a Document into this Compendium Collection.
     * @param document The existing Document you wish to import
     * @return The imported Document instance
     */
    importDocument(document: TDocument): Promise<TDocument>;

    /**
     * Fully import the contents of a Compendium pack into a World folder.
     * @param [folderId]   An existing Folder _id to use.
     * @param [folderName] A new Folder name to create.
     * @param [options]    Additional options forwarded to Document.createDocuments
     * @return The imported Documents, now existing within the World
     */
    importAll({
      folderId,
      folderName,
      options,
    }?: {
      folderId?: string | null;
      folderName?: string;
      options?: Record<string, unknown>;
    }): Promise<TDocument[]>;

    /**
     * Add a Document to the index, capturing it's relevant index attributes
     * @param document The document to index
     */
    indexDocument(document: TDocument): void;

    /**
     * Assign configuration metadata settings to the compendium pack
     * @param settings The object of compendium settings to define
     * @return A Promise which resolves once the setting is updated
     */
    configure(settings?: Record<string, unknown>): Promise<void>;

    /**
     * Delete an existing world-level Compendium Collection.
     * This action may only be performed for world-level packs by a Gamemaster User.
     */
    deleteCompendium(): Promise<this>;

    /**
     * Duplicate a compendium pack to the current World.
     * @param label A new Compendium label
     */
    duplicateCompendium({ label }?: { label?: string }): Promise<this>;

    /** Validate that the current user is able to modify content of this Compendium pack */
    protected _assertUserCanModify(): boolean;

    /** Request that a Compendium pack be migrated to the latest System data template */
    migrate(options?: Record<string, unknown>): Promise<this>;

    testUserPermission(
      user: foundry.documents.BaseUser,
      permission: DocumentOwnershipString | DocumentOwnershipLevel,
      { exact }?: { exact?: boolean },
    ): boolean;

    protected override _onCreateDocuments(
      documents: TDocument[],
      result: TDocument['_source'][],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onUpdateDocuments(
      documents: TDocument[],
      result: TDocument['_source'][],
      options: DocumentUpdateContext<null>,
      userId: string,
    ): void;

    protected override _onDeleteDocuments(
      documents: TDocument[],
      result: string[],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    /** Follow-up actions taken when Documents within this Compendium pack are modified */
    protected _onModifyContents(
      documents: TDocument[],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;
  }

  type CompendiumDocumentType = (typeof CONST.COMPENDIUM_DOCUMENT_TYPES)[number];
  type CompendiumUUID = `Compendium.${string}.${string}` | `Compendium.${string}.${CompendiumDocumentType}.${string}`;
  type DocumentUUID = WorldDocumentUUID | CompendiumUUID | TokenDocumentUUID;

  function fromUuid(uuid: CompendiumUUID, relative?: Maybe<ClientDocument>): Promise<CompendiumDocument | null>;
  function fromUuid(
    uuid: ActorUUID,
    relative?: Maybe<ClientDocument>,
  ): Promise<Actor<TokenDocument<Scene> | null> | null>;
  function fromUuid(
    uuid: ItemUUID,
    relative?: Maybe<ClientDocument>,
  ): Promise<Item<Actor<TokenDocument<Scene> | null>> | null>;
  function fromUuid(uuid: TokenDocumentUUID, relative?: Maybe<ClientDocument>): Promise<TokenDocument<Scene> | null>;
  function fromUuid<TDocument extends ClientDocument>(
    uuid: string,
    relative?: Maybe<ClientDocument>,
  ): Promise<TDocument | null>;

  /**
   * Retrieve a Document by its Universally Unique Identifier (uuid) synchronously. If the uuid resolves to a compendium
   * document, that document's index entry will be returned instead.
   * @param uuid The uuid of the Document to retrieve.
   * @param {} [relative]  A document to resolve relative UUIDs against.
   * @returns The Document or its index entry if it resides in a Compendium, otherwise null.
   * @throws If the uuid resolves to a Document that cannot be retrieved synchronously.
   */
  function fromUuidSync(uuid: ItemUUID, relative?: Maybe<ClientDocument>): Item | CompendiumIndexData | null;
  function fromUuidSync<TDocument extends WorldDocument>(
    uuid: WorldDocumentUUID<TDocument>,
    relative?: Maybe<ClientDocument>,
  ): TDocument | null;
  function fromUuidSync<TDocument extends ClientDocument | CompendiumIndexData>(
    uuid: string,
    relative?: Maybe<ClientDocument>,
  ): TDocument | null;

  /**
   * Parse a UUID into its constituent parts.
   * @param uuid The UUID to parse.
   * @param relative A document to resolve relative UUIDs against.
   * @returns The Collection and the Document ID to resolve the parent document, as
   *          well as the remaining Embedded Document parts, if any.
   */
  function _parseUuid(uuid: string, relative?: foundry.abstract.Document): ResolvedUUID;

  interface ResolvedUUID {
    uuid?: string;
    /** The parent collection. */
    collection?: DocumentCollection<ClientDocument> | undefined;
    /** The parent document. */
    documentId?: string | undefined;
    /** The parent document type. */
    documentType?: string;
    /** An already-resolved document. */
    doc?: ClientDocument | null;
    /** Any remaining Embedded Document parts. */
    embedded: string[];
  }

  /**
   * Resolve a series of embedded document UUID parts against a parent Document.
   * @param parent The parent Document.
   * @param parts A series of Embedded Document UUID parts.
   * @returns The resolved Embedded Document.
   */
  function _resolveEmbedded(parent: ClientDocument, parts: string[]): ClientDocument | undefined;

  interface CompendiumMetadata<T extends CompendiumDocument = CompendiumDocument> {
    readonly type: T['documentName'];
    id: string;
    name: string;
    label: string;
    path: string;
    private?: string;
    package?: string;
    packageName: string;
    packageType: 'world' | 'system' | 'module';
    system: string;
  }

  interface CompendiumIndexData {
    _id: string;
    type: string;
    name: string;
    img: ImageFilePath;
    uuid: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [key: string]: any;
  }

  type CompendiumIndex = Collection<CompendiumIndexData>;

  type CompendiumDocument = Actor<null> | Cards | Item<null> | JournalEntry | Macro | Playlist | RollTable | Scene;
}

declare global {
  /**
   * The Collection of JournalEntry documents which exist within the active World.
   * This Collection is accessible within the Game object as game.journal.
   * @see {@link JournalEntry} The JournalEntry entity
   * @see {@link JournalDirectory} The JournalDirectory sidebar directory
   */
  class Journal extends WorldCollection<JournalEntry> {
    static override documentName: 'JournalEntry';

    /** Open Socket listeners which transact JournalEntry data */
    protected static _activateSocketListeners(socket: io.Socket): void;

    /**
     * Handle a received request to show a JournalEntry to the current client
     * @param entryId The ID of the journal entry to display for other players
     * @param mode    The JournalEntry mode to display
     * @param force   Display the entry to all players regardless of normal permissions
     */
    static _showEntry(entryId: string, mode?: string, force?: boolean): Promise<void>;
  }
}

declare global {
  /**
   * The Collection of Scene documents which exist within the active World.
   * This Collection is accessible within the Game object as game.scenes.
   */
  class Scenes<TScene extends Scene> extends WorldCollection<TScene> {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    static override documentName: 'Scene';

    /** Return a reference to the Scene which is currently active */
    get active(): TScene | undefined;

    /**
     * Return the current Scene target.
     * This is the viewed scene if the canvas is active, otherwise it is the currently active scene.
     */
    get current(): TScene | undefined;

    /**
     * Return a reference to the Scene which is currently viewed
     */
    get viewed(): TScene | undefined;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Handle pre-loading the art assets for a Scene
     * @param sceneId The Scene id to begin loading
     * @param push    Trigger other connected clients to also pre-load Scene resources
     */
    preload(sceneId: string, push?: boolean): Promise<void>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    /** @override */
    static _activateSocketListeners(socket: io.Socket): void;

    /** Augment the standard modifyDocument listener to flush fog exploration */
    protected static _resetFog(response: Record<string, unknown>): void;

    /** Handle requests pulling the current User to a specific Scene */
    static _pullToScene(sceneId: string): void;

    /* -------------------------------------------- */
    /*  Importing and Exporting                     */
    /* -------------------------------------------- */

    /** @override */
    fromCompendium(document: TScene): foundry.documents.SceneSource;
  }
}

declare global {
  /**
   * The Collection of User documents which exist within the active World.
   * This Collection is accessible within the Game object as game.users.
   * @see {@link User} The User entity
   * @see {@link UserDirectory} The UserDirectory sidebar directory
   */
  class Users<TUser extends User = User> extends WorldCollection<TUser> {
    constructor(data?: foundry.documents.UserSource[]);

    /** The User entity of the currently connected user */
    current: Active<TUser> | null;

    protected override _initialize(data: TUser['_source'][]): void;

    static override documentName: 'User';

    /** Get the users with player roles */
    get players(): TUser[];

    /**
     * Get one User who is an active Gamemaster, or null if no active GM is available.
     * This can be useful for workflows which occur on all clients, but where only one user should take action.
     */
    get activeGM(): TUser | null;

    /* -------------------------------------------- */
    /*  Socket Listeners and Handlers               */
    /* -------------------------------------------- */

    protected static _activateSocketListeners(socket: io.Socket): void;

    /**
     * Handle receipt of activity data from another User connected to the Game session
     * @param userId       The User id who generated the activity data
     * @param activityData The object of activity data
     */
    protected static _handleUserActivity(userId: string, activityData?: UserActivity): void;
  }
}

declare class ClientBaseAmbientLight<TParent extends ClientBaseScene | null> extends foundry.documents
  .BaseAmbientLight<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseAmbientLight<TParent extends ClientBaseScene | null> extends ClientBaseAmbientLight<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseAmbientSound<TParent extends ClientBaseScene | null> extends foundry.documents
  .BaseAmbientSound<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseAmbientSound<TParent extends ClientBaseScene | null> extends ClientBaseAmbientSound<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseActiveEffect<
  TParent extends
    | ClientBaseActor<CanvasBaseToken<ClientBaseScene | null> | null>
    | ClientBaseItem<ClientBaseActor<CanvasBaseToken<ClientBaseScene | null> | null> | null>
    | null,
> extends foundry.documents.BaseActiveEffect<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseActor<TParent extends CanvasBaseToken<ClientBaseScene | null> | null> extends foundry.documents
  .BaseActor<TParent> {
  protected _sheet: DocumentSheet<ClientBaseActor<CanvasBaseToken<ClientBaseScene | null> | null>> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<ClientBaseActor<CanvasBaseToken<ClientBaseScene | null> | null>>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseActorDelta<TParent extends CanvasBaseToken<ClientBaseScene | null> | null> extends foundry
  .documents.BaseActorDelta<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Orchestrate dispatching descendant document events to parent documents when embedded children are modified.
   * @param event      The event name, preCreate, onCreate, etc...
   * @param collection The collection name being modified within this parent document
   * @param args       Arguments passed to each dispatched function
   * @param [_parent]  The document with directly modified embedded documents. Either this document or a descendant
   *                   of this one.
   * @internal
   */
  protected _dispatchDescendantDocumentEvents(
    event: string,
    collection: string,
    args: unknown[],
    _parent?: foundry.abstract.Document,
  ): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseAdventure extends foundry.documents.BaseAdventure {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseCard<TParent extends ClientBaseCards | null> extends foundry.documents.BaseCard<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseCards extends foundry.documents.BaseCards {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseChatMessage extends foundry.documents.BaseChatMessage {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseCombat extends foundry.documents.BaseCombat {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseCombatant<TParent extends ClientBaseCombat | null> extends foundry.documents
  .BaseCombatant<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseDrawing<TParent extends ClientBaseScene | null> extends foundry.documents.BaseDrawing<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseDrawing<TParent extends ClientBaseScene | null> extends ClientBaseDrawing<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseFogExploration extends foundry.documents.BaseFogExploration {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): null;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseFolder extends foundry.documents.BaseFolder {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseItem<
  TParent extends ClientBaseActor<CanvasBaseToken<ClientBaseScene | null> | null> | null,
> extends foundry.documents.BaseItem<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this | undefined>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseJournalEntry extends foundry.documents.BaseJournalEntry {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseJournalEntryPage<TParent extends ClientBaseJournalEntry | null> extends foundry.documents
  .BaseJournalEntryPage<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseMacro extends foundry.documents.BaseMacro {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseMeasuredTemplate<TParent extends ClientBaseScene | null> extends foundry.documents
  .BaseMeasuredTemplate<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseMeasuredTemplate<
  TParent extends ClientBaseScene | null,
> extends ClientBaseMeasuredTemplate<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  /** System note: undocumented */
  locked?: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseNote<TParent extends ClientBaseScene | null> extends foundry.documents.BaseNote<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseNote<TParent extends ClientBaseScene | null> extends ClientBaseNote<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBasePlaylist extends foundry.documents.BasePlaylist {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBasePlaylistSound<TParent extends ClientBasePlaylist | null> extends foundry.documents
  .BasePlaylistSound<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseRollTable extends foundry.documents.BaseRollTable {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseScene extends foundry.documents.BaseScene {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseSetting extends foundry.documents.BaseSetting {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseTableResult<TParent extends ClientBaseRollTable | null> extends foundry.documents
  .BaseTableResult<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseTile<TParent extends ClientBaseScene | null> extends foundry.documents.BaseTile<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseTile<TParent extends ClientBaseScene | null> extends ClientBaseTile<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseToken<TParent extends ClientBaseScene | null> extends foundry.documents.BaseToken<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseToken<TParent extends ClientBaseScene | null> extends ClientBaseToken<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare class ClientBaseUser<TCharacter extends ClientBaseActor<null>> extends foundry.documents.BaseUser<TCharacter> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<null>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(data: this['_source'], options: DocumentModificationContext<null>, userId: string): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<null>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

declare class ClientBaseWall<TParent extends ClientBaseScene | null> extends foundry.documents.BaseWall<TParent> {
  protected _sheet: DocumentSheet<this> | null;

  /**
   * A collection of Application instances which should be re-rendered whenever this document is updated.
   * The keys of this object are the application ids and the values are Application instances. Each
   * Application in this object will have its render method called by {@link Document#render}.
   * @see {@link Document#render}
   */
  apps: { [K in number]?: Application };

  constructor(data: object, context?: DocumentConstructionContext<TParent>);

  static override name: string;

  protected override _initialize(options?: Record<string, unknown>): void;

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** Return a reference to the parent Collection instance which contains this Document. */
  get collection(): Collection<this>;

  /** A reference to the Compendium Collection which contains this Document, if any, otherwise undefined. */
  get compendium(): CompendiumCollection<CompendiumDocument> | undefined;

  /**
   * A boolean indicator for whether or not the current game User has ownership rights for this Document.
   * Different Document types may have more specialized rules for what constitutes ownership.
   */
  get isOwner(): boolean;

  /** Test whether this Document is owned by any non-Gamemaster User. */
  get hasPlayerOwner(): boolean;

  /** A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater). */
  get limited(): boolean;

  /** Return a string which creates a dynamic link to this Document instance. */
  get link(): string;

  /**
   * Return the permission level that the current game User has over this Document.
   * See the CONST.DOCUMENT_OWNERSHIP_LEVELS object for an enumeration of these levels.
   *
   * @example Get the permission level the current user has for a document
   * \`\`\`js
   * game.user.id; // "dkasjkkj23kjf"
   * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
   * actor.permission; // 2
   * \`\`\`
   */
  get permission(): DocumentOwnershipLevel;

  /** Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available. */
  get sheet(): DocumentSheet<this>;

  /** A Universally Unique Identifier (uuid) for this Document instance. */
  get uuid(): DocumentUUID;

  /**
   * A boolean indicator for whether the current game User has at least limited visibility for this Document.
   * Different Document types may have more specialized rules for what determines visibility.
   */
  get visible(): boolean;

  /* -------------------------------------------- */
  /*  Methods                                     */
  /* -------------------------------------------- */

  /** Obtain the FormApplication class constructor which should be used to configure this Document. */
  protected _getSheetClass(): Maybe<Function>;

  /**
   * Prepare data for the Document. This method is called automatically by the DataModel#_initialize workflow.
   * This method provides an opportunity for Document classes to define special data preparation logic.
   * The work done by this method should be idempotent. There are situations in which prepareData may be called more
   * than once.
   */
  prepareData(): void;

  /** Prepare data related to this Document itself, before any embedded Documents or derived data is computed. */
  prepareBaseData(): void;

  /**
   * Prepare all embedded Document instances which exist within this primary Document.
   * @memberof ClientDocumentMixin#
   */
  prepareEmbeddedDocuments(): void;

  /**
   * Apply transformations or derivations to the values of the source data object.
   * Compute data fields whose values are not stored to the database.
   */
  prepareDerivedData(): void;

  /**
   * Render all of the Application instances which are connected to this document by calling their respective
   * @see Application#render
   * @param [force=false] Force rendering
   * @param [context={}] Optional context
   */
  render(force?: boolean, context?: RenderOptions): void;

  /**
   * Determine the sort order for this Document by positioning it relative a target sibling.
   * See SortingHelper.performIntegerSort for more details
   * @param [options]            Sorting options provided to SortingHelper.performIntegerSort
   * @param [options.updateData] Additional data changes which are applied to each sorted document
   * @param [sortOptions]        Options which are passed to the SortingHelpers.performIntegerSort method
   * @returns The Document after it has been re-sorted
   */
  sortRelative({ updateData, ...sortOptions }: { updateData?: object } & SortingOptions<this>): Promise<void>;

  /**
   * Construct a UUID relative to another document.
   * @param doc The document to compare against.
   */
  getRelativeUUID(doc: foundry.abstract.Document): string;

  /**
   * Handle clicking on a content link for this document.
   * @param event    The triggering click event.
   */
  protected _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onUpdate(
    data: DeepPartial<this['_source']>,
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

  /**
   * Actions taken after descendant documents have been created, but before changes are applied to the client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents are being created
   * @param data       The source data for new documents that are being created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preCreateDescendantDocuments(
    parent: this,
    collection: string,
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been created and changes have been applied to client data.
   * @param parent     The direct parent of the created Documents, may be this Document or a child
   * @param collection The collection within which documents were created
   * @param documents  The array of created Documents
   * @param data       The source data for new documents that were created
   * @param options    Options which modified the creation operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onCreateDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    data: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated, but before changes are applied to the client data.
   * @param parent         The direct parent of the updated Documents, may be this Document or a child
   * @param collection       The collection within which documents are being updated
   * @param changes        The array of differential Document updates to be applied
   * @param options          Options which modified the update operation
   * @param userId           The ID of the User who triggered the operation
   */
  protected _preUpdateDescendantDocuments(
    parent: this,
    collection: string,
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been updated and changes have been applied to client data.
   * @param parent     The direct parent of the updated Documents, may be this Document or a child
   * @param collection The collection within which documents were updated
   * @param documents  The array of updated Documents
   * @param changes    The array of differential Document updates which were applied
   * @param options    Options which modified the update operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onUpdateDescendantDocuments(
    parent: this,
    collection: string,
    documents: ClientDocument[],
    changes: object[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted, but before deletions are applied to the client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _preDeleteDescendantDocuments(
    parent: this,
    collection: string,
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /**
   * Actions taken after descendant documents have been deleted and those deletions have been applied to client data.
   * @param parent     The direct parent of the deleted Documents, may be this Document or a child
   * @param collection The collection within which documents were deleted
   * @param documents  The array of Documents which were deleted
   * @param ids        The array of document IDs which were deleted
   * @param options    Options which modified the deletion operation
   * @param userId     The ID of the User who triggered the operation
   */
  protected _onDeleteDescendantDocuments(
    parent: this,
    collection: string,
    documents: foundry.abstract.Document[],
    ids: string[],
    options: DocumentModificationContext<this>,
    userId: string,
  ): void;

  /** Gets the default new name for a Document */
  static defaultName(): string;

  /* -------------------------------------------- */
  /*  Importing and Exporting                     */
  /* -------------------------------------------- */

  /**
   * Present a Dialog form to create a new Document of this type.
   * Choose a name and a type from a select menu of types.
   * @param [data]       Initial data with which to populate the creation form
   * @param [context={}] Additional context options or dialog positioning options
   * @returns A Promise which resolves to the created Document, or null if the dialog was closed.
   */
  static createDialog<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data?: Record<string, unknown>,
    context?: {
      parent?: TDocument['parent'];
      pack?: Collection<TDocument> | null;
    } & Partial<FormApplicationOptions>,
  ): Promise<TDocument | null>;

  /**
   * Present a Dialog form to confirm deletion of this Document.
   * @param [options] Positioning and sizing options for the resulting dialog
   * @return A Promise which resolves to the deleted Document
   */
  deleteDialog(options?: ConfirmDialogParameters): Promise<this>;

  /**
   * Export document data to a JSON file which can be saved by the client and later imported into a different session.
   * @param [options] Additional options passed to the {@link ClientDocumentMixin#toCompendium} method
   */
  exportToJSON(options?: Record<string, unknown>): void;

  /**
   * Create a content link for this Document.
   * @param [options] Additional options to configure how the link is constructed.
   * @param [options.attrs]   Attributes to set on the link.
   * @param [options.dataset] Custom data- attributes to set on the link.
   * @param [options.classes] Classes to add to the link.
   * @param [options.name]    A name to use for the Document, if different from the Document's name.
   * @param [options.icon]    A font-awesome icon class to use as the icon, if different to the Document's configured sidebarIcon.
   */
  toAnchor(options?: {
    attrs?: Record<string, string>;
    dataset?: Record<string, string>;
    classes?: string[];
    name?: string;
    icon?: string;
  }): HTMLAnchorElement;

  /**
   * Serialize salient information about this Document when dragging it.
   * @returns An object of drag data.
   */
  toDragData(): { type: string; [key: string]: unknown };

  /**
   * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
   * The dropped data could have:
   * 1. A data object explicitly provided
   * 2. A UUID
   *
   * @param data    The data object extracted from a DataTransfer event
   * @param options Additional options which affect drop data behavior
   * @returns The resolved Document
   * @throws If a Document could not be retrieved from the provided data.
   */
  static fromDropData<TDocument extends foundry.abstract.Document>(
    this: ConstructorOf<TDocument>,
    data: object,
    options?: Record<string, unknown>,
  ): Promise<TDocument | undefined>;

  /**
   * Update this Document using a provided JSON string.
   * @param json Raw JSON data to import
   * @returns The updated Document instance
   */
  importFromJSON(json: string): Promise<this>;

  /** Render an import dialog for updating the data related to this Document through an exported JSON file */
  importFromJSONDialog(): Promise<void>;

  /**
   * Transform the Document data to be stored in a Compendium pack.
   * Remove any features of the data which are world-specific.
   * @param [pack]    A specific pack being exported to
   * @param [options] Additional options which modify how the document is converted
   * @param [options.clearFlags=false]     Clear the flags object
   * @param [options.clearSort=true]       Clear the currently assigned folder and sort order
   * @param  [options.clearOwnership=true] Clear document ownership
   * @param [options.clearState=true]      Clear fields which store document state
   * @param [options.keepId=false]         Retain the current Document id
   * @returns A data object of cleaned data suitable for compendium import
   */
  toCompendium(
    pack?: CompendiumCollection<CompendiumDocument>,
    options?: {
      clearSort?: boolean;
      clearFlags?: boolean;
      clearOwnership?: boolean;
      clearState?: boolean;
      keepId?: boolean;
    },
  ): this['_source'];
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be
 * represented upon the game Canvas.
 * @category - Mixins
 */
declare class CanvasBaseWall<TParent extends ClientBaseScene | null> extends ClientBaseWall<TParent> {
  /** A reference to the PlaceableObject instance which represents this Embedded Document. */
  _object: PlaceableObject<this> | null;

  /** Has this object been deliberately destroyed as part of the deletion workflow? */
  protected _destroyed: boolean;

  constructor(data: object, context: DocumentConstructionContext<TParent>);

  /* -------------------------------------------- */
  /*  Properties                                  */
  /* -------------------------------------------- */

  /** A lazily constructed PlaceableObject instance which can represent this Document on the game canvas. */
  get object(): this['_object'];

  /** A reference to the CanvasLayer which contains Document objects of this type. */
  get layer(): NonNullable<this['object']>['layer'] | null;

  /** An indicator for whether this document is currently rendered on the game canvas. */
  get rendered(): boolean;

  /* -------------------------------------------- */
  /*  Event Handlers                              */
  /* -------------------------------------------- */

  /**
   * @see abstract.Document#_onCreate
   */
  protected override _onCreate(
    data: this['_source'],
    options: DocumentModificationContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onUpdate
   */
  protected override _onUpdate(
    changed: DeepPartial<this['_source']>,
    options: DocumentUpdateContext<TParent>,
    userId: string,
  ): void;

  /**
   * @see abstract.Document#_onDelete
   */
  protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}

declare global {
  /**
   * The ActiveEffect embedded document within an Actor or Item document which extends the BaseRollTable abstraction.
   * Each ActiveEffect belongs to the effects collection of its parent Document.
   * Each ActiveEffect contains a ActiveEffectData object which provides its source data.
   */
  class ActiveEffect<TParent extends Actor | Item | null>
    extends ClientBaseActiveEffect<TParent>
    implements TemporaryEffect
  {
    constructor(data: PreCreate<ActiveEffectSource>, context?: DocumentConstructionContext<TParent>);

    /** A cached reference to the source name to avoid recurring database lookups */
    protected _sourceName: string | null;

    /** A cached reference to the ActiveEffectConfig instance which configures this effect */
    protected override _sheet: ActiveEffectConfig<this> | null;

    /**
     * Format a round+turn combination as a decimal
     * @param round    The round number
     * @param turn     The turn number
     * @param [nTurns] The maximum number of turns in the encounter
     * @returns The decimal representation
     */
    protected _getCombatTime(round: number, turn: number, nTurns?: number): number;

    /**
     * Format a number of rounds and turns into a human-readable duration label
     * @param rounds The number of rounds
     * @param turns   The number of turns
     * @returns The formatted label
     */
    protected _getDurationLabel(rounds: number, turns: number): string;

    /** Describe whether the ActiveEffect has a temporary duration based on combat turns or rounds. */
    get isTemporary(): boolean;

    /** A cached property for obtaining the source name */
    get sourceName(): string;

    /**
     * An instance of the ActiveEffectConfig sheet to use for this ActiveEffect instance.
     * The reference to the sheet is cached so the same sheet instance is reused.
     */
    override get sheet(): ActiveEffectConfig<this>;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Apply this ActiveEffect to a provided Actor.
     * @param actor  The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    apply(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /**
     * Apply an ActiveEffect that uses an ADD application mode.
     * The way that effects are added depends on the data type of the current value.
     *
     * If the current value is null, the change value is assigned directly.
     * If the current type is a string, the change value is concatenated.
     * If the current type is a number, the change value is cast to numeric and added.
     * If the current type is an array, the change value is appended to the existing array if it matches in type.
     *
     * @param actor  The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    protected _applyAdd(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /**
     * Apply an ActiveEffect that uses a MULTIPLY application mode.
     * Changes which MULTIPLY must be numeric to allow for multiplication.
     * @param actor  The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    protected _applyMultiply(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /**
     * Apply an ActiveEffect that uses an OVERRIDE application mode.
     * Numeric data is overridden by numbers, while other data types are overridden by any value
     * @param actor The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    protected _applyOverride(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /**
     * Apply an ActiveEffect that uses an UPGRADE, or DOWNGRADE application mode.
     * Changes which UPGRADE or DOWNGRADE must be numeric to allow for comparison.
     * @param actor The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    protected _applyUpgrade(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /**
     * Apply an ActiveEffect that uses a CUSTOM application mode.
     * @param actor  The Actor to whom this effect should be applied
     * @param change The change data being applied
     * @return The resulting applied value
     */
    protected _applyCustom(actor: Actor<TokenDocument>, change: ActiveEffectSource['changes'][number]): unknown;

    /** Get the name of the source of the Active Effect */
    protected _getSourceName(): Promise<string>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<TParent>,
      user: User,
    ): Promise<boolean | void>;
  }

  interface ActiveEffect<TParent extends Actor | Item | null> extends ClientBaseActiveEffect<TParent> {
    duration: PreparedEffectDurationData;
  }

  interface PreparedEffectDurationData extends EffectDurationData {
    type: string;
    remaining?: string;
    label?: string;
  }

  interface TemporaryEffect extends ModelPropsFromSchema<ActiveEffectSchema> {
    isTemporary: boolean;
    duration: PreparedEffectDurationData;
  }
}

declare global {
  /**
   * The client-side Actor document which extends the common BaseActor model.
   *
   * @category - Documents
   *
   * @see {@link documents.Actors}            The world-level collection of Actor documents
   * @see {@link applications.ActorSheet}     The Actor configuration application
   *
   * @example Create a new Actor
   * ```js
   * let actor = await Actor.create({
   *   name: "New Test Actor",
   *   type: "character",
   *   img: "artwork/character-profile.jpg"
   * });
   * ```
   *
   * @example Retrieve an existing Actor
   * ```js
   * let actor = game.actors.get(actorId);
   * ```
   */
  class Actor<TParent extends TokenDocument | null = TokenDocument | null> extends ClientBaseActor<TParent> {
    /** An object that tracks which tracks the changes to the data model which were applied by active effects */
    overrides: Omit<DeepPartial<this['_source']>, 'prototypeToken'>;

    /** The statuses that are applied to this actor by active effects */
    statuses: Set<string>;

    /**
     * A cached array of image paths which can be used for this Actor's token.
     * Null if the list has not yet been populated.
     */
    protected _tokenImages: string[] | null;

    /** Cache the last drawn wildcard token to avoid repeat draws */
    protected _lastWildcard: string | null;

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** Provide a thumbnail image path used to represent this document. */
    get thumbnail(): this['img'];

    /** Provide an object which organizes all embedded Item instances by their type */
    get itemTypes(): object;

    /** Test whether an Actor is a synthetic representation of a Token (if true) or a full Document (if false) */
    get isToken(): boolean;

    /** Retrieve the list of ActiveEffects that are currently applied to this Actor. */
    get appliedEffects(): ActiveEffect<this>[];

    /** An array of ActiveEffect instances which are present on the Actor which have a limited duration. */
    get temporaryEffects(): TemporaryEffect[];

    /** Return a reference to the TokenDocument which owns this Actor as a synthetic override */
    get token(): TParent;

    /** Whether the Actor has at least one Combatant in the active Combat that represents it. */
    get inCombat(): boolean;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /** Apply any transformations to the Actor data which are caused by ActiveEffects. */
    applyActiveEffects(): void;

    /**
         * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
         * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
         * If the Actor is a synthetic token actor, only the exact Token which it represents will be returned.
         *
         * @param [linked=false]   Limit results to Tokens which are linked to the Actor. Otherwise return all Tokens,
                                   even those which are not linked.
         * @param [document=false] Return the Document instance rather than the PlaceableObject
         * @return An array of Token instances in the current Scene which reference this Actor.
         */
    getActiveTokens(linked: boolean | undefined, document: true): TokenDocument<Scene>[];
    getActiveTokens(linked?: boolean | undefined, document?: false): Token<TokenDocument<Scene>>[];
    getActiveTokens(linked?: boolean, document?: boolean): TokenDocument<Scene>[] | Token<TokenDocument<Scene>>[];

    /**
     * Get all ActiveEffects that may apply to this Actor.
     * If CONFIG.ActiveEffect.legacyTransferral is true, this is equivalent to actor.effects.contents.
     * If CONFIG.ActiveEffect.legacyTransferral is false, this will also return all the transferred ActiveEffects on any
     * of the Actor's owned Items.
     */
    allApplicableEffects(): Generator<ActiveEffect<this>, void, void>;

    /** Prepare a data object which defines the data schema used by dice roll commands against this Actor */
    getRollData(): Record<string, unknown>;

    /**
     * Create a new Token document, not yet saved to the database, which represents the Actor.
     * @param [data={}] Additional data, such as x, y, rotation, etc. for the created token data
     * @returns The created TokenDocument instance
     */
    getTokenDocument(data?: DeepPartial<foundry.documents.TokenSource>): Promise<NonNullable<TParent>>;

    /** Get an Array of Token images which could represent this Actor */
    getTokenImages(): Promise<(ImageFilePath | VideoFilePath)[]>;

    /**
     * Handle how changes to a Token attribute bar are applied to the Actor.
     * This allows for game systems to override this behavior and deploy special logic.
     * @param attribute The attribute path
     * @param value     The target attribute value
     * @param isDelta   Whether the number represents a relative change (true) or an absolute change (false)
     * @param isBar     Whether the new value is part of an attribute bar, or just a direct value
     * @return The updated Actor document
     */
    modifyTokenAttribute(attribute: string, value: number, isDelta?: boolean, isBar?: boolean): Promise<this>;

    override prepareEmbeddedDocuments(): void;

    /**
     * Roll initiative for all Combatants in the currently active Combat encounter which are associated with this Actor.
     * If viewing a full Actor entity, all Tokens which map to that actor will be targeted for initiative rolls.
     * If viewing a synthetic Token actor, only that particular Token will be targeted for an initiative roll.
     *
     * @param options Configuration for how initiative for this Actor is rolled.
     * @param [options.createCombatants=false] Create new Combatant entries for Tokens associated with this actor.
     * @param [options.rerollInitiative=false] Re-roll the initiative for this Actor if it has already been rolled.
     * @param [options.initiativeOptions={}]   Additional options passed to the Combat#rollInitiative method.
     * @return A promise which resolves to the Combat entity once rolls are complete.
     */
    rollInitiative(options?: {
      createCombatants?: boolean;
      rerollInitiative?: boolean;
      initiativeOptions?: object;
    }): Promise<Combat | null>;

    /**
     * Request wildcard token images from the server and return them.
     * @param actorId   The actor whose prototype token contains the wildcard image path.
     * @param [options]
     * @param [options.pack] The name of the compendium the actor is in.
     */
    protected static _requestTokenImages(
      actorId: string,
      options?: { pack?: string },
    ): Promise<(ImageFilePath | VideoFilePath)[]>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<TParent>,
      user: User,
    ): Promise<boolean | void>;

    /**
     * When an Actor is being created, apply default token configuration settings to its prototype token.
     * @param data    Data explicitly provided to the creation workflow
     * @param options Options which configure creation
     * @param [options.fromCompendium] Does this creation workflow originate via compendium import?
     */
    protected _applyDefaultTokenSettings(
      data: this['_source'],
      options?: { fromCompendium?: boolean },
    ): DeepPartial<this['_source']>;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentUpdateContext<TParent>,
      userId: string,
    ): void;

    protected override _onCreateDescendantDocuments(
      parent: this,
      collection: 'effects' | 'items',
      documents: ActiveEffect<this>[] | Item<this>[],
      result: ActiveEffect<this>['_source'][] | Item<this>['_source'][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onUpdateDescendantDocuments(
      parent: this,
      collection: 'effects' | 'items',
      documents: ActiveEffect<this>[] | Item<this>[],
      changes: ActiveEffect<this>['_source'][] | Item<this>['_source'][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    /** Additional workflows to perform when any descendant document within this Actor changes. */
    protected _onEmbeddedDocumentChange(): void;

    /**
     * Update the active TokenDocument instances which represent this Actor.
     * @param [update]  The update delta.
     * @param [options] The update context.
     */
    protected _updateDependentTokens(
      update?: Record<string, unknown>,
      options?: DocumentModificationContext<TParent>,
    ): void;
  }

  interface Actor<TParent extends TokenDocument | null = TokenDocument | null> extends ClientBaseActor<TParent> {
    readonly effects: foundry.abstract.EmbeddedCollection<ActiveEffect<this>>;
    readonly items: foundry.abstract.EmbeddedCollection<Item<this>>;

    get sheet(): ActorSheet<Actor>;

    get uuid(): ActorUUID;

    get folder(): Folder<Actor<null>> | null;
  }

  namespace Actor {
    const implementation: typeof Actor;
  }

  type CompendiumActorUUID = `Compendium.${string}.Actor.${string}`;
  type ActorUUID = `Actor.${string}` | `${TokenDocumentUUID}.Actor.${string}` | CompendiumActorUUID;
}

declare global {
  /**
   * The client-side ActorDelta embedded document which extends the common BaseActorDelta document model.
   * @see {@link TokenDocument}  The TokenDocument document type which contains ActorDelta embedded documents.
   * @todo Fill in
   */

  class ActorDelta<TParent extends TokenDocument | null> extends ClientBaseActorDelta<TParent> {
    syntheticActor?: NonNullable<NonNullable<TParent>['actor']> | undefined;

    protected override _configure(options?: { pack?: string | null; parentCollection?: string | null }): void;

    protected override _initialize({
      sceneReset,
      ...options
    }?: {
      sceneReset?: boolean;
      options?: Record<string, unknown>;
    }): void;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Apply this ActorDelta to the base Actor and return a synthetic Actor.
     * @param {object} [context]  Context to supply to synthetic Actor instantiation.
     * @returns {Actor|null}
     */
    apply(context?: Record<string, unknown>): NonNullable<TParent>['baseActor'];

    override prepareEmbeddedDocuments(): void;

    override updateSource(
      changes?: Record<string, unknown> | undefined,
      options?: DocumentSourceUpdateContext,
    ): DeepPartial<this['_source']>;

    override reset(): void;

    /**
     * Generate a synthetic Actor instance when constructed, or when the represented Actor, or actorLink status changes.
     * @param [options]
     * @param [options.reinitializeCollections]  Whether to fully re-initialize this ActorDelta's collections in
     *                                           order to re-retrieve embedded Documents from the synthetic Actor.
     * @internal
     */
    protected _createSyntheticActor(options?: { reinitializeCollections?: boolean }): void;

    /** Update the synthetic Actor instance with changes from the delta or the base Actor. */
    updateSyntheticActor(): void;

    /**
     * Restore this delta to empty, inheriting all its properties from the base actor.
     * @returns The restored synthetic Actor.
     */
    restore(): Promise<Actor<TParent>>;

    /**
     * Ensure that the embedded collection delta is managing any entries that have had their descendants updated.
     * @param doc  The parent whose immediate children have been modified.
     * @internal
     */
    protected _handleDeltaCollectionUpdates(doc: foundry.abstract.Document): void;

    /* -------------------------------------------- */
    /*  Database Operations                         */
    /* -------------------------------------------- */

    protected override _preDelete(options: DocumentModificationContext<TParent>, user: User): Promise<boolean | void>;

    protected override _onUpdate(
      data: DeepPartial<this['_source']>,
      options: DocumentModificationContext<TParent>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;

    protected override _dispatchDescendantDocumentEvents(
      event: string,
      collection: string,
      args: [object[], ...unknown[]],
      parent: ClientDocument | undefined,
    ): void;
  }
}

declare global {
  /**
   * The client-side Adventure document which extends the common {@link foundry.documents.BaseAdventure} model.
   *
   * ### Hook Events
   * {@link hookEvents.preImportAdventure} emitted by Adventure#import
   * {@link hookEvents.importAdventure} emitted by Adventure#import
   */
  class Adventure extends ClientBaseAdventure {
    /**
     * Perform a full import workflow of this Adventure.
     * Create new and update existing documents within the World.
     * @param [options] Options which configure and customize the import process
     * @param [options.dialog=true] Display a warning dialog if existing documents would be overwritten
     * @returns The import result
     */
    import(options?: { dialog?: boolean } & Record<string, unknown>): Promise<AdventureImportResult>;

    /**
     * Prepare Adventure data for import into the World.
     * @param [options] Options passed in from the import dialog to configure the import behavior.
     * @param [options.importFields]  A subset of adventure fields to import.
     */
    prepareImport(options?: { importFields?: string[] }): Promise<AdventureImportData>;

    /**
     * Execute an Adventure import workflow, creating and updating documents in the World.
     * @param Prepared adventure data to import
     * @returns The import result
     */
    importContent(data?: Partial<AdventureImportData>): AdventureImportResult;
  }

  interface AdventureImportData {
    /** Arrays of document data to create, organized by document name */
    toCreate: Record<string, object[]>;
    /** Arrays of document data to update, organized by document name */
    toUpdate: Record<string, object[]>;
    /** The total count of documents to import */
    documentCount: number;
  }

  interface AdventureImportResult {
    /** Documents created as a result of the import, organized by document name */
    created: foundry.abstract.Document[];
    /** Documents updated as a result of the import, organized by document name */
    updated: foundry.abstract.Document[];
  }
}

declare global {
  class AmbientLightDocument<TParent extends Scene | null> extends CanvasBaseAmbientLight<TParent> {
    /** Is this ambient light source global in nature? */
    get isGlobal(): boolean;
  }

  interface AmbientLightDocument<TParent extends Scene | null> extends CanvasBaseAmbientLight<TParent> {
    get object(): AmbientLight<this> | null;
  }
}

declare global {
  class AmbientSoundDocument<TParent extends Scene | null> extends CanvasBaseAmbientSound<TParent> {}

  interface AmbientSoundDocument<TParent extends Scene | null> extends CanvasBaseAmbientSound<TParent> {
    readonly _object: AmbientSound<this> | null;
  }
}

declare global {
  /**
   * The client-side Card document which extends the common BaseCard document model.
   * @extends documents.BaseCard
   * @mixes ClientDocumentMixin
   *
   * @see {@link Cards}                    The Cards document type which contains Card embedded documents
   * @see {@link CardConfig}               The Card configuration application
   */
  class Card<TParent extends Cards | null> extends ClientBaseCard<TParent> {
    /**
     * The current card face
     * @type {CardFaceData|null}
     */
    get currentFace(): foundry.documents.CardFaceData | null;

    /** The image of the currently displayed card face or back */
    get img(): this['img'];

    /** A reference to the source Cards document which defines this Card. */
    get source(): Cards | null;

    /**
     * A convenience property for whether the Card is within its source Cards stack. Cards in decks are always
     * considered home.
     */
    get isHome(): boolean;

    /** Whether to display the face of this card? */
    get showFace(): boolean;

    /**
     * Does this Card have a next face available to flip to?
     * @type {boolean}
     */
    get hasNextFace(): boolean;

    /**
     * Does this Card have a previous face available to flip to?
     * @type {boolean}
     */
    get hasPreviousFace(): boolean;

    /* -------------------------------------------- */
    /*  Core Methods                                */
    /* -------------------------------------------- */

    override prepareDerivedData(): void;

    /* -------------------------------------------- */
    /*  API Methods                                 */
    /* -------------------------------------------- */

    /**
     * Flip this card to some other face. A specific face may be requested, otherwise:
     * If the card currently displays a face the card is flipped to the back.
     * If the card currently displays the back it is flipped to the first face.
     * @param [face] A specific face to flip the card to
     * @returns A reference to this card after the flip operation is complete
     */
    flip(face: number | null): Promise<this>;

    /**
     * Pass this Card to some other Cards document.
     * @param {Cards} to                A new Cards document this card should be passed to
     * @param {object} [options={}]     Options which modify the pass operation
     * @param {object} [options.updateData={}]  Modifications to make to the Card as part of the pass operation,
     *                                  for example the displayed face
     * @returns {Promise<Card>}         A reference to this card after it has been passed to another parent document
     */
    pass(to: Cards, options?: { updateData?: Record<string, unknown> }): Promise<Card<Cards> | undefined>;

    /**
     * @alias Card#pass
     * @see Card#pass
     */
    play(to: Cards, options?: { updateData?: Record<string, unknown> }): Promise<Card<Cards> | undefined>;

    /**
     * @alias Card#pass
     * @see Card#pass
     */
    discard(to: Cards, options?: { updateData?: Record<string, unknown> }): Promise<Card<Cards> | undefined>;

    /**
     * Recall this Card to its original Cards parent.
     * @param {object} [options={}]   Options which modify the recall operation
     * @returns {Promise<Card>}       A reference to the recalled card belonging to its original parent
     */
    recall(options?: Record<string, unknown>): Promise<Card<Cards | null>>;

    /**
     * Create a chat message which displays this Card.
     * @param {object} [messageData={}] Additional data which becomes part of the created ChatMessageData
     * @param {object} [options={}]     Options which modify the message creation operation
     * @returns {Promise<ChatMessage>}  The created chat message
     */
    toMessage(
      messageData?: DeepPartial<foundry.documents.ChatMessageSource>,
      options?: ChatMessageModificationContext,
    ): Promise<ChatMessage | undefined>;
  }
}

declare global {
  /**
   * The client-side Cards document which extends the common BaseCards model.
   * Each Cards document contains CardsData which defines its data schema.
   *
   * @see {@link CardStacks}  The world-level collection of Cards documents
   * @see {@link CardsConfig} The Cards configuration application
   * @todo Fill in
   */
  class Cards extends ClientBaseCards {
    /** Provide a thumbnail image path used to represent this document. */
    get thumbnail(): this['img'];

    /** The Card documents within this stack which are available to be drawn. */
    get availableCards(): Card<this>[];

    /** The Card documents which belong to this stack but have already been drawn. */
    get drawnCards(): Card<this>[];

    /** Returns the localized Label for the type of Card Stack this is */
    get typeLabel(): string;

    /** Can this Cards document be cloned in a duplicate workflow? */
    get canClone(): boolean;
  }
}

declare global {
  /**
   * The client-side ChatMessage document which extends the common BaseChatMessage abstraction.
   * Each ChatMessage document contains ChatMessageData which defines its data schema.
   * @see {@link data.ChatMessageData} The ChatMessage data schema
   * @see {@link documents.Messages} The world-level collection of ChatMessage documents
   */
  class ChatMessage extends ClientBaseChatMessage {
    constructor(data: PreCreate<foundry.documents.ChatMessageSource>, context?: MessageConstructionContext);

    _rollExpanded: boolean;

    /**
     * Return the recommended String alias for this message.
     * The alias could be a Token name in the case of in-character messages or dice rolls.
     * Alternatively it could be a User name in the case of OOC chat or whispers.
     */
    get alias(): string;

    /** Is the current User the author of this message? */
    get isAuthor(): boolean;

    /**
     * Return whether the content of the message is visible to the current user.
     * For certain dice rolls, for example, the message itself may be visible while the content of that message is not.
     */
    get isContentVisible(): boolean;

    /** Test whether the chat message contains a dice roll */
    get isRoll(): boolean;

    /**
     * Return whether the ChatMessage is visible to the current User.
     * Messages may not be visible if they are private whispers.
     */
    override get visible(): boolean;

    override prepareData(): void;

    /**
     * Transform a provided object of ChatMessage data by applying a certain rollMode to the data object.
     * @param chatData The object of ChatMessage data prior to applying a rollMode preference
     * @param rollMode The rollMode preference to apply to this message data
     * @returns The modified ChatMessage data with rollMode preferences applied
     */
    static applyRollMode<TData extends DeepPartial<ChatMessage['_source']>>(
      chatData: TData,
      rollMode: RollMode | 'roll',
    ): TData;

    /**
     * Update the data of a ChatMessage instance to apply a requested rollMode
     * @param rollMode The rollMode preference to apply to this message data
     */
    applyRollMode(rollMode: RollMode | 'roll'): void;

    /**
     * Attempt to determine who is the speaking character (and token) for a certain Chat Message
     * First assume that the currently controlled Token is the speaker
     *
     * @param [scene] The Scene in which the speaker resides
     * @param [actor] The Actor whom is speaking
     * @param [token] The Token whom is speaking
     * @param [alias] The name of the speaker to display
     * @returns The identified speaker data
     */
    static getSpeaker({
      scene,
      actor,
      token,
      alias,
    }?: {
      scene?: Scene | null;
      actor?: Actor | null;
      token?: TokenDocument | null;
      alias?: string;
    }): foundry.documents.ChatSpeakerData;

    /** A helper to prepare the speaker object based on a target Token */
    protected static _getSpeakerFromToken({ token, alias }: { token: Token; alias?: string }): {
      scene: string;
      token: string;
      actor: string | null;
      alias: string;
    };
    /**
     * A helper to prepare the speaker object based on a target Actor
     * @private
     */
    protected static _getSpeakerFromActor({ scene, actor, alias }: { scene?: Scene; actor: Actor; alias?: string }): {
      scene: string | null;
      actor: string;
      token: null;
      alias: string;
    };

    /** A helper to prepare the speaker object based on a target User */
    protected static _getSpeakerFromUser({
      scene,
      user,
      alias,
    }: {
      scene?: Scene | null;
      user: User;
      alias?: string;
    }): {
      scene: string | null;
      actor: null;
      token: null;
      alias: string;
    };

    /**
     * Obtain an Actor instance which represents the speaker of this message (if any)
     * @param speaker The speaker data object
     */
    static getSpeakerActor(speaker: DeepPartial<foundry.documents.ChatSpeakerData>): Actor | null;

    /** Obtain a data object used to evaluate any dice rolls associated with this particular chat message */
    getRollData(): object;

    /**
     * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
     * @param name The target name of the whisper target
     * @return An array of User instances
     */
    static getWhisperRecipients(name: string): User[];

    /** Render the HTML for the ChatMessage which should be added to the log */
    getHTML(): Promise<JQuery>;

    /**
     * Render the inner HTML content for ROLL type messages.
     * @param messageData The chat message data used to render the message HTML
     */
    protected _renderRollContent(messageData: ChatMessageRenderData): Promise<void>;

    /**
     * Render HTML for the array of Roll objects included in this message.
     * @param  isPrivate Is the chat message private?
     * @returns The rendered HTML string
     */
    protected _renderRollHTML(isPrivate: boolean): Promise<string>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      user: BaseUser<BaseActor<null>>,
    ): Promise<boolean | void>;

    protected override _onCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

    /* -------------------------------------------- */
    /*  Importing and Exporting                     */
    /* -------------------------------------------- */

    /** Export the content of the chat message into a standardized log format */
    export(): string;
  }

  interface ChatMessage extends ClientBaseChatMessage {
    user: User;
  }

  namespace ChatMessage {
    function create<TDocument extends ChatMessage>(
      this: ConstructorOf<TDocument>,
      data: DeepPartial<Omit<TDocument['_source'], 'rolls'> & { rolls: (string | RollJSON)[] }>[],
      context?: ChatMessageModificationContext,
    ): Promise<TDocument[]>;
    function create<T extends ChatMessage>(
      this: ConstructorOf<T>,
      data: DeepPartial<Omit<T['_source'], 'rolls'> & { rolls: (string | RollJSON)[] }>,
      context?: ChatMessageModificationContext,
    ): Promise<T | undefined>;
    function create<T extends ChatMessage>(
      this: ConstructorOf<T>,
      data:
        | DeepPartial<Omit<T['_source'], 'rolls'> & { rolls: (string | RollJSON)[] }>[]
        | DeepPartial<Omit<T['_source'], 'rolls'> & { rolls: (string | RollJSON)[] }>,
      context?: ChatMessageModificationContext,
    ): Promise<T[] | T | undefined>;
  }

  interface MessageConstructionContext extends DocumentConstructionContext<null> {
    rollMode?: RollMode | 'roll';
  }

  interface ChatMessageRenderData {
    message: RawObject<ChatMessage>;
    user: User;
    author: User;
    alias: string;
    borderColor?: string;
    cssClass: string;
    isWhisper: number;
    canDelete: boolean;
    whisperTo: string;
  }
}

declare global {
  // Interfaces for ClientDocuments, given there is no common base with the generated intermediate classes
  interface ClientDocument extends foundry.abstract.Document {
    name?: string | null;

    get hasPlayerOwner(): boolean;
    get isOwner(): boolean;
    get sheet(): FormApplication;
    get uuid(): DocumentUUID;
  }

  interface CanvasDocument extends ClientDocument {
    readonly parent: ClientBaseScene | null;
    hidden?: boolean;
  }
}

declare global {
  /**
   * The Combat model definition which defines common behavior of an Combat document between both client and server.
   * Each Combat document contains CombatData which defines its data schema.
   * @param [data={}] Initial data provided to construct the Combat document
   */
  class Combat extends ClientBaseCombat {
    constructor(data: PreCreate<foundry.documents.CombatSource>, context?: DocumentConstructionContext<null>);

    /** Track the sorted turn order of this combat encounter */
    turns: CollectionValue<this['combatants']>[];

    /** Record the current round, turn, and tokenId to understand changes in the encounter state */
    current: CombatHistoryData;

    /** Track the previous round, turn, and tokenId to understand changes in the encounter state */
    previous: CombatHistoryData;

    /** The configuration setting used to record Combat preferences */
    static CONFIG_SETTING: 'combatTrackerConfig';

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** Get the Combatant who has the current turn. */
    get combatant(): CollectionValue<this['combatants']> | undefined;

    /** Return the object of settings which modify the Combat Tracker behavior */
    get settings(): Record<string, unknown>;

    /** Has this combat encounter been started? */
    get started(): boolean;

    override get visible(): true;

    /** Is this combat active in the current scene? */
    get isActive(): boolean;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Set the current Combat encounter as active within the Scene.
     * Deactivate all other Combat encounters within the viewed Scene and set this one as active
     */
    activate(): Promise<[this]>;

    /** Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker */
    endCombat(): Promise<this>;

    /**
     * Get a Combatant using its Token id
     * @param tokenId The id of the Token for which to acquire the combatant
     */
    getCombatantByToken(tokenId: string): Combatant<this> | undefined;

    /**
     * Get a Combatant using its Actor id
     * @param actorId The id of the Actor for which to acquire the combatant
     */
    getCombatantByActor(actorId: string): Combatant<this> | undefined;

    /** Advance the combat to the next round */
    nextRound(): Promise<this>;

    /** Advance the combat to the next turn */
    nextTurn(): Promise<this>;

    override prepareDerivedData(): void;

    /** Rewind the combat to the previous round */
    previousRound(): Promise<this>;

    /** Rewind the combat to the previous turn */
    previousTurn(): Promise<this>;

    /** Toggle whether this combat is linked to the scene or globally available. */
    toggleSceneLink(): Promise<this>;

    /** Reset all combatant initiative scores, setting the turn back to zero */
    resetAll(): Promise<this>;

    /**
     * Roll initiative for one or multiple Combatants within the Combat entity
     * @param ids A Combatant id or Array of ids for which to roll
     * @param [options={}] Additional options which modify how initiative rolls are created or presented.
     * @param [options.formula]           A non-default initiative formula to roll. Otherwise the system default is used.
     * @param [options.updateTurn=true]   Update the Combat turn after adding new initiative scores to keep the turn on the same Combatant.
     * @param [options.messageOptions={}] Additional options with which to customize created Chat Messages
     * @return A promise which resolves to the updated Combat entity once updates are complete.
     */
    rollInitiative(ids: string | string[], options?: RollInitiativeOptions): Promise<this>;

    /**
     * Roll initiative for all combatants which have not already rolled
     * @param [options={}] Additional options forwarded to the Combat.rollInitiative method
     */
    rollAll(options?: RollInitiativeOptions): Promise<this>;

    /**
     * Roll initiative for all non-player actors who have not already rolled
     * @param [options={}] Additional options forwarded to the Combat.rollInitiative method
     */
    rollNPC(options?: RollInitiativeOptions): Promise<this>;

    /**
     * Assign initiative for a single Combatant within the Combat encounter.
     * Update the Combat turn order to maintain the same combatant as the current turn.
     * @param id    The combatant ID for which to set initiative
     * @param value A specific initiative value to set
     */
    setInitiative(id: string, value: number): Promise<void>;

    /** Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name. */
    setupTurns(): Combatant<this>[];

    /** Begin the combat encounter, advancing to round 1 and turn 1 */
    startCombat(): Promise<this>;

    /**
     * Define how the array of Combatants is sorted in the displayed list of the tracker.
     * This method can be overridden by a system or module which needs to display combatants in an alternative order.
     * By default sort by initiative, next falling back to name, lastly tie-breaking by combatant id.
     */
    protected _sortCombatants(a: Combatant<this>, b: Combatant<this>): number;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _onCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

    protected override _onCreateDescendantDocuments(
      parent: this,
      collection: 'combatants',
      documents: Combatant<this>[],
      data: Combatant<this>['_source'][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onUpdateDescendantDocuments(
      parent: this,
      collection: 'combatants',
      documents: Combatant<this>[],
      changes: DeepPartial<Combatant<this>['_source']>[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onDeleteDescendantDocuments(
      parent: this,
      collection: 'combatants',
      documents: Combatant<this>[],
      ids: string[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    /* -------------------------------------------- */
    /*  Turn Events                                 */
    /* -------------------------------------------- */

    /**
     * Manage the execution of Combat lifecycle events.
     * This method orchestrates the execution of four events in the following order, as applicable:
     * 1. End Turn
     * 2. End Round
     * 3. Begin Round
     * 4. Begin Turn
     * Each lifecycle event is an async method, and each is awaited before proceeding.
     * @param [adjustedTurn]   Optionally, an adjusted turn to commit to the Combat.
     */
    protected _manageTurnEvents(adjustedTurn?: number): Promise<void>;

    /**
     * A workflow that occurs at the end of each Combat Turn.
     * This workflow occurs after the Combat document update, prior round information exists in this.previous.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @param combatant The Combatant whose turn just ended
     */
    protected _onEndTurn(combatant: Combatant<this>): Promise<void>;

    /**
     * A workflow that occurs at the end of each Combat Round.
     * This workflow occurs after the Combat document update, prior round information exists in this.previous.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     */
    protected _onEndRound(): Promise<void>;

    /**
     * A workflow that occurs at the start of each Combat Round.
     * This workflow occurs after the Combat document update, new round information exists in this.current.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     */
    protected _onStartRound(): Promise<void>;

    /**
     * A workflow that occurs at the start of each Combat Turn.
     * This workflow occurs after the Combat document update, new turn information exists in this.current.
     * This can be overridden to implement system-specific combat tracking behaviors.
     * This method only executes for one designated GM user. If no GM users are present this method will not be called.
     * @param combatant The Combatant whose turn just started
     */
    protected _onStartTurn(combatant: Combatant<this>): Promise<void>;
  }

  interface Combat extends ClientBaseCombat {
    readonly combatants: foundry.abstract.EmbeddedCollection<Combatant<this>>;
  }

  interface CombatHistoryData {
    round: number | null;
    turn: number | null;
    tokenId: string | null;
    combatantId: string | null;
  }

  interface RollInitiativeOptions {
    formula?: number | null;
    updateTurn?: boolean;
    messageOptions?: ChatMessageModificationContext;
  }
}

declare global {
  /**
   * The client-side Combatant document which extends the common BaseCombatant model.
   *
   * @see {@link Combat}                  The Combat document which contains Combatant embedded documents
   * @see {@link CombatantConfig}         The application which configures a Combatant.
   */
  class Combatant<
    TParent extends Combat | null,
    TTokenDocument extends TokenDocument | null = TokenDocument | null,
  > extends ClientBaseCombatant<TParent> {
    constructor(data: PreCreate<foundry.documents.CombatantSource>, context?: DocumentConstructionContext<TParent>);

    /** The current value of the special tracked resource which pertains to this Combatant */
    resource: { value: number } | null;

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**
     * This is treated as a non-player combatant if it has no associated actor and no player users who can control
     * it
     */
    get isNPC(): boolean;

    override get isOwner(): boolean;

    /** Is this Combatant entry currently visible in the Combat Tracker? */
    get isVisible(): boolean;

    /** A reference to the Actor document which this Combatant represents, if any */
    get actor(): NonNullable<TTokenDocument>['actor'];

    /** A reference to the Token document which this Combatant represents, if any */
    get token(): TTokenDocument;

    /** An array of User documents who have ownership of this Document */
    get players(): User[];

    /** Has this combatant been marked as defeated? */
    get isDefeated(): boolean;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override testUserPermission(
      user: User,
      permission: DocumentOwnershipString | DocumentOwnershipLevel,
      { exact }?: { exact?: boolean },
    ): boolean;

    /**
     * Get a Roll object which represents the initiative roll for this Combatant.
     * @param formula An explicit Roll formula to use for the combatant.
     * @return The Roll instance to use for the combatant.
     */
    getInitiativeRoll(formula: string): Roll;

    /**
     * Roll initiative for this particular combatant.
     * @param [formula] A dice formula which overrides the default for this Combatant.
     * @return The Roll instance to use for the combatant.
     */
    rollInitiative(formula: string): Rolled<Roll>;

    override prepareDerivedData(): void;

    /** Update the value of the tracked resource for this Combatant. */
    updateResource(): { value: number } | null;

    /**
     * Acquire the default dice formula which should be used to roll initiative for this combatant.
     * Modules or systems could choose to override or extend this to accommodate special situations.
     * @return The initiative formula to use for this combatant.
     */
    _getInitiativeFormula(): string;
  }

  interface Combatant<TParent extends Combat | null, TTokenDocument extends TokenDocument | null = TokenDocument | null>
    extends ClientBaseCombatant<TParent> {
    _sheet: CombatantConfig<this>;
  }
}

declare global {
  /**
   * The client-side Drawing document which extends the common BaseDrawing model.
   *
   * @see {@link Scene}               The Scene document type which contains Drawing embedded documents
   * @see {@link DrawingConfig}       The Drawing configuration application
   */
  class DrawingDocument<TParent extends Scene | null> extends CanvasBaseDrawing<TParent> {
    /** Define an elevation property on the Drawing Document which in the future will become a part of its data schema. */
    accessor elevation: number;

    /** A flag for whether the current User has full ownership over the Drawing document. */
    override get isOwner(): boolean;
  }

  interface DrawingDocument<TParent extends Scene | null> extends CanvasBaseDrawing<TParent> {
    readonly _object: Drawing<this> | null;
  }
}

declare global {
  /** The client-side FogExploration document which extends the common BaseFogExploration model. */
  class FogExploration extends ClientBaseFogExploration {
    /**
     * Obtain the fog of war exploration progress for a specific Scene and User.
     * @param [query] Parameters for which FogExploration document is retrieved
     * @param [query.scene] A certain Scene ID
     * @param [query.user]  A certain User ID
     * @param [options={}]  Additional options passed to DatabaseBackend#get
     */
    static get(
      query?: { scene?: string; user?: string },
      options?: Record<string, unknown>,
    ): Promise<FogExploration | null>;

    /** Transform the explored base64 data into a PIXI.Texture object */
    getTexture(): PIXI.Texture | null;

    protected override _onCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onUpdate(
      data: DeepPartial<this['_source']>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;
  }
}

declare global {
  /**
   * The client-side Folder document which extends the common BaseFolder model.
   *
   * @see {@link Folders}                     The world-level collection of Folder documents
   * @see {@link FolderConfig}                The Folder configuration application
   */
  class Folder<TDocument extends EnfolderableDocument = EnfolderableDocument> extends ClientBaseFolder {
    /** The depth of this folder in its sidebar tree */
    depth: number;

    /**
     * An array of other Folders which are the displayed children of this one. This differs from the results of
     * {@link Folder.getSubfolders} because reports the subset of child folders which  are displayed to the current User
     * in the UI.
     */
    children: Folder<TDocument>[];

    /** Return whether the folder is displayed in the sidebar to the current User. */
    displayed: boolean;

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /**
     * The array of the Document instances which are contained within this Folder,
     * unless it's a Folder inside a Compendium pack, in which case it's the array
     * of objects inside the index of the pack that are contained in this Folder.
     */
    get contents(): TDocument[];

    set contents(value: TDocument[]);

    /** Return a reference to the Document type which is contained within this Folder. */
    get documentClass(): ConstructorOf<TDocument>;

    /** Return a reference to the WorldCollection instance which provides Documents to this Folder. */
    get documentCollection(): WorldCollection<TDocument>;

    /** Return whether the folder is currently expanded within the sidebar interface. */
    get expanded(): boolean;

    /** Return the list of ancestors of this folder, starting with the parent. */
    get ancestors(): Folder<TDocument>[];

    /** A reference to the parent Folder if one is set, otherwise null. */
    get parentFolder(): this | null;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      user: User,
    ): Promise<boolean | void>;

    /**
     * Create a new Folder by rendering a dialog window to provide basic creation details
     * @param data Initial data with which to populate the creation form
     * @param options Initial positioning and sizing options for the dialog form
     * @return An active FolderConfig instance for creating the new Folder entity
     */
    static createDialog<TDocument extends foundry.abstract.Document>(
      this: ConstructorOf<TDocument>,
      data?: Record<string, unknown>,
      context?: {
        parent?: TDocument['parent'];
        pack?: Collection<TDocument> | null;
      } & Partial<FormApplicationOptions>,
    ): Promise<TDocument | null>;

    /**
     * Export all Documents contained in this Folder to a given Compendium pack.
     * Optionally update existing Documents within the Pack by name, otherwise append all new entries.
     * @param pack         A Compendium pack to which the entities will be exported
     * @param updateByName Update existing entries in the Compendium pack, matching by name
     * @return The updated Compendium Collection instance
     */
    exportToCompendium(
      pack: CompendiumCollection<TDocument>,
      { updateByName }?: { updateByName?: boolean },
    ): Promise<CompendiumCollection<TDocument>>;

    /**
     * Provide a dialog form that allows for exporting the contents of a Folder into an eligible Compendium pack.
     * @param pack    A pack ID to set as the default choice in the select input
     * @param options Additional options passed to the Dialog.prompt method
     * @return A Promise which resolves or rejects once the dialog has been submitted or closed
     */
    exportDialog(pack: string, options?: Record<string, unknown>): Promise<void>;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

    /**
     * Get the Folder documents which are sub-folders of the current folder, either direct children or recursively.
     * @param [recursive=false] Identify child folders recursively, if false only direct children are returned
     * @returns An array of Folder documents which are subfolders of this one
     */
    getSubfolders(recursive?: boolean): Folder<TDocument>[];

    /**
     * Get the Folder documents which are parent folders of the current folder or any if its parents.
     * @returns An array of Folder documents which are parent folders of this one
     */
    getParentFolders(): Folder<TDocument>[];
  }

  type EnfolderableDocument = Actor<null> | Item<null> | Macro | Scene | JournalEntry | RollTable;
}

declare global {
  /**
   * The client-side Item document which extends the common BaseItem model.
   *
   * @see {@link documents.Items}            The world-level collection of Item documents
   * @see {@link applications.ItemSheet}     The Item configuration application
   */
  class Item<TParent extends Actor | null = Actor | null> extends ClientBaseItem<TParent> {
    /** A convenience alias of Item#parent which is more semantically intuitive */
    get actor(): TParent;

    /** Provide a thumbnail image path used to represent this document. */
    get thumbnail(): this['img'];

    /** A convenience alias of Item#isEmbedded which is preserves legacy support */
    get isOwned(): boolean;

    /**
     * Return an array of the Active Effect instances which originated from this Item.
     * The returned instances are the ActiveEffect instances which exist on the Item itself.
     */
    get transferredEffects(): CollectionValue<this['effects']>[];

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /** Prepare a data object which defines the data schema used by dice roll commands against this Item */
    getRollData(): object;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<TParent>,
      user: User,
    ): Promise<boolean | void>;

    protected static override _onCreateDocuments<TDocument extends foundry.abstract.Document>(
      this: ConstructorOf<TDocument>,
      items: TDocument[],
      context: DocumentModificationContext<TDocument['parent']>,
    ): void;

    protected static override _onDeleteDocuments<TDocument extends foundry.abstract.Document>(
      this: ConstructorOf<TDocument>,
      items: TDocument[],
      context: DocumentModificationContext<TDocument['parent']>,
    ): void;
  }

  interface Item<TParent extends Actor | null = Actor | null> extends ClientBaseItem<TParent> {
    get uuid(): ItemUUID;
    get sheet(): ItemSheet<this, DocumentSheetOptions>;
  }

  namespace Item {
    const implementation: typeof Item;
  }

  type EmbeddedItemUUID = `Actor.${string}.Item.${string}`;
  type WorldItemUUID = WorldDocumentUUID<Item<null>>;
  type CompendiumItemUUID = `Compendium.${string}.Item.${string}`;
  type ItemUUID = WorldItemUUID | EmbeddedItemUUID | CompendiumItemUUID;
}

declare global {
  /**
   * The client-side JournalEntry document which extends the common BaseJournalEntry model.
   *
   * @see {@link Journal}                       The world-level collection of JournalEntry documents
   * @see {@link JournalSheet}                  The JournalEntry configuration application
   */
  class JournalEntry extends ClientBaseJournalEntry {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** A boolean indicator for whether or not the JournalEntry is visible to the current user in the directory sidebar */
    override get visible(): boolean;

    /**
     * Return a reference to the Note instance for this Journal Entry in the current Scene, if any.
     * If multiple notes are placed for this Journal Entry, only the first will be returned.
     */
    get sceneNote(): Note | null;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Show the JournalEntry to connected players.
     * By default the entry will only be shown to players who have permission to observe it.
     * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
     *
     * @param mode  Which JournalEntry mode to display? Default is text.
     * @param force Display the entry to all players regardless of normal permissions
     * @return A Promise that resolves back to the shown entry once the request is processed
     */
    show(mode?: string, force?: boolean): Promise<JournalEntry>;

    /**
     * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
     * The note will also be highlighted as if hovered upon by the mouse
     * @param [options={}] Options which modify the pan operation
     * @param [scale=1.5] The resulting zoom level
     * @param [duration=250] The speed of the pan animation in milliseconds
     * @return A Promise which resolves once the pan animation has concluded
     */
    panToNote({ scale, duration }?: { scale?: number; duration?: number }): Promise<void>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentUpdateContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;
  }

  interface JournalEntry extends ClientBaseJournalEntry {
    readonly pages: foundry.abstract.EmbeddedCollection<JournalEntryPage<this>>;

    get sheet(): JournalSheet<this>;
  }
}

declare global {
  /**
   * The client-side JournalEntryPage document which extends the common BaseJournalEntryPage document model.
   *
   * @see {@link JournalEntry}  The JournalEntry document type which contains JournalEntryPage embedded documents.
   */
  class JournalEntryPage<TParent extends JournalEntry | null> extends ClientBaseJournalEntryPage<TParent> {
    /** The table of contents for this JournalEntryPage. */
    get toc(): JournalEntryPageHeading;

    override get permission(): DocumentOwnershipLevel;

    /**
     * Return a reference to the Note instance for this Journal Entry Page in the current Scene, if any.
     * If multiple notes are placed for this Journal Entry, only the first will be returned.
     */
    get sceneNote(): Note | null;

    /* -------------------------------------------- */
    /*  Table of Contents                           */
    /* -------------------------------------------- */

    /**
     * Convert a heading into slug suitable for use as an identifier.
     * @param heading The heading element or some text content.
     */
    static slugifyHeading(heading: HTMLHeadingElement | string): string;

    /**
     * Build a table of contents for the given HTML content.
     * @param html      The HTML content to generate a ToC outline for.
     * @param [options] Additional options to configure ToC generation.
     * @param [options.includeElement=true] Include references to the heading DOM elements in the returned ToC.
     */
    static buildTOC(html: HTMLElement, options?: { includeElement?: boolean }): JournalEntryPageHeading;

    /**
     * Flatten the tree structure into a single object with each node's slug as the key.
     * @param nodes  The root ToC nodes.
     */
    protected static _flattenTOC(nodes: JournalEntryPageHeading[]): JournalEntryPageHeading;

    /**
     * Construct a table of contents node from a heading element.
     * @param heading   The heading element.
     * @param [options] Additional options to configure the returned node.
     * @param [options.includeElement=true] Whether to include the DOM element in the returned ToC node.
     */
    protected static _makeHeadingNode(
      heading: HTMLHeadElement,
      options?: { includeElement?: boolean },
    ): JournalEntryPageHeading;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    protected override _onClickDocumentLink(event: MouseEvent): Promise<this['sheet']>;

    protected override _onUpdate(
      data: DeepPartial<this['_source']>,
      options: DocumentModificationContext<TParent>,
      userId: string,
    ): void;
  }

  interface JournalEntryPage<TParent extends JournalEntry | null> extends ClientBaseJournalEntryPage<TParent> {
    get documentName(): 'JournalEntryPage';
    get sheet(): JournalPageSheet<this>;
  }

  interface JournalEntryPageHeading {
    /** The heading level, 1-6. */
    level: 1 | 2 | 3 | 4 | 5 | 6;
    /** The raw heading text with any internal tags omitted. */
    text: string;
    /** The generated slug for this heading. */
    slug: string;
    /** The currently rendered element for this heading, if it exists. */
    element?: HTMLHeadingElement;
    /** Any child headings of this one. */
    children: string[];
  }
}

declare global {
  /**
   * The client-side Folder document which extends the common BaseFolder model.
   *
   * @see {@link Folders}                     The world-level collection of Folder documents
   * @see {@link FolderConfig}                The Folder configuration application
   */
  class Macro extends ClientBaseMacro {
    /* -------------------------------------------- */
    /*  Model Properties                            */
    /* -------------------------------------------- */

    /** Is the current User the author of this macro? */
    get isAuthor(): boolean;

    /** Test whether the current user is capable of executing a Macro script */
    get canExecute(): boolean;

    /** Provide a thumbnail image path used to represent this document. */
    get thumbnail(): ImageFilePath;

    /* -------------------------------------------- */
    /*  Model Methods                               */
    /* -------------------------------------------- */

    /**
     * Execute the Macro command.
     * @param [scope={}]    Macro execution scope which is passed to script macros
     * @param [scope.actor] An Actor who is the protagonist of the executed action
     * @param [scope.token] A Token which is the protagonist of the executed action
     * @returns A created ChatMessage from chat macros or returned value from script macros
     */
    execute(scope?: { actor?: Actor; token?: Token }): unknown;
  }
}

declare global {
  /**
   * The client-side MeasuredTemplate document which extends the common BaseMeasuredTemplate document model.
   *
   * @see {@link Scene}                     The Scene document type which contains MeasuredTemplate documents
   * @see {@link MeasuredTemplateConfig}    The MeasuredTemplate configuration application
   */
  class MeasuredTemplateDocument<TParent extends Scene | null> extends CanvasBaseMeasuredTemplate<TParent> {
    /* -------------------------------------------- */
    /*  Model Properties                            */
    /* -------------------------------------------- */

    /** A reference to the User who created the MeasuredTemplate document. */
    get author(): User;

    /** Rotation is an alias for direction */
    get rotation(): number;
  }

  interface MeasuredTemplateDocument<TParent extends Scene | null> extends CanvasBaseMeasuredTemplate<TParent> {
    _sheet: MeasuredTemplateConfig<this> | null;
    _object: MeasuredTemplate<this> | null;
  }
}

declare global {
  /**
   * The client-side Note embedded document which extends the common BaseNote abstraction.
   * Each Note document contains NoteData which defines its data schema.
   * @see {@link data.NoteData}                 The Note data schema
   * @see {@link documents.Scene}               The Scene document type which contains Note embedded documents
   * @see {@link applications.NoteConfig}       The Note configuration application
   */
  class NoteDocument<TParent extends Scene | null> extends CanvasBaseNote<TParent> {
    /** The associated JournalEntry which is referenced by this Note */
    get entry(): JournalEntry;

    /** The specific JournalEntryPage within the associated JournalEntry referenced by this Note. */
    get page(): JournalEntryPage<JournalEntry>;

    /** The text label used to annotate this Note */
    get label(): string;
  }

  interface NoteDocument<TParent extends Scene | null> extends CanvasBaseNote<TParent> {
    readonly _object: Note<this> | null;
  }
}

declare global {
  /**
   * The client-side Playlist document which extends the common BasePlaylist model.
   *
   * @see {@link Playlists}             The world-level collection of Playlist documents
   * @see {@link PlaylistSound}         The PlaylistSound embedded document within a parent Playlist
   * @see {@link PlaylistConfig}        The Playlist configuration application
   */
  class Playlist extends ClientBasePlaylist {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** Playlists may have a playback order which defines the sequence of Playlist Sounds */
    protected _playbackOrder: string[];

    /**
     * The order in which sounds within this playlist will be played (if sequential or shuffled)
     * Uses a stored seed for randomization to guarantee that all clients generate the same random order.
     */
    get playbackOrder(): string[];

    override get visible(): boolean;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Find all content links belonging to a given {@link Playlist} or {@link PlaylistSound}.
     * @param doc  The Playlist or PlaylistSound.
     */
    protected static _getSoundContentLinks(doc: Playlist | PlaylistSound<Playlist | null>): NodeListOf<Element>;

    override prepareDerivedData(): void;

    /**
     * Begin simultaneous playback for all sounds in the Playlist.
     * @returns The updated Playlist document
     */
    playAll(): Promise<this>;

    /**
     * Play the next Sound within the sequential or shuffled Playlist.
     * @param [soundId]    The currently playing sound ID, if known
     * @param [options={}] Additional options which configure the next track
     * @param [options.direction=1] Whether to advance forward (if 1) or backwards (if -1)
     * @returns The updated Playlist document
     */
    playNext(soundId: string, { direction }?: { direction?: number }): Promise<this>;

    /**
     * Begin playback of a specific Sound within this Playlist.
     * Determine which other sounds should remain playing, if any.
     * @param sound The desired sound that should play
     * @returns The updated Playlist
     */
    playSound(sound: PlaylistSound<this>): Promise<this>;

    /**
     * Stop playback of a specific Sound within this Playlist.
     * Determine which other sounds should remain playing, if any.
     * @param sound The desired sound that should play
     * @returns The updated Plaaylist
     */
    stopSound(sound: PlaylistSound<this>): Promise<this | undefined>;
    /**
     * End playback for any/all currently playing sounds within the Playlist.
     * @returns The updated Playlist entity
     */
    stopAll(): Promise<this | undefined>;

    /**
     * Cycle the playlist mode
     * @return A promise which resolves to the updated Playlist instance
     */
    cycleMode(): Promise<this | undefined>;

    /** Get the next sound in the cached playback order. For internal use. */
    protected _getNextSound(soundId: string): PlaylistSound<this>;

    /** Get the previous sound in the cached playback order. For internal use. */
    protected _getPreviousSound(soundId: string): PlaylistSound<this>;

    /** Define the sorting order for the Sounds within this Playlist. For internal use. */
    protected _sortSounds(a: PlaylistSound<this>, b: PlaylistSound<this>): number;

    protected override _preUpdate(
      data: Record<string, unknown>,
      options: DocumentModificationContext<null>,
      user: User,
    ): Promise<void>;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

    protected override _onCreateDescendantDocuments(
      parent: this,
      collection: 'sounds',
      documents: PlaylistSound<this>[],
      data: PlaylistSound<this>['_source'][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onUpdateDescendantDocuments(
      parent: this,
      collection: 'sounds',
      documents: PlaylistSound<this>[],
      changes: DeepPartial<PlaylistSound<this>['_source']>[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onDeleteDescendantDocuments(
      parent: this,
      collection: 'sounds',
      documents: PlaylistSound<this>[],
      ids: string[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    /** Handle callback logic when an individual sound within the Playlist concludes playback naturally */
    protected _onSoundEnd(sound: PlaylistSound<this>): Promise<this | undefined>;

    /**
     * Handle callback logic when playback for an individual sound within the Playlist is started.
     * Schedule auto-preload of next track
     */
    protected _onSoundStart(sound: PlaylistSound<this>): Promise<void>;

    override toCompendium(pack: CompendiumCollection<this>): this['_source'];
  }

  interface Playlist extends ClientBasePlaylist {
    readonly sounds: foundry.abstract.EmbeddedCollection<PlaylistSound<this>>;
  }
}

declare global {
  /**
   * The PlaylistSound embedded document within a Playlist document which extends the BasePlaylist abstraction.
   * Each PlaylistSound belongs to the results collection of a Playlist entity.
   * Each PlaylistSound contains a PlaylistSoundData object which provides its source data.
   *
   * @see {@link data.PlaylistSoundData}    The PlaylistSound data schema
   * @see {@link documents.Playlist}        The Playlist document which contains PlaylistSound embedded documents
   * @see {@link Sound}                     The Sound API which manages web audio playback
   */
  class PlaylistSound<TParent extends Playlist | null> extends ClientBasePlaylistSound<TParent> {
    constructor(data: PreCreate<foundry.documents.PlaylistSoundSource>, context?: DocumentConstructionContext<TParent>);

    /** The Sound which manages playback for this playlist sound */
    sound: Sound | null;

    /**
     * A debounced function, accepting a single volume parameter to adjust the volume of this sound
     * @param volume The desired volume level
     */
    debounceVolume: (volume: number) => unknown;

    /** The debounce tolerance for processing rapid volume changes into database updates in milliseconds */
    static VOLUME_DEBOUNCE_MS: number;

    /** @todo fill the rest of this in */
  }

  /** @todo: fill in */
  class Sound {}
}

declare global {
  /**
   * The client-side RollTable document which extends the common BaseRollTable abstraction.
   * Each RollTable document contains RollTableData which defines its data schema.
   * @see {@link data.RollTableData}              The RollTable data schema
   * @see {@link documents.RollTables}            The world-level collection of RollTable documents
   * @see {@link applications.RollTableConfig}    The RollTable configuration application
   */
  class RollTable extends ClientBaseRollTable {
    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Display a result drawn from a RollTable in the Chat Log along.
     * Optionally also display the Roll which produced the result and configure aspects of the displayed messages.
     *
     * @param results      An Array of one or more TableResult Documents which were drawn and should be displayed
     * @param [options={}] Additional options which modify message creation
     * @param [options.roll]              An optional Roll instance which produced the drawn results
     * @param [options.messageData={}]    Additional data which customizes the created messages
     * @param [options.messageOptions={}] Additional options which customize the created messages
     */
    toMessage(
      results: TableResult<this>[],
      {
        roll,
        messageData,
        messageOptions,
      }?: {
        roll?: Roll | null;
        messageData?: Partial<foundry.documents.ChatMessageSource>;
        messageOptions?: ChatMessageModificationContext;
      },
    ): Promise<ChatMessage | undefined>;

    /**
     * Draw a result from the RollTable based on the table formula or a provided Roll instance
     * @param [options={}]               Optional arguments which customize the draw behavior
     * @param [options.roll]             An existing Roll instance to use for drawing from the table
     * @param [options.recursive=true]   Allow drawing recursively from inner RollTable results
     * @param [options.results]          One or more table results which have been drawn
     * @param [options.displayChat=true] Whether to automatically display the results in chat
     * @param [options.rollMode]         The chat roll mode to use when displaying the result
     * @returns A Promise which resolves to an object containing the executed roll and the produced results
     */
    draw({
      roll,
      recursive,
      results,
      displayChat,
      rollMode,
    }?: {
      roll?: Roll | null;
      recursive?: boolean;
      results?: TableResult<RollTable>[];
      displayChat?: boolean;
      rollMode?: RollMode | 'roll' | null;
    }): Promise<RollTableDraw<this>>;

    /**
     * Draw multiple results from a RollTable, constructing a final synthetic Roll as a dice pool of inner rolls.
     * @param number       The number of results to draw
     * @param [options={}] Optional arguments which customize the draw
     * @param [options.roll]             An optional pre-configured Roll instance which defines the dice roll to use
     * @param [options.recursive=true]   Allow drawing recursively from inner RollTable results
     * @param [options.displayChat=true] Automatically display the drawn results in chat? Default is true
     * @param [options.rollMode]         Customize the roll mode used to display the drawn results
     * @returns The drawn results
     */
    drawMany(
      number: number,
      {
        roll,
        recursive,
        displayChat,
        rollMode,
      }?: { roll?: Roll | null; recursive?: boolean; displayChat?: boolean; rollMode?: RollMode | null },
    ): Promise<RollTableDraw<this>>;

    /** Normalize the probabilities of rolling each item in the RollTable based on their assigned weights */
    normalize(): Promise<this>;

    /** Reset the state of the RollTable to return any drawn items to the table */
    reset(): Promise<this>;

    /**
     * Evaluate a RollTable by rolling its formula and retrieving a drawn result.
     *
     * Note that this function only performs the roll and identifies the result, the RollTable#draw function should be
     * called to formalize the draw from the table.
     *
     * @param [roll]    An alternative dice Roll to use instead of the default formula for the table
     * @param recursive If a RollTable entity is drawn as a result, recursively roll it
     * @param _depth    An internal flag used to track recursion depth
     * @returns The Roll and results drawn by that Roll
     *
     * @example
     * // Draw results using the default table formula
     * const defaultResults = await table.roll();
     *
     * // Draw results using a custom roll formula
     * const roll = new Roll("1d20 + @abilities.wis.mod", actor.getRollData());
     * const customResults = await table.roll({roll});
     */
    roll({
      roll,
      recursive,
      _depth,
    }?: {
      roll?: Roll;
      recursive?: boolean;
      _depth?: number;
    }): Promise<RollTableDraw<this>>;

    /**
     * Get an Array of valid results for a given rolled total
     * @param value The rolled value
     * @return An Array of results
     */
    getResultsForRoll(value: number): TableResult<this>[];

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _onCreateDescendantDocuments(
      parent: this,
      collection: 'results',
      documents: TableResult<this>[],
      data: TableResult<this>['_source'][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onDeleteDescendantDocuments(
      parent: this,
      collection: 'results',
      documents: TableResult<this>[],
      ids: string[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    /* -------------------------------------------- */
    /*  Importing and Exporting                     */
    /* -------------------------------------------- */

    override toCompendium(pack: CompendiumCollection<this>): this['_source'];

    /**
     * Create a new RollTable entity using all of the Entities from a specific Folder as new results.
     * @param folder  The Folder entity from which to create a roll table
     * @param options Additional options passed to the RollTable.create method
     */
    static fromFolder(folder: Folder, options?: DocumentModificationContext<null>): Promise<RollTable | undefined>;
  }

  interface RollTable extends ClientBaseRollTable {
    readonly results: foundry.abstract.EmbeddedCollection<TableResult<this>>;
  }

  /**
   * @typedef RollTableDraw An object containing the executed Roll and the produced results
   * @property roll    The Dice roll which generated the draw
   * @property results An array of drawn TableResult documents
   */
  interface RollTableDraw<TParent extends RollTable> {
    roll: Roll;
    results: TableResult<TParent>[];
  }
}

declare global {
  /**
   * The client-side Scene document which extends the common BaseScene abstraction.
   * Each Scene document contains SceneData which defines its data schema.
   * @param [data={}]        Initial data provided to construct the Scene document
   */
  class Scene extends ClientBaseScene {
    /**
     * Track the viewed position of each scene (while in memory only, not persisted)
     * When switching back to a previously viewed scene, we can automatically pan to the previous position.
     */
    protected _viewPosition: {} | { x: number; y: number; scale: number };

    /** Track whether the scene is the active view */
    protected _view: boolean;

    /** Determine the canvas dimensions this Scene would occupy, if rendered */
    dimensions: SceneDimensions;

    /** Provide a thumbnail image path used to represent this document. */
    get thumbnail(): string;

    /** A convenience accessor for whether the Scene is currently viewed */
    get isView(): boolean;

    /* -------------------------------------------- */
    /*  Scene Methods                               */
    /* -------------------------------------------- */

    /**
     * Set this scene as currently active
     * @return A Promise which resolves to the current scene once it has been successfully activated
     */
    activate(): Promise<this>;

    override clone(
      data: Record<string, unknown> | undefined,
      context: DocumentCloneContext & { save: true },
    ): Promise<this>;
    override clone(data?: Record<string, unknown>, context?: DocumentCloneContext & { save?: false }): this;
    override clone(data?: Record<string, unknown>, context?: DocumentCloneContext): this | Promise<this>;

    /** Set this scene as the current view */
    view(): Promise<this>;

    override prepareBaseData(): void;

    /**
     * Get the Canvas dimensions which would be used to display this Scene.
     * Apply padding to enlarge the playable space and round to the nearest 2x grid size to ensure symmetry.
     * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
     */
    getDimensions(): SceneDimensions;

    protected override _preCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      user: User,
    ): Promise<boolean | void>;

    protected override _onCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _preUpdate(
      data: Record<string, unknown>,
      options: SceneUpdateContext,
      user: User,
    ): Promise<boolean | void>;

    override _onUpdate(changed: DeepPartial<this['_source']>, options: SceneUpdateContext, userId: string): void;

    protected override _preDelete(options: DocumentModificationContext<null>, user: User): Promise<boolean | void>;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;

    /**
     * Handle Scene activation workflow if the active state is changed to true
     * @param active Is the scene now active?
     */
    protected _onActivate(active: boolean): Promise<this>;

    protected override _preCreateDescendantDocuments(
      parent: this,
      collection: 'tokens',
      data: foundry.documents.TokenSource[][],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _preUpdateDescendantDocuments(
      parent: this,
      collection: string,
      changes: object[],
      options: SceneEmbeddedModificationContext<this>,
      userId: string,
    ): void;

    protected override _onUpdateDescendantDocuments(
      parent: this,
      collection: string,
      documents: ClientDocument[],
      changes: object[],
      options: SceneEmbeddedModificationContext<this>,
      userId: string,
    ): void;

    /* -------------------------------------------- */
    /*  Importing and Exporting                     */
    /* -------------------------------------------- */

    override toCompendium(pack: CompendiumCollection<this>): this['_source'];

    /**
         * Create a 300px by 100px thumbnail image for this scene background
         * @param [string|null] A background image to use for thumbnail creation, otherwise the current scene background
                                is used.
         * @param [width]       The desired thumbnail width. Default is 300px
         * @param [height]      The desired thumbnail height. Default is 100px;
         * @return The created thumbnail data.
         */
    createThumbnail({
      img,
      width,
      height,
    }?: {
      img?: ImageFilePath | null;
      width?: number;
      height?: number;
    }): Promise<Record<string, unknown>>;
  }

  interface Scene {
    readonly drawings: foundry.abstract.EmbeddedCollection<DrawingDocument<this>>;
    readonly lights: foundry.abstract.EmbeddedCollection<AmbientLightDocument<this>>;
    readonly notes: foundry.abstract.EmbeddedCollection<NoteDocument<this>>;
    readonly sounds: foundry.abstract.EmbeddedCollection<AmbientSoundDocument<this>>;
    readonly templates: foundry.abstract.EmbeddedCollection<MeasuredTemplateDocument<this>>;
    readonly tokens: foundry.abstract.EmbeddedCollection<TokenDocument<this>>;
    readonly tiles: foundry.abstract.EmbeddedCollection<TileDocument<this>>;
    readonly walls: foundry.abstract.EmbeddedCollection<WallDocument<this>>;

    _sheet: SceneConfig<this> | null;

    get sheet(): SceneConfig<this>;

    getEmbeddedCollection(embeddedName: 'Token'): this['tokens'];

    update(data: Record<string, unknown>, options?: SceneUpdateContext): Promise<this>;

    createEmbeddedDocuments(
      embeddedName: 'Note',
      data: PreCreate<NoteSource>[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['notes']>[]>;
    createEmbeddedDocuments(
      embeddedName: 'Token',
      data: PreCreate<TokenSource>[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['tokens']>[]>;
    createEmbeddedDocuments(
      embeddedName: SceneEmbeddedName,
      data: Record<string, unknown>[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<
      | CollectionValue<this['drawings']>[]
      | CollectionValue<this['lights']>[]
      | CollectionValue<this['notes']>[]
      | CollectionValue<this['sounds']>[]
      | CollectionValue<this['tiles']>[]
      | CollectionValue<this['tokens']>[]
      | CollectionValue<this['tokens']>[]
      | CollectionValue<this['walls']>[]
    >;

    updateEmbeddedDocuments(
      embeddedName: 'Token',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneTokenModificationContext<this>,
    ): Promise<CollectionValue<this['tokens']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'AmbientLight',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['lights']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'AmbientSound',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['sounds']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'Drawing',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['drawings']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'MeasuredTemplate',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['tokens']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'Note',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['notes']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'Tile',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['tiles']>[]>;
    updateEmbeddedDocuments(
      embeddedName: 'Wall',
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<CollectionValue<this['walls']>[]>;
    updateEmbeddedDocuments(
      embeddedName: SceneEmbeddedName,
      updateData: EmbeddedDocumentUpdateData[],
      context?: SceneEmbeddedModificationContext<this>,
    ): Promise<
      | CollectionValue<this['drawings']>[]
      | CollectionValue<this['lights']>[]
      | CollectionValue<this['notes']>[]
      | CollectionValue<this['sounds']>[]
      | CollectionValue<this['tiles']>[]
      | CollectionValue<this['tokens']>[]
      | CollectionValue<this['tokens']>[]
      | CollectionValue<this['walls']>[]
    >;
  }

  interface SceneUpdateContext extends DocumentModificationContext<null> {
    animateDarkness?: number;
  }

  interface SceneTokenModificationContext<TParent extends Scene> extends SceneEmbeddedModificationContext<TParent> {
    animation?: TokenAnimationOptions<Token>;
  }

  interface SceneDimensions {
    /** The width of the canvas. */
    width: number;
    /** The height of the canvas. */
    height: number;
    /** The grid size. */
    size: number;
    /** The canvas rectangle. */
    rect: PIXI.Rectangle;
    /** The X coordinate of the scene rectangle within the larger canvas. */
    sceneX: number;
    /** The Y coordinate of the scene rectangle within the larger canvas. */
    sceneY: number;
    /** The width of the scene. */
    sceneWidth: number;
    /** The height of the scene. */
    sceneHeight: number;
    /** The scene rectangle. */
    sceneRect: PIXI.Rectangle;
    /** The number of distance units in a single grid space. */
    distance: number;
    /** The aspect ratio of the scene rectangle. */
    ratio: number;
    /** The length of the longest line that can be drawn on the canvas. */
    maxR: number;
  }
}

type SceneEmbeddedName =
  | 'AmbientLight'
  | 'AmbientSound'
  | 'Drawing'
  | 'MeasuredTemplate'
  | 'Note'
  | 'Tile'
  | 'Token'
  | 'Wall';

declare global {
  /**
   * The client-side Setting document which extends the common BaseSetting model.
   *
   * @see {@link WorldSettings}       The world-level collection of Setting documents
   */
  class Setting extends ClientBaseSetting {
    /** The setting configuration for this setting document. */
    get config(): SettingsConfig | undefined;

    protected override _initialize(options?: object): void;

    protected override _onCreate(
      data: this['_source'],
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    /**
     * Cast the value of the Setting into its defined type.
     * The initialized type of the Setting document.
     */
    protected _castType(): unknown;
  }
}

declare global {
  /**
   * The client-side TableResult document which extends the common BaseTableResult document model.
   *
   * @see {@link RollTable} The RollTable document type which contains TableResult documents
   */
  class TableResult<TParent extends RollTable> extends ClientBaseTableResult<TParent> {
    /** A path reference to the icon image used to represent this result */
    get icon(): string;

    /**
     * Prepare a string representation for the result which (if possible) will be a dynamic link or otherwise plain
     * text
     */
    getChatText(): string;
  }
}

declare global {
  class TileDocument<TParent extends Scene | null> extends CanvasBaseTile<TParent> {}

  interface TileDocument<TParent extends Scene | null> extends CanvasBaseTile<TParent> {
    readonly _object: Tile<this> | null;
  }
}

declare global {
  class TokenDocument<TParent extends Scene | null = Scene | null> extends CanvasBaseToken<TParent> {
    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** A singleton collection which holds a reference to the synthetic token actor by its base actor's ID. */
    actors: Collection<Actor>;

    /**
     * A lazily evaluated reference to the Actor this Token modifies.
     * If actorLink is true, then the document is the primary Actor document.
     * Otherwise, the Actor document is a synthetic (ephemeral) document constructed using the Token's actorData.
     */
    get actor(): Actor<this | null> | null;

    /** A reference to the base, World-level Actor this token represents. */
    get baseActor(): Actor<null>;

    /** An indicator for whether or not the current User has full control over this Token document. */
    override get isOwner(): boolean;

    /** A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy */
    get isLinked(): this['actorLink'];

    /** Return a reference to a Combatant that represents this Token, if one is present in the current encounter. */
    get combatant(): Combatant<Combat, this> | null;

    /** An indicator for whether or not this Token is currently involved in the active combat encounter. */
    get inCombat(): boolean;

    /**
     * Define a sort order for this TokenDocument.
     * This controls its rendering order in the PrimaryCanvasGroup relative to siblings at the same elevation.
     * In the future this will be replaced with a persisted database field for permanent adjustment of token stacking.
     * In case of ties, Tokens will be sorted above other types of objects.
     */
    get sort(): number;

    set sort(value: number);

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override prepareBaseData(): void;

    /**
     * Prepare detection modes which are available to the Token.
     * Ensure that every Token has the basic sight detection mode configured.
     */
    protected _prepareDetectionModes(): void;

    override clone(
      data: Record<string, unknown> | undefined,
      context: DocumentCloneContext & { save: true },
    ): Promise<this>;
    override clone(data?: Record<string, unknown>, context?: DocumentCloneContext & { save?: false }): this;
    override clone(data?: Record<string, unknown>, context?: DocumentCloneContext): this | Promise<this>;

    /**
     * Create a synthetic Actor using a provided Token instance
     * If the Token data is linked, return the true Actor document
     * If the Token data is not linked, create a synthetic Actor using the Token's actorData override
     */
    getActor(): Actor<this | null> | null;

    /**
     * A helper method to retrieve the underlying data behind one of the Token's attribute bars
     * @param barName     The named bar to retrieve the attribute for
     * @param alternative An alternative attribute path to get instead of the default one
     * @return The attribute displayed on the Token bar, if any
     */
    getBarAttribute(barName: string, { alternative }?: { alternative?: string }): TokenResourceData | null;

    /**
     * Test whether a Token has a specific status effect.
     * @param statusId The status effect ID as defined in CONFIG.statusEffects
     * @returns Does the Token have this status effect?
     */
    hasStatusEffect(statusId: string): boolean;

    /* -------------------------------------------- */
    /*  Actor Data Operations                       */
    /* -------------------------------------------- */

    /**
     * Redirect updates to a synthetic Token Actor to instead update the tokenData override object.
     * Once an attribute in the Token has been overridden, it must always remain overridden.
     *
     * @param update   The provided differential update data which should update the Token Actor
     * @param options  Provided options which modify the update request
     * @returns The updated un-linked Actor instance
     */
    modifyActorDocument(
      update: Record<string, unknown>,
      options: DocumentModificationContext<this>,
    ): Promise<Actor<this>[]>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    protected override _preUpdate(
      data: Record<string, unknown>,
      options: TokenUpdateContext<TParent>,
      user: User,
    ): Promise<boolean | void>;

    protected override _onUpdate(
      changed: DeepPartial<this['_source']>,
      options: DocumentModificationContext<TParent>,
      userId: string,
    ): void;

    /**
     * Support the special case descendant document changes within an ActorDelta.
     * The descendant documents themselves are configured to have a synthetic Actor as their parent.
     * We need this to ensure that the ActorDelta receives these events which do not bubble up.
     */
    protected override _preCreateDescendantDocuments(
      parent: this,
      collection: string,
      data: object[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _preUpdateDescendantDocuments(
      parent: this,
      collection: string,
      changes: Record<string, unknown>[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _preDeleteDescendantDocuments(
      parent: this,
      collection: string,
      ids: string[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onCreateDescendantDocuments(
      parent: this,
      collection: string,
      documents: ClientDocument[],
      data: object[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onUpdateDescendantDocuments(
      parent: this,
      collection: string,
      documents: ClientDocument[],
      changes: Record<string, unknown>[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    protected override _onDeleteDescendantDocuments(
      parent: this,
      collection: string,
      documents: ClientDocument[],
      ids: string[],
      options: DocumentModificationContext<this>,
      userId: string,
    ): void;

    /**
     * When the base Actor for a TokenDocument changes, we may need to update its Actor instance
     * @internal
     */
    protected _onUpdateBaseActor(
      update?: Record<string, unknown>,
      options?: DocumentModificationContext<ClientDocument | null>,
    ): void;

    /**
     * Whenever the token's actor delta changes, or the base actor changes, perform associated refreshes.
     * @param [update]  The update delta.
     * @param [options] The options provided to the update.
     */
    protected _onRelatedUpdate(update?: Record<string, unknown>, options?: DocumentModificationContext<null>): void;

    /** Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker */
    static getTrackedAttributes(data?: object, _path?: string[]): TrackedAttributesDescription;

    /** Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar */
    static getTrackedAttributeChoices(attributes?: TrackedAttributesDescription): TrackedAttributesDescription;
  }

  interface TokenDocument<TParent extends Scene | null = Scene | null> extends CanvasBaseToken<TParent> {
    delta: ActorDelta<this> | null;

    get object(): Token<this> | null;
    get sheet(): TokenConfig<this>;
    get uuid(): TokenDocumentUUID;
  }

  interface TokenDocumentConstructionContext<TParent extends Scene | null, TActor extends Actor<TokenDocument> | null>
    extends DocumentConstructionContext<TParent> {
    actor?: TActor;
  }

  interface TokenUpdateContext<TParent extends Scene | null> extends DocumentModificationContext<TParent> {
    action?: 'create' | 'update' | 'delete';
    embedded?: { embeddedName: string; hookData: { _id?: string }[] };
  }

  type TokenDocumentUUID = `Scene.${string}.Token.${string}`;

  interface TrackedAttributesDescription {
    bar: string[][];
    value: string[][];
  }
}

declare global {
  /**
   * The client-side User document which extends the common BaseUser model.
   * Each User document contains UserData which defines its data schema.
   *
   * @see {@link Users}       The world-level collection of User documents
   * @see {@link UserConfig} The User configuration application
   */
  class User<TCharacter extends Actor<null> = Actor<null>> extends ClientBaseUser<TCharacter> {
    constructor(data: PreCreate<foundry.documents.UserSource>, context?: DocumentConstructionContext<null>);

    /** Track whether the user is currently active in the game */
    active: boolean;

    /** Track references to the current set of Tokens which are targeted by the User */
    targets: Set<Token>;

    /** Track the ID of the Scene that is currently being viewed by the User */
    viewedScene: string | null;

    /* ---------------------------------------- */
    /*  User Properties                         */
    /* ---------------------------------------- */

    /** A flag for whether the current User is a Trusted Player */
    get isTrusted(): boolean;

    /** A flag for whether this User is the connected client */
    get isSelf(): boolean;

    override prepareDerivedData(): void;

    /**
     * Assign a Macro to a numbered hotbar slot between 1 and 50
     * @param macro      The Macro entity to assign
     * @param [slot]     A specific numbered hotbar slot to fill
     * @param [fromSlot] An optional origin slot from which the Macro is being shifted
     * @return A Promise which resolves once the User update is complete
     */
    assignHotbarMacro(
      macro: Macro | null,
      slot?: number | string,
      { fromSlot }?: { fromSlot?: number | undefined },
    ): Promise<this>;

    /**
     * Assign a specific boolean permission to this user.
     * Modifies the user permissions to grant or restrict access to a feature.
     *
     * @param permission The permission name from USER_PERMISSIONS
     * @param allowed    Whether to allow or restrict the permission
     */
    assignPermission(permission: UserPermission, allowed: boolean): Promise<this | undefined>;

    /**
     * Submit User activity data to the server for broadcast to other players.
     * This type of data is transient, persisting only for the duration of the session and not saved to any database.
     *
     * @param activityData An object of User activity data to submit to the server for broadcast.
     * @param activityData.cursor  The coordinates of the user's cursor
     * @param activityData.focus   Is the user pulling focus to the cursor coordinates?
     * @param activityData.ping    Is the user emitting a ping at the cursor coordinates?
     * @param activityData.ruler   Serialized Ruler coordinate data in JSON format
     * @param activityData.sceneId The id of the Scene currently being viewed by the User
     * @param activityData.targets An id of Token ids which are targeted by the User
     */
    broadcastActivity(activityData?: UserActivity): void;

    /**
     * Get an Array of Macro Entities on this User's Hotbar by page
     * @param page The hotbar page number
     */
    getHotbarMacros(page?: number): object[];

    /**
     * Update the set of Token targets for the user given an array of provided Token ids.
     * @param targetIds An array of Token ids which represents the new target set
     */
    updateTokenTargets(targetIds?: string[]): void;

    protected override _onUpdate(
      changed: DeepPartial<foundry.documents.UserSource>,
      options: DocumentModificationContext<null>,
      userId: string,
    ): void;

    protected override _onDelete(options: DocumentModificationContext<null>, userId: string): void;
  }

  interface UserActivity {
    cursor?: object;
    focus?: boolean;
    ping?: boolean;
    ruler?: string;
    sceneId?: string;
    target?: string[];
  }

  type Active<TUser extends User<Actor<null>>> = TUser & {
    color: HexColorString;
    border: HexColorString;
  };
}

declare global {
  class WallDocument<TParent extends Scene | null> extends CanvasBaseWall<TParent> {}

  interface WallDocument<TParent extends Scene | null> extends CanvasBaseWall<TParent> {
    get object(): Wall<this> | null;
  }
}

declare global {
  type WorldDocument =
    | Actor<null>
    | Cards
    | ChatMessage
    | Combat
    | Folder
    | Item<null>
    | JournalEntry
    | Macro
    | Playlist
    | RollTable
    | Scene
    | User;

  type WorldDocumentUUID<T extends WorldDocument = WorldDocument> = `${T['documentName']}.${string}`;
}

declare global {
  const socket: io.Socket | null;
  const keyboard: KeyboardManager;

  /**
   * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
   * The singleton instance of the Game class is available as the global variable game.
   *
   * @param view      The named view which is active for this game instance.
   * @param data      An object of all the World data vended by the server when the client first connects
   * @param sessionId The ID of the currently active client session retrieved from the browser cookie
   * @param socket    The open web-socket which should be used to transact game-state data
   */
  class Game<
    TActor extends Actor<null>,
    TActors extends Actors<TActor>,
    TChatMessage extends ChatMessage,
    TCombat extends Combat,
    TItem extends Item<null>,
    TMacro extends Macro,
    TScene extends Scene,
    TUser extends User<TActor>,
  > {
    /**
     * The named view which is currently active.
     * Game views include: join, setup, players, license, game, stream
     */
    view: string;

    // Undocumented
    _documentsReady?: boolean;

    /** The object of world data passed from the server */
    data: {
      actors: TActor['_source'][];
      items: TItem['_source'][];
      macros: TMacro['_source'][];
      messages: TChatMessage['_source'][];
      packs: CompendiumMetadata[];
      tables: foundry.documents.RollTableSource[];
      users: TUser['_source'][];
      version: string;
    };

    /** The game World which is currently active */
    world: object;

    /** Localization support */
    i18n: Localization;

    /** The Keyboard Manager */
    keyboard: KeyboardManager;

    /** A mapping of installed modules */
    modules: Collection<Module>;

    /** The user role permissions setting */
    permissions: Record<string, number[]>;

    /** The client session id which is currently active */
    sessionId: string;

    /** Client settings which are used to configure application behavior */
    settings: ClientSettings;

    /** Client keybindings which are used to configure application behavior */
    keybindings: ClientKeybindings;

    /** A reference to the open Socket.io connection */
    socket: io.Socket;

    /** A singleton GameTime instance which manages the progression of time within the game world. */
    time: GameTime;

    /** The id of the active game user */
    userId: string;

    /** A singleton instance of the Audio Helper class */
    audio: AudioHelper;

    /** A singleton instance of the Video Helper class */
    video: VideoHelper;

    /** A singleton instance of the TooltipManger class */
    tooltip: TooltipManager;

    /** A singleton instance of the Clipboard Helper class. */
    clipboard: ClipboardHelper;

    /** A singleton instance of the Tours class */
    tours: Tours;

    /** The global document index. */
    documentIndex: DocumentIndex;

    documentTypes: Record<string, string[]>;

    /** Whether the Game is running in debug mode */
    debug: boolean;

    /**
     * A flag for whether texture assets for the game canvas are currently loading
     */
    loading: boolean;

    /** A flag for whether the Game has successfully reached the "ready" hook */
    ready: boolean;

    /** The Release data for this version of Foundry */
    release: {
      build: number;
      channel: string;
      download: string;
      generation: number;
      node_version?: number;
      notes: string;
      suffix?: string;
      time: number;
    };

    /* -------------------------------------------- */
    /*  World Collections                           */
    /* -------------------------------------------- */

    actors: TActors;
    collections: Collection<WorldCollection<TActor | TItem | JournalEntry | TMacro | Playlist | RollTable | TScene>>;

    combats: CombatEncounters<TCombat>;
    folders: Folders<Folder>;
    items: Items<TItem>;
    journal: Journal;
    macros: Macros<TMacro>;
    messages: Messages<TChatMessage>;
    packs: Collection<CompendiumCollection<TActor | TItem | JournalEntry | TMacro | Playlist | RollTable | TScene>>;
    playlists: Playlists;
    scenes: Scenes<TScene>;
    tables: RollTables;
    users: Users<TUser>;

    constructor(view: string, worldData: object, sessionId: string, socket: io.Socket);

    /** Returns the current version of the Release, usable for comparisons using isNewerVersion */
    get version(): string;

    /**
     * Fetch World data and return a Game instance
     * @return A Promise which resolves to the created Game instance
     */
    static create(): Promise<
      Game<Actor<null>, Actors<Actor<null>>, ChatMessage, Combat, Item<null>, Macro, Scene, User>
    >;

    /** Request World data from server and return it */
    static getWorldData(socket: io.Socket): Promise<object>;

    /** Request setup data from server and return it */
    static getSetupData(socket: io.Socket): Promise<object>;

    /** Initialize the Game for the current window location */
    initialize(): Promise<void>;

    /** Fully set up the game state, initializing Entities, UI applications, and the Canvas */
    setupGame(): Promise<void>;

    /** Initialize game state data by creating Collections for all Entity types */
    initializeEntities(): void;

    /** Initialization actions for compendium packs */
    initializePacks(config: object): Promise<void>;

    /** Initialize the WebRTC implementation */
    initializeRTC(): void;

    /** Initialize core UI elements */
    initializeUI(): void;

    /** Initialize the game Canvas */
    initializeCanvas(): Promise<void>;

    /** Initialize Keyboard controls */
    initializeKeyboard(): void;

    /** Initialize Mouse controls */
    initializeMouse(): void;

    /** Register core game settings */
    registerSettings(): void;

    /** The currently connected User */
    get user(): Active<TUser>;

    /** Metadata regarding the game System which powers this World */
    get system(): System;

    /** A convenience accessor for the currently active Combat encounter */
    get combat(): TCombat | null;

    /** A state variable which tracks whether or not the game session is currently paused */
    get paused(): boolean;

    /** A convenient reference to the currently active canvas tool */
    get activeTool(): string;

    /**
     * Toggle the pause state of the game
     * Trigger the `pauseGame` Hook when the paused state changes
     * @param pause The new pause state
     * @param push  Push the pause state change to other connected clients?
     */
    togglePause(pause: boolean, push?: boolean): void;

    static getCookies(): object;

    static clearCookies(): boolean;

    /** Open socket listeners which transact game state data */
    openSockets(): void;

    /** General game-state socket listeners and event handlers */
    static socketListeners(socket: io.Socket): void;

    /** Activate Event Listeners which apply to every Game View */
    activateListeners(): void;
  }
}

declare global {
  /**
   * A class responsible for managing defined game keybinding.
   * Each keybinding is a string key/value pair belonging to a certain namespace and a certain store scope.
   *
   * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
   * Game object as as game.keybindings.
   */
  class ClientKeybindings {
    /** Registered Keybinding actions */
    actions: Map<string, KeybindingActionConfig>;

    /** A mapping of a string key to possible Actions that might execute off it */
    activeKeys: Map<string, KeybindingAction[]>;

    /** A stored cache of Keybind Actions Ids to Bindings */
    bindings: Map<string, KeybindingActionBinding[]>;

    protected _registered: number;

    /** A timestamp which tracks the last time a pan operation was performed */
    private _moveTime: number;

    constructor();

    static MOVEMENT_DIRECTIONS: {
      UP: 'up';
      LEFT: 'left';
      DOWN: 'down';
      RIGHT: 'right';
    };

    static ZOOM_DIRECTIONS: { IN: 'in'; OUT: 'out' };

    /** An alias of the movement key set tracked by the keyboard */
    get moveKeys(): Set<string>;

    /** Initializes the keybinding values for all registered actions */
    initialize(): void;

    /**
     * Register a new keybinding
     *
     * @param namespace The namespace the Keybinding Action belongs to
     * @param action    A unique machine-readable id for the Keybinding Action
     * @param data      Configuration for keybinding data
     *
     * @example <caption>Define a keybinding which shows a notification</caption>
     * game.keybindings.register("myModule", "showNotification", {
     *   name: "My Settings Keybinding",
     *   hint: "A description of what will occur when the Keybinding is executed.",
     *   uneditable: [
     *     {
     *       key: "Digit1",
     *       modifiers: ["Control"]
     *     }
     *   ],
     *   editable: [
     *     {
     *       key: "F1"
     *     }
     *   ],
     *   onDown: () => { ui.notifications.info("Pressed!") },
     *   onUp: () => {},
     *   restricted: true,                         // Restrict this Keybinding to gamemaster only?
     *   reservedModifiers: ["Alt""],              // If the ALT modifier is pressed, the notification is permanent instead of temporary
     *   precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL
     * }
     */
    register(namespace: string, action: string, data: KeybindingActionConfig): void;

    /**
     * Get the current Bindings of a given namespace's Keybinding Action
     *
     * @param namespace The namespace under which the setting is registered
     * @param action    The keybind action to retrieve
     *
     * @example <caption>Retrieve the current Keybinding Action Bindings</caption>
     * game.keybindings.get("myModule", "showNotification");
     */
    get(namespace: string, action: string): KeybindingActionBinding[];

    /**
     * Set the editable Bindings of a Keybinding Action for a certain namespace and Action
     *
     * @param namespace The namespace under which the Keybinding is registered
     * @param action    The Keybinding action to set
     * @param bindings  The Bindings to assign to the Keybinding
     *
     * @example <caption>Update the current value of a keybinding</caption>
     * game.keybindings.set("myModule", "showNotification", [
     *     {
     *       key: "F2",
     *       modifiers: [ "CONTROL" ]
     *     }
     * ]);
     */
    set(namespace: string, action: string, bindings: KeybindingActionBinding[]): Promise<void>;

    /** Reset all client keybindings back to their default configuration. */
    resetDefaults(): Promise<void>;

    /**
     * A helper method that, when given a value, ensures that the returned value is a standardized Binding array
     * @param values An array of keybinding assignments to be validated
     * @return An array of keybinding assignments confirmed as valid
     */
    private static _validateBindings(values: KeybindingActionBinding[]): KeybindingActionBinding[];

    /**
     * Validate that assigned modifiers are allowed
     * @param keys An array of modifiers which may be valid
     * @returns An array of modifiers which are confirmed as valid
     */
    private static _validateModifiers(keys: string[]): string[];

    /**
     * Compares two Keybinding Actions based on their Order
     * @param a The first Keybinding Action
     * @param b the second Keybinding Action
     */
    private static _compareActions(a: KeybindingAction, b: KeybindingAction): number;

    /* ---------------------------------------- */
    /*  Core Keybinding Actions                 */
    /* ---------------------------------------- */

    /** Register core keybindings */
    private _registerCoreKeybindings(): void;

    /**
     * Handle Select all action
     * @param event   The originating keyboard event
     * @param context The context data of the event
     */
    private static _onSelectAllObjects(event: KeyboardEvent, context: KeyboardEventContext): boolean;

    /**
     * Handle Cycle View actions
     * @param context The context data of the event
     */
    private static _onCycleView(context: KeyboardEventContext): boolean;

    /**
     * Handle Dismiss actions
     * @param context The context data of the event
     */
    private static _onDismiss(context: KeyboardEventContext): boolean;

    /**
     * Open Character sheet for current token or controlled actor
     * @param {} context    The context data of the event
     * @private
     */
    private static _onToggleCharacterSheet(
      event: KeyboardEvent,
      context: KeyboardEventContext,
    ): ActorSheet<Actor> | Promise<ActorSheet<Actor>>;

    /**
     * Handle action to target the currently hovered token.
     * @param context    The context data of the event
     */
    private static _onTarget(context: KeyboardEventContext): boolean;

    /**
     * Handle DELETE Keypress Events
     * @param event   The originating keyboard event
     * @param context The context data of the event
     */
    private static _onDelete(event: KeyboardEvent, context: KeyboardEventContext): boolean;

    /**
     * Handle keyboard movement once a small delay has elapsed to allow for multiple simultaneous key-presses.
     * @param context The context data of the event
     * @param layer   The Placeables layer
     */
    private _handleMovement(context: KeyboardEventContext, layer: TokenLayer<Token> | TilesLayer<Tile>): void;

    /** Handle panning the canvas using CTRL + directional keys */
    private _handleCanvasPan(): Promise<void>;

    /**
     * Handle Measured Ruler Movement Action
     * @param context The context data of the event
     */
    private static _onMeasuredRulerMovement(context: KeyboardEventContext): boolean;

    /**
     * Handle Pause Action
     * @param context The context data of the event
     */
    private static _onPause(context: KeyboardEventContext): boolean;

    /**
     * Handle Highlight action
     * @param context The context data of the event
     */
    private static _onHighlight(context: KeyboardEventContext): boolean;

    /**
     * Handle Pan action
     * @param context            The context data of the event
     * @param movementDirections The Directions being panned in
     */
    private _onPan(context: KeyboardEventContext, movementDirections: MovementDirection[]): boolean;

    /**
     * Handle Macro executions
     * @param context The context data of the event
     */
    private static _onMacroExecute(context: KeyboardEventContext, number: number): boolean;

    /** Handle Macro page swaps */
    private static _onMacroPageSwap(context: KeyboardEventContext, page: number): boolean;

    /**
     * Handle action to copy data to clipboard
     * @param context The context data of the event
     */
    private static _onCopy(context: KeyboardEventContext): boolean;

    /**
     * Handle Paste action
     * @param context The context data of the event
     */
    private static _onPaste(context: KeyboardEventContext): boolean;

    /**
     * Handle Undo action
     * @param context The context data of the event
     */
    private static _onUndo(context: KeyboardEventContext): boolean;

    /**
     * Handle presses to keyboard zoom keys
     * @param context The context data of the event
     * @param zoomDirection The direction to zoom
     */
    private static _onZoom(context: KeyboardEventContext, zoomDirection: 'in' | 'out'): boolean;
  }

  type MovementDirection = 'up' | 'right' | 'down' | 'left';
}

declare global {
  /**
   * A set of helpers and management functions for dealing with user input from keyboard events.
   * {@link https://keycode.info/}
   */
  class KeyboardManager {
    constructor();

    /** The set of key codes which are currently depressed (down) */
    downKeys: Set<string>;

    /** The set of movement keys which were recently pressed */
    moveKeys: Set<string>;

    /** Allowed modifier keys */
    static MODIFIER_KEYS: {
      CONTROL: 'Control';
      SHIFT: 'Shift';
      ALT: 'Alt';
    };

    /** Track which KeyboardEvent#code presses associate with each modifier */
    static MODIFIER_CODES: {
      Alt: ['AltLeft', 'AltRight'];
      Control: ['ControlLeft', 'ControlRight', 'MetaLeft', 'MetaRight'];
      Shift: ['ShiftLeft', 'ShiftRight'];
    };

    /** Key codes which are "protected" and should not be used because they are reserved for browser-level actions. */
    static PROTECTED_KEYS: ['F5', 'F11', 'F12', 'PrintScreen', 'ScrollLock', 'NumLock', 'CapsLock'];

    /** The OS-specific string display for what their Command key is */
    static CONTROL_KEY_STRING: '⌘' | 'Control';

    /**
     * An special mapping of how special KeyboardEvent#code values should map to displayed strings or symbols.
     * Values in this configuration object override any other display formatting rules which may be applied.
     */
    static KEYCODE_DISPLAY_MAPPING: {
      ArrowLeft: '🡸';
      ArrowRight: '🡺';
      ArrowUp: '🡹';
      ArrowDown: '🡻';
      Backquote: '`';
      Backslash: '\\';
      BracketLeft: '[';
      BracketRight: ']';
      Comma: ',';
      Equal: '=';
      MetaLeft: '⌘' | '⊞';
      Minus: '-';
      NumpadAdd: 'Numpad+';
      NumpadSubtract: 'Numpad-';
      Period: '.';
      Quote: "'";
      Semicolon: ';';
      Slash: '/';
    };

    /** Test whether a Form Element currently has focus */
    get hasFocus(): boolean;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Emulates a key being pressed, triggering the Keyboard event workflow.
     * @param up       If True, emulates the `keyup` Event. Else, the `keydown` event
     * @param code     The KeyboardEvent#code which is being pressed
     * @param altKey   Emulate the ALT modifier as pressed
     * @param ctrlKey  Emulate the CONTROL modifier as pressed
     * @param shiftKey Emulate the SHIFT modifier as pressed
     * @param repeat   Emulate this as a repeat event
     */
    static emulateKeypress(
      up: boolean,
      code: string,
      {
        altKey,
        ctrlKey,
        shiftKey,
        repeat,
      }?: { altKey?: boolean; ctrlKey?: boolean; shiftKey?: boolean; repeat?: boolean },
    ): KeyboardEvent;

    /**
     * Format a KeyboardEvent#code into a displayed string.
     * @param code The input code
     * @returns The displayed string for this code
     */
    static getKeycodeDisplayString(code: string): string;

    /**
     * Get a standardized keyboard context for a given event.
     * Every individual keypress is uniquely identified using the KeyboardEvent#code property.
     * A list of possible key codes is documented here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
     *
     * @param event The originating keypress event
     * @param up    A flag for whether the key is down or up
     * @return The standardized context of the event
     */
    static getKeyboardEventContext(event: KeyboardEvent, up?: boolean): KeyboardEventContext;

    /**
     * Report whether a modifier in KeyboardManager.MODIFIER_KEYS is currently actively depressed.
     * @param modifier A modifier in MODIFIER_KEYS
     * @returns Is this modifier key currently down (active)?
     */
    isModifierActive(modifier: ModifierKey): boolean;

    /**
     * Converts a Keyboard Context event into a string representation, such as "C" or "Control+C"
     * @param context          The standardized context of the event
     * @param includeModifiers If True, includes modifiers in the string representation
     */
    protected static _getContextDisplayString(context: KeyboardEventContext, includeModifiers?: boolean): string;

    /**
     * Given a standardized pressed key, find all matching registered Keybind Actions.
     * @param context A standardized keyboard event context
     * @return The matched Keybind Actions. May be empty.
     */
    protected static _getMatchingActions(context: KeyboardEventContext): KeybindingAction$1[];

    /**
     * Test whether a keypress context matches the registration for a keybinding action
     * @param action The keybinding action
     * @param context The keyboard event context
     * @returns Does the context match the action requirements?
     */
    protected static _testContext(action: KeybindingAction$1, context: KeyboardEventContext): boolean;

    /**
     * Given a registered Keybinding Action, executes the action with a given event and context
     * @param keybind The registered Keybinding action to execute
     * @param context The gathered context of the event
     * @return Returns true if the keybind was consumed
     */
    protected static _executeKeybind(keybind: KeybindingAction$1, context: KeyboardEventContext): boolean;

    /**
     * Processes a keyboard event context, checking it against registered keybinding actions
     * @param context The keyboard event context
     */
    protected _processKeyboardContext(context: KeyboardEventContext): void;

    /** Reset tracking for which keys are in the down and released states */
    protected _reset(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /**
     * Handle a key press into the down position
     * @param event The originating keyboard event
     * @param up    A flag for whether the key is down or up
     */
    protected _handleKeyboardEvent(event: KeyboardEvent, up: boolean): void;

    /**
     * Input events do not fire with isComposing = false at the end of a composition event in Chrome
     * See: https://github.com/w3c/uievents/issues/202
     */
    protected _onCompositionEnd(event: CompositionEvent): void;
  }

  type ModifierKey = (typeof KeyboardManager)['MODIFIER_KEYS'][keyof (typeof KeyboardManager)['MODIFIER_KEYS']];

  interface KeyboardEventContext {
    event: KeyboardEvent;
    key: string;
    isShift: boolean;
    isControl: boolean;
    isAlt: boolean;
    hasModifier: boolean;
    modifiers: ModifierKey[];
    up: boolean;
    repeat: boolean;
  }
}

interface KeybindingAction$1 {
  key: string;
  value: {
    name: string;
    editable: { key: string; modifiers: ModifierKey[] }[];
    precedence: number;
    reservedModifiers: ModifierKey[];
    namespace: string;
    order: number;
    uneditable: { key: string; modifiers: ModifierKey[] }[];
    repeat: boolean;
  };
}

declare global {
  namespace globalThis {
    const _templateCache: Record<string, Function>;
  }
}

declare global {
  /**
   * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
   *
   * We track three types of events:
   * 1) Cursor movement
   * 2) Ruler measurement
   * 3) Map pings
   */
  class ControlsLayer extends InteractionLayer {
    constructor();

    /** A container of DoorControl instances */
    doors: DoorContainer;

    /** A container of HUD interface elements */
    hud: PIXI.Container;

    /**
     * A container of cursor interaction elements.
     * Contains cursors, rulers, interaction rectangles, and pings
     */
    cursors: PIXI.Container;

    /** Ruler tools, one per connected user */
    rulers: RulerContainer;

    /** A graphics instance used for drawing debugging visualization */
    debug: PIXI.Container;

    /** The Canvas selection rectangle */
    select: PIXI.Graphics;

    /** A mapping of user IDs to Cursor instances for quick access */
    protected _cursors: Record<string, object>;

    /** A mapping of user IDs to Ruler instances for quick access */
    protected _rulers: Record<string, Ruler>;

    static override get layerOptions(): PlaceablesLayerOptions;

    /** A convenience accessor to the Ruler for the active game user */
    get ruler(): Ruler | null;

    /** Get the Ruler display for a specific User ID */
    getRulerForUser(userId: string): Ruler | null;

    protected override _draw(): Promise<void>;

    protected override _tearDown(): Promise<void>;

    /** Draw the cursors container */
    drawCursors(): void;

    /** Draw Ruler tools */
    drawRulers(): void;

    /**
     * Draw the select rectangle given an event originated within the base canvas layer
     * @param coords The rectangle coordinates of the form {x, y, width, height}
     */
    drawSelect({ x, y, width, height }: { x: number; y: number; width: number; height: number }): void;

    protected override _deactivate(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /** Handle mousemove events on the game canvas to broadcast activity of the user's cursor position */
    protected _onMouseMove(event: PIXI.FederatedEvent): void;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Create and draw the Cursor object for a given User
     * @param user The User document for whom to draw the cursor Container
     */
    drawCursor(user: User): object;

    /**
     * Update the cursor when the user moves to a new position
     * @param user     The User for whom to update the cursor
     * @param position The new cursor position
     */
    updateCursor(user: User, position: Point): void;

    /**
     * Update display of an active Ruler object for a user given provided data
     * @param user      The User for whom to update the ruler
     * @param rulerData Data which describes the new ruler measurement to display
     */
    updateRuler(user: User, rulerData: object): void;
  }
}

interface DoorContainer extends PIXI.Container {
  children: DoorControl[];
}

interface RulerContainer extends PIXI.Container {
  children: Ruler[];
}

declare global {
  /** A CanvasLayer responsible for drawing a square grid */
  class GridLayer extends CanvasLayer {
    grid: BaseGrid;

    highlight: PIXI.Container;

    highlightLayers: Record<string, PIXI.Graphics>;

    static override get layerOptions(): GridLayerOptions;

    /** The grid type rendered in this Scene */
    get type(): GridType;

    /** A convenient reference to the pixel grid size used throughout this layer */
    get size(): number;

    /** Get grid unit width */
    get w(): number;

    /** Get grid unit height */
    get h(): number;

    /** A boolean flag for whether the current grid is hexagonal */
    get isHex(): boolean;

    /**
     * Draw the grid
     * @param preview Override settings used in place of those saved to the Scene data
     */
    protected _draw({ type, dimensions, gridColor, gridAlpha }?: GridDrawOptions): Promise<void>;

    /**
     * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
     * @param x The exact target location x
     * @param y The exact target location y
     * @param [interval=1]  An interval of grid spaces at which to snap, default is 1. If the interval is zero, no snapping occurs.
     */
    getSnappedPosition(x: number, y: number, interval?: number): Point;

    /**
     * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
     * @return An Array [x, y] of the top-left coordinate of the square which contains (x, y)
     */
    getTopLeft(x: number, y: number): PointArray;

    /**
     * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
     * @return An Array [x, y] of the central point of the square which contains (x, y)
     */
    getCenter(x: number, y: number): PointArray;

    /**
     * Measure the grid-wise distance between two point coordinates.
     * @param origin The origin point
     * @param target The target point
     * @param [options] Additional options which modify the measurement
     * @return The measured distance between these points
     *
     * @example
     * let distance = canvas.grid.measureDistance({x: 1000, y: 1000}, {x: 2000, y: 2000});
     */
    measureDistance(origin: Point, target: Point, options?: MeasureDistancesOptions): number;

    /**
     * Measure the distance traveled over an array of distance segments.
     * @param segments  An array of measured segments
     * @param [options] Additional options which modify the measurement
     */
    measureDistances(segments: Segment[], options?: MeasureDistancesOptions): number[];

    /* -------------------------------------------- */
    /*  Grid Highlighting Methods                   */

    /* -------------------------------------------- */

    /**
     * Define a new Highlight graphic
     * @param name The name for the referenced highlight layer
     */
    addHighlightLayer(name: string): PIXI.Graphics | undefined;

    /**
     * Clear a specific Highlight graphic
     * @param name The name for the referenced highlight layer
     */
    clearHighlightLayer(name: string): void;

    /**
     * Destroy a specific Highlight graphic
     * @param name The name for the referenced highlight layer
     */
    destroyHighlightLayer(name: string): void;

    /**
     * Obtain the highlight layer graphic by name
     * @param name The name for the referenced highlight layer
     */
    getHighlightLayer(name: string): GridHighlight | undefined;

    /**
     * Add highlighting for a specific grid position to a named highlight graphic
     * @param name    The name for the referenced highlight layer
     * @param options Options for the grid position that should be highlighted
     */
    highlightPosition(name: string, options: Record<string, unknown>): void;

    /**
     * Test if a specific row and column position is a neighboring location to another row and column coordinate
     * @param r0 The original row position
     * @param c0 The original column position
     * @param r1 The candidate row position
     * @param c1 The candidate column position
     */
    isNeighbor(r0: number, c0: number, r1: number, c1: number): boolean;
  }

  interface GridDrawOptions {
    type?: GridType | null;
    dimensions?: SceneDimensions | null;
    gridColor?: string | null;
    gridAlpha?: number | null;
  }

  interface MeasureDistancesOptions {
    /** Return the distance in grid increments rather than the co-ordinate distance. */
    gridSpaces?: boolean;
  }
}

interface GridLayerOptions extends CanvasLayerOptions {
  name: 'grid';
}

declare global {
  /**
   * The base grid class.
   * This double-dips to implement the "gridless" option
   */
  abstract class BaseGrid extends PIXI.Container {
    constructor(options: BaseGridOptions);

    options: BaseGridOptions;

    /** Grid Unit Width */
    w: number;

    /** Grid Unit Height */
    h: number;

    /** Highlight active grid spaces */
    highlight: PIXI.Container;

    /**
     * Draw the grid. Subclasses are expected to override this method to perform their type-specific drawing logic.
     * @param [preview] Override settings used in place of those saved to the scene data.
     * @param [preview.gridColor=null] The grid color.
     * @param [preview.gridAlpha=null] The grid transparency.
     */
    draw(preview?: { gridColor?: string | null; gridAlpha?: string | null }): this;

    /**
     * Highlight a grid position for a certain coordinates
     * @param layer  The highlight layer to use
     * @param x      The x-coordinate of the highlighted position
     * @param y      The y-coordinate of the highlighted position
     * @param color  The hex fill color of the highlight
     * @param border The hex border color of the highlight
     * @param alpha  The opacity of the highlight
     */
    highlightGridPosition(
      layer: GridHighlight,
      data?: { x?: number; y?: number; color?: number; border?: number; alpha?: number },
    ): this;

    /* -------------------------------------------- */
    /*  Grid Measurement Methods
        /* -------------------------------------------- */

    /**
     * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
     * @return    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
     */
    getTopLeft(x: number, y: number): number[];

    /* -------------------------------------------- */

    /**
     * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
     * @return    An Array [x, y] of the central point of the square which contains (x, y)
     */
    getCenter(x: number, y: number): number[];

    /* -------------------------------------------- */

    /**
     * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
     * Under a "gridless" system, every pixel position is a valid snapping position
     *
     * @param x The exact target location x
     * @param y The exact target location y
     * @param interval An interval of grid spaces at which to snap, default is 1
     *
     * @return  An object containing the coordinates of the snapped location
     */
    getSnappedPosition(x: number, y: number, interval: number): { x: number; y: number };

    /* -------------------------------------------- */

    /**
     * Given a pair of pixel coordinates, return the grid position as an Array.
     * Always round down to the nearest grid position so the pixels are within the grid space (from top-left).
     * @param x The x-coordinate pixel position
     * @param y The y-coordinate pixel position
     * @return  An array representing the position in grid units
     */
    getGridPositionFromPixels(x: number, y: number): number[];

    /* -------------------------------------------- */

    /**
     * Given a pair of grid coordinates, return the pixel position as an Array.
     * Always round up to a whole pixel so the pixel is within the grid space (from top-left).
     * @param x The x-coordinate grid position
     * @param y The y-coordinate grid position
     * @return An array representing the position in pixels
     */
    getPixelsFromGridPosition(x: number, y: number): number[];

    /* -------------------------------------------- */

    /**
     * Shift a pixel position [x,y] by some number of grid units dx and dy
     * @param x    The starting x-coordinate in pixels
     * @param y    The starting y-coordinate in pixels
     * @param dx   The number of grid positions to shift horizontally
     * @param dy   The number of grid positions to shift vertically
     */
    shiftPosition(x: number, y: number, dx: number, dy: number): number[];

    /* -------------------------------------------- */

    /**
     * Measure the distance traversed over an array of measured segments
     * @param segments  An Array of measured movement segments
     * @param options   Additional options which modify the measurement
     * @return  An Array of distance measurements for each segment
     */
    measureDistances(segments: Segment[], options: MeasureDistancesOptions): number[];

    /* -------------------------------------------- */

    /**
     * Get the grid row and column positions which are neighbors of a certain position
     * @param row  The grid row coordinate against which to test for neighbors
     * @param col  The grid column coordinate against which to test for neighbors
     * @return      An array of grid positions which are neighbors of the row and column
     */
    getNeighbors(row: number, col: number): number[];
  }

  interface BaseGridOptions {
    dimensions: {
      size: number;
    };
  }

  interface Segment {
    ray: Ray;
    label: PIXI.Container;
  }

  interface MeasureDistancesOptions {
    gridSpaces?: boolean;
  }
}

declare global {
  /**
   * An extension of PIXI.Container used as the interface frame for a PlaceableObject on the ControlsLayer
   * @see {@link PlaceableObject}
   * @see {@link ControlsLayer}
   */
  class ObjectHUD<T extends PlaceableObject> extends PIXI.Container {
    constructor(object: T);

    /** The object that this HUD container is linked to */
    object: T;

    /** Use the linked object's transform matrix to easily synchronize position */
    transform: PIXI.Transform;

    override readonly visible: boolean;

    override readonly renderable: boolean;

    /**
     * Display scrolling status text originating from this ObjectHUD container.
     * @param content The text content to display
     * @param [anchor=0]      The original anchor point where the text first appears
     * @param [direction=2]   The direction in which the text scrolls
     * @param [duration=2000] The duration of the scrolling effect in milliseconds
     * @param [jitter=0]      An amount of randomization between 0 and 1 to apply to the initial position
     * @param [textStyle={}]  Additional parameters of PIXI.TextStyle which are applied to the text
     * @returns The created PreciseText object which is scrolling
     */
    createScrollingText(
      content: string,
      { anchor, direction, duration, jitter, ...textStyle }?: ScrollingTextOptions,
    ): Promise<PreciseText | null>;

    /**
     * Orchestrate the animation of the scrolling text in this HUD
     * @param text     The PrecisText instance to animate
     * @param duration A desired duration of animation
     * @param dx       A horizontal distance to animate the text
     * @param dy       A vertical distance to animate the text
     */
    protected _animateScrollText(text: PreciseText, duration: number, dx?: number, dy?: number): Promise<void>;
  }
}

interface ScrollingTextOptions extends Partial<PIXI.ITextStyle> {
  anchor?: number;
  direction?: number;
  duration?: number;
  jitter?: number;
}

declare global {
  interface QuadtreeObject<
    TPlaceableObject extends PlaceableObject = PlaceableObject,
    TQuadtree extends Quadtree<TPlaceableObject> = Quadtree<TPlaceableObject>,
  > {
    r: Rectangle;
    t: TPlaceableObject;
    n: Set<TQuadtree>;
  }

  /**
   * A Quadtree implementation that supports collision detection for rectangles.
   *
   * @param {Rectangle} bounds       The outer bounds of the region
   * @param [options]                Additional options which configure the Quadtree
   * @param [options.maxObjects=20]  The maximum number of objects per node
   * @param [options.maxDepth=4]     The maximum number of levels within the root Quadtree
   * @param [options._depth=0]       The depth level of the sub-tree. For internal use
   * @param [options._root]          The root of the quadtree. For internal use
   */
  class Quadtree<TPlaceableObject extends PlaceableObject> {
    /** The bounding rectangle of the region */
    bounds: Rectangle;

    /** The maximum number of objects allowed within this node before it must split */
    maxObjects: number;

    /** The maximum number of levels that the base quadtree is allowed */
    maxDepth: number;

    /** The depth of this node within the root Quadtree */
    depth: number;

    /** The objects contained at this level of the tree */
    objects: QuadtreeObject<TPlaceableObject, this>[];

    /** Children of this node */
    nodes: this[];

    /** The root Quadtree */
    root: this;

    constructor(
      bounds: Rectangle,
      options?: { maxObjects?: number; maxDepth?: number; _depth?: number; _root?: Quadtree<TPlaceableObject> },
    );

    /**
     * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
     * @enum {number}
     */
    static INDICES: { tl: number; tr: number; bl: number; br: number };

    /**
     * Return an array of all the objects in the Quadtree (recursive)
     */
    get all(): QuadtreeObject<TPlaceableObject, this>[];

    /* -------------------------------------------- */
    /*  Tree Management                             */
    /* -------------------------------------------- */

    /**
     * Split this node into 4 sub-nodes.
     * @returns The split Quadtree
     */
    split(): this;

    /* -------------------------------------------- */
    /*  Object Management                           */
    /* -------------------------------------------- */

    /**
     * Clear the quadtree of all existing contents
     * @returns The cleared Quadtree
     */
    clear(): this;

    /**
     * Add a rectangle object to the tree
     * @param  obj  The object being inserted
     * @returns     The Quadtree nodes the object was added to.
     */
    insert(obj: QuadtreeObject<TPlaceableObject, this>): this[];

    /**
     * Remove an object from the quadtree
     * @param target     The quadtree target being removed
     * @returns          The Quadtree for method chaining
     */
    remove(target: TPlaceableObject): this;

    /**
     * Remove an existing object from the quadtree and re-insert it with a new position
     * @param obj  The object being inserted
     * @returns    The Quadtree nodes the object was added to
     */
    update(obj: QuadtreeObject<TPlaceableObject, this>): this[];

    /* -------------------------------------------- */
    /*  Target Identification                       */
    /* -------------------------------------------- */

    /**
     * Get all the objects which could collide with the provided rectangle
     * @param rect    The normalized target rectangle
     * @param [options]                    Options affecting the collision test.
     * @param [options.collisionTest]    Function to further refine objects to return
     *   after a potential collision is found. Parameters are the object and rect, and the
     *   function should return true if the object should be added to the result set.
     * @param [options._s]                    The existing result set, for internal use.
     * @returns   The objects in the Quadtree which represent potential collisions
     */
    getObjects(
      rect: Rectangle,
      options?: {
        collisionTest?: (obj: QuadtreeObject, rect: Rectangle) => boolean;
        _s: Set<TPlaceableObject>;
      },
    ): Set<TPlaceableObject>;

    /**
     * Obtain the leaf nodes to which a target rectangle belongs.
     * This traverses the quadtree recursively obtaining the final nodes which have no children.
     * @param rect  The target rectangle.
     * @returns     The Quadtree nodes to which the target rectangle belongs
     */
    getLeafNodes(rect: Rectangle): this[];

    /**
     * Obtain the child nodes within the current node which a rectangle belongs to.
     * Note that this function is not recursive, it only returns nodes at the current or child level.
     * @param rect  The target rectangle.
     * @returns     The Quadtree nodes to which the target rectangle belongs
     */
    getChildNodes(rect: Rectangle): this[];

    /** Identify all nodes which are adjacent to this one within the parent Quadtree. */
    getAdjacentNodes(): this[];

    /**
     * Visualize the nodes and objects in the quadtree
     * @param [options]
     * @param [options.objects]    Visualize the rectangular bounds of objects in the Quadtree. Default is false.
     */
    private visualize(options?: { object?: boolean }): void;
  }

  /**
   * A subclass of Quadtree specifically intended for classifying the location of objects on the game canvas.
   */
  class CanvasQuadtree<TPlaceableObject extends PlaceableObject> extends Quadtree<TPlaceableObject> {}
}

declare global {
  /**
   * A ray for the purposes of computing sight and collision
   * Given points A[x,y] and B[x,y]
   *
   * Slope-Intercept form:
   * y = a + bx
   * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
   *
   * Parametric form:
   * R(t) = (1-t)A + tB
   */
  class Ray {
    constructor(A: Point, B: Point);

    // Store points
    A: Point;
    B: Point;

    // Origins
    y0: number;
    x0: number;

    // Slopes
    dx: number;
    dy: number;

    /** The slope of the ray, dy over dx */
    slope: number;

    /** The normalized angle of the ray in radians on the range (-PI, PI) */
    angle: number;

    /** The distance of the ray */
    distance: number;

    /**
     * Return the value of the angle normalized to the range (0, 2*PI)
     * This is useful for testing whether an angle falls between two others
     */
    readonly normAngle: number;

    static fromAngle(x: number, y: number, radians: number, distance: number): Ray;

    static fromArrays(A: [], B: []): Ray;

    /**
     * Project the Array by some proportion of it's initial distance.
     * Return the coordinates of that point along the path.
     * @param t The distance along the Ray
     * @return The coordinates of the projected point
     */
    project(t: number): Point;

    shiftAngle(angleOffset: number, distance: number): Ray;

    /**
     * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
     * http://paulbourke.net/geometry/pointlineplane/
     */
    intersectSegment(coords: [number]): Vector2;

    static _getIntersection(
      x1: number,
      y1: number,
      x2: number,
      y2: number,
      x3: number,
      y3: number,
      x4: number,
      y4: number,
    ): Vector2;
  }
}

declare global {
  class Canvas<
    TScene extends Scene = Scene,
    TAmbientLight extends AmbientLight<AmbientLightDocument<TScene>> = AmbientLight<AmbientLightDocument<TScene>>,
    TMeasuredTemplate extends MeasuredTemplate<MeasuredTemplateDocument<TScene>> = MeasuredTemplate<
      MeasuredTemplateDocument<TScene>
    >,
    TToken extends Token<TokenDocument<TScene>> = Token<TokenDocument<TScene>>,
    TEffectsCanvasGroup extends EffectsCanvasGroup = EffectsCanvasGroup,
  > {
    /** A perception manager interface for batching lighting, sight, and sound updates */
    perception: PerceptionManager;

    /** A flag to indicate whether a new Scene is currently being drawn. */
    loading: boolean;

    /** A promise that resolves when the canvas is first initialized and ready. */
    initializing: Promise<void> | null;

    /** The current pixel dimensions of the displayed Scene, or null if the Canvas is blank. */
    dimensions: SceneDimensions;

    /** A set of blur filter instances which are modified by the zoom level and the "soft shadows" setting */
    blurFilters: Set<PIXI.Filter>;

    /**
     * A reference to the MouseInteractionManager that is currently controlling pointer-based interaction, or null.
     */
    currentMouseManager: MouseInteractionManager | null;

    /**
     * Configure options passed to the texture loaded for the Scene.
     * This object can be configured during the canvasInit hook before textures have been loaded.
     */
    loadTexturesOptions: { expireCache: boolean; additionalSources: string[] };

    /**
     * Configure options used by the visibility framework for special effects
     * This object can be configured during the canvasInit hook before visibility is initialized.
     */
    visibilityOptions: { persistentVision: boolean };

    /**
     * Configure options passed to initialize blur for the Scene and override normal behavior.
     * This object can be configured during the canvasInit hook before blur is initialized.
     */
    blurOptions: {
      enabled: boolean;
      blurClass: object;
      strength: number;
      passes: number;
      kernels: number;
    };

    /**
     * Configure the Textures to apply to the Scene.
     * Textures registered here will be automatically loaded as part of the TextureLoader.loadSceneTextures workflow.
     * Textures which need to be loaded should be configured during the "canvasInit" hook.
     */
    sceneTextures: {
      background?: PIXI.Texture;
      foreground?: PIXI.Texture;
      fogOverlay?: PIXI.Texture;
    };

    /** Record framerate performance data. */
    fps: {
      average: number;
      values: number[];
      render: number;
      element: HTMLElement | null;
    };

    /** The singleton interaction manager instance which handles mouse interaction on the Canvas. */
    mouseInteractionManager: MouseInteractionManager;

    /** Configured performance settings which affect the behavior of the Canvas and its renderer. */
    performance: CanvasPerformanceSettings;

    /** A list of supported webGL capabilities and limitations. */
    supported: CanvasSupportedComponents;

    /** Is the photosensitive mode enabled? */
    photosensitiveMode: boolean;

    /** The renderer screen dimensions. */
    screenDimensions: [number, number];

    /* -------------------------------------------- */
    /*  Canvas Groups and Layers                    */
    /* -------------------------------------------- */

    /** The singleton PIXI.Application instance rendered on the Canvas. */
    app: PIXI.Application;

    /** The primary stage container of the PIXI.Application. */
    stage: PIXI.Container;

    /**
     * The primary Canvas group which generally contains tangible physical objects which exist within the Scene.
     * This group is a {@link CachedContainer} which is rendered to the Scene as a {@link SpriteMesh}.
     * This allows the rendered result of the Primary Canvas Group to be affected by a {@link BaseSamplerShader}.
     */
    primary: PrimaryCanvasGroup;

    /**
     * The effects Canvas group which modifies the result of the {@link PrimaryCanvasGroup} by adding special effects.
     * This includes lighting, weather, vision, and other visual effects which modify the appearance of the Scene.
     */
    effects: TEffectsCanvasGroup;

    /**
     * The interface Canvas group which is rendered above other groups and contains all interactive elements.
     * The various {@link InteractionLayer} instances of the interface group provide different control sets for
     * interacting with different types of {@link Document}s which can be represented on the Canvas.
     */
    interface: InterfaceCanvasGroup;

    /** The overlay Canvas group which is rendered above other groups and contains elements not bound to stage transform. */
    overlay: object;

    /** The singleton HeadsUpDisplay container which overlays HTML rendering on top of this Canvas. */
    hud: HeadsUpDisplay;

    /** Position of the mouse on stage. */
    mousePosition: PIXI.Point;

    // Layers
    controls: ControlsLayer;
    drawings: DrawingsLayer;
    grid: GridLayer;
    lighting: TAmbientLight['layer'];
    notes: NotesLayer;
    sounds: SoundsLayer;
    templates: TMeasuredTemplate['layer'];
    tiles: Tile['layer'];
    tokens: TToken['layer'];
    walls: WallsLayer;

    constructor();

    /* -------------------------------------------- */
    /*  Properties and Attributes                   */
    /* -------------------------------------------- */

    /** A flag for whether the game Canvas is initialized and ready for drawing. */
    get initialized(): boolean;

    /** A reference to the currently displayed Scene document, or null if the Canvas is currently blank. */
    get scene(): TScene | null;

    /** A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise. */
    get ready(): boolean;

    /** The fog of war bound to this canvas */
    get fog(): object;

    /** The color manager class bound to this canvas */
    get colorManager(): CanvasColorManager;

    /** The colors bound to this scene and handled by the color manager. */
    get colors(): CanvasColorManager['colors'];

    /** Shortcut to get the masks container from HiddenCanvasGroup. */
    get masks(): PIXI.Container;

    /** The id of the currently displayed Scene. */
    get id(): string | null;

    /** The pixel radius of blur distance that should be applied for the current zoom level */
    blurDistance: number;

    /** A mapping of named CanvasLayer classes which defines the layers which comprise the Scene. */
    static get layers(): Record<string, CanvasLayer>;

    /** An Array of all CanvasLayer instances which are active on the Canvas board */
    get layers(): CanvasLayer[];

    /** The currently displayed darkness level, which may override the saved Scene value. */
    get darknessLevel(): number;

    /** Return a reference to the active Canvas Layer */
    get activeLayer(): InteractionLayer | null;

    /* -------------------------------------------- */
    /*  Initialization                              */
    /* -------------------------------------------- */

    /**
     * Initialize the Canvas by creating the HTML element and PIXI application.
     * This step should only ever be performed once per client session.
     * Subsequent requests to reset the canvas should go through Canvas#draw
     */
    initialize(): void;

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /**
     * Draw the game canvas.
     * @param [scene] A specific Scene document to render on the Canvas
     * @returns A Promise which resolves once the Canvas is fully drawn
     */
    draw(scene?: TScene | undefined): Promise<this>;

    /** When re-drawing the canvas, first tear down or discontinue some existing processes */
    tearDown(): Promise<void>;

    /**
     * Get the value of a GL parameter
     * @param parameter The GL parameter to retrieve
     * @returns The GL parameter value
     */
    getGLParameter(parameter: string): unknown;

    /**
     * Initialize the starting view of the canvas stage
     * If we are re-drawing a scene which was previously rendered, restore the prior view position
     * Otherwise set the view to the top-left corner of the scene at standard scale
     */
    initializeCanvasPosition(): void;

    /** Event handler for the drop portion of a drag-and-drop event. */
    protected _onDrop(event: DragEvent): void;

    /** Given an embedded object name, get the canvas layer for that object */
    getLayerByEmbeddedName(embeddedName: string): PlaceablesLayer | null;

    /**
     * Get the InteractionLayer of the canvas which manages Documents of a certain collection within the Scene.
     * @param collectionName The collection name
     * @returns The canvas layer
     */
    getCollectionLayer(collectionName: string): PlaceablesLayer | undefined;

    /**
     * Get the canvas active dimensions based on the size of the scene's map.
     * We expand the image size by a factor of 1.5 and round to the nearest 2x grid size.
     * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
     * @see {@link documents.BaseScene.getDimensions}
     * @param dimensions The scene dimensions data being established
     */
    static getDimensions(dimensions: GetDimensionsParams): SceneDimensions;

    /** Configure performance settings for hte canvas application based on the selected performance mode */
    protected _configurePerformanceMode(): CanvasPerformanceSettings;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /** Activate framerate tracking by adding an HTML element to the display and refreshing it every frame. */
    activateFPSMeter(): void;

    /** Deactivate framerate tracking by canceling ticker updates and removing the HTML element. */
    deactivateFPSMeter(): void;

    /**
     * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
     * @param x     The x-coordinate of the pan destination
     * @param y     The y-coordinate of the pan destination
     * @param scale The zoom level (max of CONFIG.Canvas.maxZoom) of the action
     */
    pan({ x, y, scale }?: { x?: number | null; y?: number | null; scale?: number | null }): void;

    /**
     * Animate panning the canvas to a certain destination coordinate and zoom scale
     * Customize the animation speed with additional options
     * Returns a Promise which is resolved once the animation has completed
     *
     * @param view The desired view parameters
     * @param [view.x]            The destination x-coordinate
     * @param [view.y]            The destination y-coordinate
     * @param [view.scale]        The destination zoom scale
     * @param [view.duration=250] The total duration of the animation in milliseconds; used if speed is not set
     * @param [view.speed]        The speed of animation in pixels per second; overrides duration if set
     * @returns A Promise which resolves once the animation has been completed
     */
    animatePan(view?: { x?: number; y?: number; scale?: number; duration?: number }): Promise<void>;

    /**
     * Recenter the canvas
     * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window
     * @returns A Promise which resolves once the animation has been completed
     */
    recenter(coordinates: [number, number]): Promise<void>;

    /** Highlight objects on any layers which are visible */
    highlightObjects(active: number): void;

    /**
     * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter
     * @param x     The requested x-coordinate
     * @param y     The requested y-coordinate
     * @param scale The requested scale
     * @return The allowed scale
     */
    protected _constrainView({ x, y, scale }: { x: number; y: number; scale: number }): {
      x: number;
      y: number;
      scale: number;
    };

    /**
     * Displays a Ping both locally and on other connected client, following these rules:
     * 1) Displays on the current canvas Scene
     * 2) If ALT is held, becomes an ALERT ping
     * 3) Else if the user is GM and SHIFT is held, becomes a PULL ping
     * 4) Else is a PULSE ping
     * @param origin  Point to display Ping at
     * @param options Additional options to configure how the ping is drawn.
     */
    ping(origin: Point, options?: Record<string, unknown>): Promise<boolean>;

    /**
     * Create a BlurFilter instance and register it to the array for updates when the zoom level changes.
     * @param blurStrength The desired blur strength to use for this filter
     */
    createBlurFilter(blurStrength?: number): PIXI.BlurFilter;

    /**
     * Add a filter to the blur filter list. The filter must have the blur property
     * @param filter The Filter instance to add
     * @returns The added filter for method chaining
     */
    addBlurFilter(filter: PIXI.BlurFilter): PIXI.BlurFilter | void;

    /**
     * Update the blur strength depending on the scale of the canvas stage.
     * This number is zero if "soft shadows" are disabled
     * @param strength Optional blur strength to apply
     */
    updateBlur(strength?: Number | undefined): void;

    /**
     * Convert canvas co-ordinates to the client's viewport.
     * @param origin The canvas coordinates.
     * @returns The corresponding co-ordinates relative to the client's viewport.
     */
    clientCoordinatesFromCanvas(origin: Point): Point;

    /**
     * Convert client viewport co-ordinates to canvas co-ordinates.
     * @param origin The client coordinates.
     * @returns The corresponding canvas co-ordinates.
     */
    canvasCoordinatesFromClient(origin: Point): Point;

    /**
     * Determine whether given canvas co-ordinates are off-screen.
     * @param position The canvas co-ordinates.
     * @returns Is the coordinate outside the screen bounds?
     */
    isOffscreen(position: Point): boolean;

    /**
     * Remove all children of the display object and call one cleaning method:
     * clean first, then tearDown, and destroy if no cleaning method is found.
     * @param displayObject   The display object to clean.
     * @param [destroy]       If textures should be destroyed.
     */
    static clearContainer(displayObject: PIXI.DisplayObject, destroy?: boolean): void;

    /**
     * Get a texture with the required configuration and clear color.
     * @param [options]
     * @param [options.clearColor]           The clear color to use for this texture. Transparent by default.
     * @param [options.textureConfiguration] The render texture configuration.
     */
    static getRenderTexture(options?: { clearColor?: number[]; textureConfiguration?: object }): PIXI.RenderTexture;

    /**
     * Pan the canvas view when the cursor position gets close to the edge of the frame
     * @param event The originating mouse movement event
     */
    _onDragCanvasPan(event: MouseEvent): void;

    /**
     * Determine selection coordinate rectangle during a mouse-drag workflow
     * @param event
     */
    _onDragSelect(event: PIXI.FederatedEvent): void;
  }

  type DrawnCanvas<T extends Canvas = Canvas> = {
    [K in keyof T]: NonNullable<T[K]>;
  };
}

interface CanvasPerformanceSettings {
  mode: CanvasPerformanceMode;
  blur: {
    enabled: boolean;
    illumination: boolean;
  };
  mipmap: 'ON' | 'OFF';
  msaa: boolean;
  fps: number;
  tokenAnimation: boolean;
  lightAnimation: boolean;
  textures: {
    enabled: boolean;
    maxSize: number;
    p2Steps: number;
    p2StepsMax: number;
  };
}

interface CanvasSupportedComponents {
  /** Is WebGL2 supported? */
  webGL2: boolean;
  /** Is reading pixels in RED format supported? */
  readPixelsRED: boolean;
  /** Is the OffscreenCanvas supported? */
  offscreenCanvas: boolean;
}

declare global {
  /**
   * A data structure for tracking a set of boolean status flags.
   * This is a restricted set which can only accept flag values which are pre-defined.
   * @param {Object<RenderFlag>} flags  An object which defines the flags which are supported for tracking
   * @param {object} [config]           Optional configuration
   * @param {RenderFlagObject} [config.object]  The object which owns this RenderFlags instance
   * @param {number} [config.priority]          The ticker priority at which these render flags are handled
   */
  class RenderFlags extends Set<string> {
    constructor(flags?: Record<string, RenderFlag>, config?: { object?: PlaceableObject; priority?: number });

    /**
     * @returns The flags which were previously set that have been cleared.
     */
    override clear(): Record<string, boolean>;

    /**
     * Allow for handling one single flag at a time.
     * This function returns whether the flag needs to be handled and removes it from the pending set.
     */
    handle(flag: string): boolean;

    /**
     * Activate certain flags, also toggling propagation and reset behaviors
     * @param {Object<boolean>} changes
     */
    set(changes: Record<string, boolean>): void;
  }

  interface RenderFlag {
    /** Activating this flag also sets these flags to true */
    propagate: string[];
    /** Activating this flag resets these flags to false */
    reset: string[];
  }
}

declare global {
  /** An internal data structure for polygon vertices */
  class PolygonVertex {
    x: number;
    y: number;
    key: number;
    _distance: number;
    _d2: unknown;
    protected _index: number;

    /**
     * The set of edges which connect to this vertex.
     * This set is initially empty and populated later after vertices are de-duplicated.
     */
    edges: Set<PolygonEdge>;

    /** The subset of edges which continue clockwise from this vertex. */
    cwEdges: Set<PolygonEdge>;

    /** The subset of edges which continue counter-clockwise from this vertex. */
    ccwEdges: Set<PolygonEdge>;

    /** The set of vertices collinear to this vertex */
    collinearVertices: Set<PolygonVertex>;

    /** The maximum restriction type of this vertex */
    type: WallSenseType | null;

    constructor(x: number, y: number, { distance, index }?: { distance?: number; index?: number });

    /** Is this vertex an endpoint of one or more edges? */
    isEndpoint: boolean;

    /** Does this vertex have a single counterclockwise limiting edge? */
    isLimitingCCW: boolean;

    /** Does this vertex have a single clockwise limiting edge? */
    isLimitingCW: boolean;

    /** Does this vertex have non-limited edges or 2+ limited edges counterclockwise? */
    isBlockingCCW: boolean;

    /** Does this vertex have non-limited edges or 2+ limited edges clockwise? */
    isBlockingCW: boolean;

    /**
     * Associate an edge with this vertex.
     * @param edge The edge being attached
     * @param orientation The orientation of the edge with respect to the origin
     */
    attachEdge(edge: PolygonEdge, orientation?: number): void;

    /** Is this vertex limited in type? */
    get isLimited(): boolean;

    /** Is this vertex terminal (at the maximum radius) */
    get isTerminal(): boolean;

    /**
     * Is this vertex the same point as some other vertex?
     * @param other Some other vertex
     * @returns Are they the same point?
     */
    equals(other: PolygonVertex): boolean;

    /**
     * Construct a PolygonVertex instance from some other Point structure.
     * @param point     The point
     * @param [options] Additional options that apply to this vertex
     * @returns The constructed vertex
     */
    static fromPoint(point: Point, options?: object): PolygonVertex;
  }

  /** An internal data structure for polygon edges */
  class PolygonEdge {
    A: PolygonVertex;

    B: PolygonVertex;

    type: WallSenseType | undefined;

    wall: Wall<WallDocument<Scene | null>> | undefined;

    constructor(a: PolygonVertex, b: PolygonVertex, type?: WallSenseType, wall?: Wall<WallDocument<Scene | null>>);

    /** An internal flag used to record whether an Edge represents a canvas boundary. */
    protected _isBoundary: boolean;

    /** Is this edge limited in type? */
    get isLimited(): boolean;

    /**
     * Construct a PolygonEdge instance from a Wall placeable object.
     * @param wall The Wall from which to construct an edge
     * @param type The type of polygon being constructed
     */
    static fromWall(wall: Wall<WallDocument<Scene | null>>, type: string): PolygonEdge;
  }
}

declare global {
  /** An extension of the default PIXI.Polygon which is used to represent the line of sight for a point source. */
  abstract class PointSourcePolygon extends PIXI.Polygon {
    /** The rectangular bounds of this polygon */
    bounds: PIXI.Rectangle;

    /** The origin point of the source polygon. */
    origin: Point;

    /** The configuration of this polygon. */
    config: PointSourcePolygonConfig;

    /** A cached array of SightRay objects used to compute the polygon. */
    rays?: Ray[];

    /** An indicator for whether this polygon is constrained by some boundary shape? */
    get isConstrained(): boolean;

    /**
     * Benchmark the performance of polygon computation for this source
     * @param iterations The number of test iterations to perform
     * @param origin The origin point to benchmark
     * @param config The polygon configuration to benchmark
     */
    static benchmark(iterations: number, origin: Point, config: PointSourcePolygonConfig): void;

    /**
     * Compute the polygon given a point origin and radius
     * @param origin      The origin source point
     * @param [config={}] Configuration options which customize the polygon computation
     * @returns The computed polygon instance
     */
    static create<T extends PointSourcePolygon>(
      this: ConstructorOf<T>,
      origin: Point,
      config?: PointSourcePolygonConfig,
    ): T;

    override contains(x: number, y: number): boolean;

    /* -------------------------------------------- */
    /*  Polygon Computation                         */
    /* -------------------------------------------- */

    /**
     * Compute the polygon using the origin and configuration options.
     * @returns The computed polygon
     */
    compute(): this;

    /** Perform the implementation-specific computation */
    protected abstract _compute(): void;

    /**
     * Customize the provided configuration object for this polygon type.
     * @param origin The provided polygon origin
     * @param config The provided configuration object
     */
    initialize(origin: Point, config: PointSourcePolygonConfig): void;

    /**
     * Apply a constraining boundary shape to an existing PointSourcePolygon.
     * Return a new instance of the polygon with the constraint applied.
     * The new instance is only a "shallow clone", as it shares references to component properties with the original.
     * @param constraint            The constraining boundary shape
     * @param [intersectionOptions] Options passed to the shape intersection method
     * @returns A new constrained polygon
     */
    applyConstraint(constraint?: PIXI.Circle | PIXI.Rectangle | PIXI.Polygon, intersectionOptions?: object): this;

    /* -------------------------------------------- */
    /*  Collision Testing                           */
    /* -------------------------------------------- */

    /**
     * Test whether a Ray between the origin and destination points would collide with a boundary of this Polygon
     * @param origin        An origin point
     * @param destination   A destination point
     * @param config        The configuration that defines a certain Polygon type
     * @param [config.mode] The collision mode to test: "any", "all", or "closest"
     * @returns The collision result depends on the mode of the test:
     *          * any: returns a boolean for whether any collision occurred
     *          * all: returns a sorted array of PolygonVertex instances
     *          * closest: returns a PolygonVertex instance or null
     */
    static testCollision(
      origin: Point,
      destination: Point,
      config?: PointSourcePolygonConfig & { mode: 'closest' },
    ): PolygonVertex | null;
    static testCollision(
      origin: Point,
      destination: Point,
      config?: PointSourcePolygonConfig & { mode: 'any' },
    ): boolean;
    static testCollision(
      origin: Point,
      destination: Point,
      config?: PointSourcePolygonConfig & { mode: 'all' },
    ): PolygonVertex[];
    static testCollision(
      origin: Point,
      destination: Point,
      config?: PointSourcePolygonConfig & { mode?: 'any' | 'all' | 'closest' },
    ): boolean | PolygonVertex | PolygonVertex[] | null;

    /**
     * Determine the set of collisions which occurs for a Ray.
     * @param ray  The Ray to test
     * @param mode The collision mode being tested
     * @returns The collision test result
     */
    protected abstract _testCollision(ray: Ray, mode: string): boolean | PolygonVertex | PolygonVertex[] | null;

    /* -------------------------------------------- */
    /*  Visualization and Debugging                 */
    /* -------------------------------------------- */

    /** Visualize the polygon, displaying its computed area, rays, and collision points */
    visualize(): void;
  }

  interface PointSourcePolygonConfig {
    /** The type of polygon being computed */
    type?: WallRestrictionType;
    /** The angle of emission, if limited */
    angle?: number;
    /** The desired density of padding rays, a number per PI */
    density?: number;
    /** A limited radius of the resulting polygon */
    radius?: number;
    /** The direction of facing, required if the angle is limited*/
    rotation?: number;
    /** Display debugging visualization and logging for the polygon */
    debug?: boolean;
    /** Is this polygon constrained by any walls? */
    walls?: boolean;
    /** The object (if any) that spawned this polygon. */
    source?: PointSource;
    /** Limiting polygon boundary shape*/
    boundaryShape?: (PIXI.Rectangle | PIXI.Circle | PIXI.Polygon)[];
  }
}

declare global {
  /**
   * A container group which contains visual effects rendered above the primary group.
   *
   * ### Hook Events
   * - {@link hookEvents.drawEffectsCanvasGroup}
   * - {@link hookEvents.createEffectsCanvasGroup}
   * - {@link hookEvents.lightingRefresh}
   *
   * @category - Canvas
   */
  class EffectsCanvasGroup extends PIXI.Container {
    constructor();

    /** The current global light source */
    globalLightSource: GlobalLightSource;

    /** Whether to currently animate light sources. */
    animateLightSources: boolean;

    /** Whether to currently animate vision sources. */
    animateVisionSources: boolean;

    /** A mapping of light sources which are active within the rendered Scene. */
    lightSources: Collection<LightSource<AmbientLight | Token>>;

    /** A Collection of vision sources which are currently active within the rendered Scene. */
    visionSources: Collection<VisionSource<Token>>;

    /** A set of vision mask filters used in visual effects group */
    visualEffectsMaskingFilters: Set<PIXI.Filter>;

    /** A layer of background alteration effects which change the appearance of the primary group render texture. */
    background: CanvasLayer;

    /** A layer which adds illumination-based effects to the scene. */
    illumination: CanvasLayer;

    /** A layer which adds color-based effects to the scene. */
    coloration: CanvasLayer;

    /** A layer which controls the current visibility of the scene. */
    visibility: CanvasVisibility;

    /** Clear all effects containers and animated sources. */
    clearEffects(): void;

    /** Draw the component layers of the canvas group. */
    draw(): Promise<void>;

    /** Initialize LightSource objects for all AmbientLightDocument instances that exist within the active Scene. */
    initializeLightSources(): void;

    /** Update the global light source which provide global illumination to the Scene. */
    protected _updateGlobalLightSource(): LightSource<null>;

    /** Refresh the state and uniforms of all LightSource objects. */
    refreshLightSources(): void;

    /** Refresh the state and uniforms of all LightSource objects. */
    refreshVisionSources(): void;

    /** Refresh the active display of lighting. */
    refreshLighting(): void;

    /** Perform a deconstruction workflow for this canvas group when the canvas is retired. */
    tearDown(): Promise<void>;

    /**
     * Activate vision masking for visual effects
     * @param [enabled=true]    Whether to enable or disable vision masking
     */
    toggleMaskingFilters(enabled?: boolean): void;

    /**
     * Activate post-processing effects for a certain effects channel.
     * @param filterMode               The filter mode to target.
     * @param [postProcessingModes=[]] The post-processing modes to apply to this filter.
     * @param [uniforms={}]            The uniforms to update.
     */
    activatePostProcessingFilters(filterMode: string, postProcessingModes?: string[], uniforms?: object): void;

    /** Reset post-processing modes on all Visual Effects masking filters. */
    resetPostProcessingFilters(): void;

    /* -------------------------------------------- */
    /*  Animation Management                        */
    /* -------------------------------------------- */

    /** Activate light source animation for AmbientLight objects within this layer */
    activateAnimation(): void;

    /** Deactivate light source animation for AmbientLight objects within this layer */
    deactivateAnimation(): void;

    /**
     * Animate a smooth transition of the darkness overlay to a target value.
     * Only begin animating if another animation is not already in progress.
     * @param target   The target darkness level between 0 and 1
     * @param duration The desired animation time in milliseconds. Default is 10 seconds
     * @returns A Promise which resolves once the animation is complete
     */
    animateDarkness(target?: number, { duration }?: { duration?: number }): Promise<void>;
  }
}

declare global {
  /** A container group which displays interface elements rendered above other canvas groups. */
  class InterfaceCanvasGroup extends PIXI.Container {
    /**
     * Display scrolling status text originating from this ObjectHUD container.
     * @param origin                  An origin point where the text should first emerge
     * @param content                 The text content to display
     * @param [options]               Options which customize the text animation
     * @param [options.duration=2000] The duration of the scrolling effect in milliseconds
     * @param [options.distance]      The distance in pixels that the scrolling text should travel
     * @param [options.anchor]        The original anchor point where the text first appears
     * @param [options.direction]     The direction in which the text scrolls
     * @param [options.jitter=0]      An amount of randomization between [0, 1] applied to the initial position
     * @param [options.textStyle={}]  Additional parameters of PIXI.TextStyle which are applied to the text
     */
    createScrollingText(origin: Point, content: string, options: CreateScrollingTextOptions): Promise<void | null>;
  }
}

interface CreateScrollingTextOptions extends Partial<PIXI.TextStyle> {
  duration?: number;
  distance?: number;
  jitter?: number;
  anchor: number;
  direction?: number;
}

declare global {
  /**
   * A subclass of Canvas Layer which is specifically designed to contain multiple PlaceableObject instances,
   * each corresponding to an embedded Document.
   * @category - Canvas
   */
  abstract class PlaceablesLayer<TObject extends PlaceableObject = PlaceableObject> extends InteractionLayer {
    constructor();

    objects: PIXI.Container | null;

    /** Preview Object Placement */
    preview: PIXI.Container;

    /** Keep track of history so that CTRL+Z can undo changes */
    history: CanvasHistory<TObject>[];

    /** Keep track of an object copied with CTRL+C which can be pasted later */
    protected _copy: TObject[];

    quadtree: CanvasQuadtree<TObject> | null;

    /* -------------------------------------------- */
    /*  Attributes                                  */
    /* -------------------------------------------- */

    /** Customize behaviors of this PlaceablesLayer by modifying some behaviors at a class level */
    static override get layerOptions(): PlaceablesLayerOptions;

    /** A reference to the named Document type which is contained within this Canvas Layer. */
    static documentName: string;

    /** Creation states affected to placeables during their construction. */
    static CREATION_STATES: {
      NONE: 0;
      POTENTIAL: 1;
      CONFIRMED: 2;
      COMPLETED: 3;
    };

    /** Obtain a reference to the Collection of embedded Document instances within the currently viewed Scene */
    get documentCollection(): Collection<TObject['document']> | null;

    /** Obtain a reference to the PlaceableObject class definition which represents the Document type in this layer. */
    static get placeableClass(): ConstructorOf<PlaceableObject>;

    /** Return the precision relative to the Scene grid with which Placeable objects should be snapped */
    get gridPrecision(): number;

    /** If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance */
    get hud(): BasePlaceableHUD<TObject> | null;

    /** A convenience method for accessing the placeable object instances contained in this layer */
    get placeables(): TObject[];

    /** An Array of placeable objects in this layer which have the _controlled attribute */
    get controlled(): TObject[];

    /**
     * Iterates over placeable objects that are eligible for control/select.
     * @yields A placeable object
     */
    controllableObjects(): Generator<TObject>;

    /** Track the set of PlaceableObjects on this layer which are currently controlled. */
    get controlledObjects(): Map<string, PlaceableObject>;

    /** Track the PlaceableObject on this layer which is currently hovered upon. */
    get hover(): TObject | null;

    set hover(object: TObject | null);

    /** Track whether "highlight all objects" is currently active */
    highlightObjects: boolean;

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /** Obtain an iterable of objects which should be added to this PlaceableLayer */
    getDocuments(): TObject['document'][];

    /** PlaceableObject layer options */
    options: PlaceablesLayerOptions;

    /** Return a reference to the active instance of this canvas layer */
    static override get instance(): PlaceablesLayer;

    /**  Define the named Array within Scene.data containing the placeable objects displayed in this layer */
    static get dataArray(): string;

    /**
     * Draw the PlaceablesLayer.
     * Draw each Sound within the scene as a child of the sounds container.
     */
    protected override _draw(options?: object): Promise<void>;

    /** Draw a single placeable object */
    createObject(data: PreCreate<TObject['document']['_source']>): TObject;

    protected override _tearDown(options?: object): Promise<void>;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override activate(): this;

    override deactivate(): this;

    /**
     * Get a PlaceableObject contained in this layer by it's ID
     * @param objectId  The ID of the contained object to retrieve
     * @return          The object instance, or undefined
     */
    get(objectId: number | string): TObject | undefined;

    /**
     * Acquire control over all PlaceableObject instances which are visible and controllable within the layer.
     * @param options Options passed to the control method of each object
     * @return An array of objects that were controlled
     */
    controlAll(options?: Record<string, unknown>): TObject[];

    /**
     * Release all controlled PlaceableObject instance from this layer.
     * @param options   Additional options which customize the Object releasing behavior
     * @return          The number of PlaceableObject instances which were released
     */
    releaseAll(options?: Record<string, unknown>): number;

    /**
     * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
     * This executes a single database operation using Scene.update.
     * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.
     *
     * @param  options Options which configure how multiple objects are rotated
     * @param [options.angle] A target angle of rotation (in degrees) where zero faces "south"
     * @param [options.delta] An incremental angle of rotation (in degrees)
     * @param [options.snap]  Snap the resulting angle to a multiple of some increment (in degrees)
     * @param [options.ids]   An Array of object IDs to target for rotation
     *
     * @return An array of objects which were rotated
     */
    rotateMany({
      angle,
      delta,
      snap,
      ids,
    }?: {
      angle?: number;
      delta?: number;
      snap?: number;
      ids?: string[];
    }): Promise<TObject[]>;

    /**
     * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
     * This executes a single database operation using Scene.update.
     * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
     *
     * @param options Options which configure how multiple objects are moved
     * @param [options.dx=0]         The number of incremental grid units in the horizontal direction
     * @param [options.dy=0]         The number of incremental grid units in the vertical direction
     * @param [options.rotate=false] Rotate the token to the keyboard direction instead of moving
     * @param [options.ids]          An Array of object IDs to target for movement
     *
     * @returns An array of objects which were moved during the operation
     */
    moveMany({
      dx,
      dy,
      rotate,
      ids,
    }?: {
      dx?: number;
      dy?: number;
      rotate?: boolean;
      ids?: string[];
    }): Promise<TObject[]>;

    /**
     * Undo a change to the objects in this layer
     * This method is typically activated using CTRL+Z while the layer is active
     * @returns An array of documents which were modified by the undo operation
     */
    undoHistory(): Promise<TObject['document'][]>;

    /**
     * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
     * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
     * @returns An array of Document objects which were deleted by the operation
     */
    deleteAll(): Promise<TObject['document'][] | void>;

    /**
     * Record a new CRUD event in the history log so that it can be undone later
     * @param type  The event type (create, update, delete)
     * @param data  The object data
     */
    storeHistory(type: string, data: Record<string, unknown>): void;

    /**
     * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
     * @returns The Array of copied Objects
     */
    copyObjects(): TObject[];

    /**
     * Paste currently copied PlaceableObjects back to the layer by creating new copies
     * @return  An Array of created Objects
     */
    pasteObjects(position: { x: number; y: number }, { hidden }?: { hidden?: boolean }): Promise<TObject['document'][]>;

    /**
     * Select all PlaceableObject instances which fall within a coordinate rectangle.
     *
     * @param x              The top-left x-coordinate of the selection rectangle
     * @param y              The top-left y-coordinate of the selection rectangle
     * @param width          The width of the selection rectangle
     * @param height         The height of the selection rectangle
     * @param releaseOptions Optional arguments provided to any called release() method
     * @param controlOptions Optional arguments provided to any called control() method
     * @return The number of PlaceableObject instances which were controlled.
     */
    selectObjects({
      x,
      y,
      width,
      height,
      releaseOptions,
      controlOptions,
    }: {
      x: number;
      y: number;
      width: number;
      height: number;
      releaseOptions?: object;
      controlOptions?: object;
    }): number;

    /**
     * Update all objects in this layer with a provided transformation.
     * Conditionally filter to only apply to objects which match a certain condition.
     * @param transformation An object of data or function to apply to all matched objects
     * @param condition      A function which tests whether to target each object
     * @param [options]      Additional options passed to Entity.update
     * @return An array of updated data once the operation is complete
     */
    updateAll(
      transformation: (document: TObject) => Record<string, unknown>,
      condition?: Function | null,
      options?: DocumentModificationContext<TObject['document']['parent']>,
    ): Promise<TObject['document'][]>;

    /**
     * Create a preview of this layer's object type from a world document and show its sheet to be finalized.
     * @param createData The data to create the object with.
     * @param [options] Options which configure preview creation
     * @param [options.renderSheet] Render the preview object config sheet?
     * @param [options.top] The offset-top position where the sheet should be rendered
     * @param [options.left] The offset-left position where the sheet should be rendered
     * @returns The created preview object
     */
    protected _createPreview(
      createData: Record<string, unknown>,
      options?: { renderSheet?: boolean; top?: number; left?: number },
    ): Promise<TObject>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /**
     * Handle left mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
     * @see {Canvas#_onClickLeft}
     */
    protected override _onClickLeft(event: PlaceablesLayerPointerEvent<TObject>): void;

    /**
     * Handle double left-click events which originate from the Canvas stage and are dispatched to this Layer.
     * @see {Canvas#_onClickLeft2}
     */
    protected _onClickLeft2(event: PlaceablesLayerPointerEvent<TObject>): void;

    /**
     * Start a left-click drag workflow originating from the Canvas stage.
     * @see {Canvas#_onDragLeftStart}
     */
    protected override _onDragLeftStart(event: PlaceablesLayerPointerEvent<TObject>): Promise<TObject | void>;

    /**
     * Continue a left-click drag workflow originating from the Canvas stage.
     * @see {Canvas#_onDragLeftMove}
     */
    protected override _onDragLeftMove(event: PlaceablesLayerPointerEvent<TObject>): void;

    /**
     * Conclude a left-click drag workflow originating from the Canvas stage.
     * @see {Canvas#_onDragLeftDrop}
     */
    protected override _onDragLeftDrop(event: PlaceablesLayerPointerEvent<TObject>): Promise<void>;

    /**
     * Cancel a left-click drag workflow originating from the Canvas stage.
     * @see {Canvas#_onDragLeftDrop}
     */
    protected override _onDragLeftCancel(
      event: PIXI.FederatedPointerEvent | PlaceablesLayerPointerEvent<TObject>,
    ): void;

    /**
     * Handle right mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
     * @see {Canvas#_onClickRight}
     */
    protected override _onClickRight(event: PlaceablesLayerPointerEvent<TObject>): void;

    /**
     * Handle mouse-wheel events at the PlaceableObjects layer level to rotate multiple objects at once.
     * This handler will rotate all controlled objects by some incremental angle.
     * @param event The mousewheel event which originated the request
     */
    protected override _onMouseWheel(event: WheelEvent): unknown;

    /**
     * Handle a DELETE keypress while a placeable object is hovered
     * @param event The delete key press event which triggered the request
     */
    protected override _onDeleteKey(event: KeyboardEvent): Promise<void>;
  }

  interface PlaceablesLayerOptions extends InteractionLayerOptions {
    /** Does this layer support a mouse-drag workflow to create new objects? */
    canDragCreate: boolean;
    /** Can objects be deleted from this layer? */
    canDelete: boolean;
    /** Can placeable objects in this layer be controlled? */
    controllableObjects: boolean;
    /** Can placeable objects in this layer be rotated? */
    rotatableObjects: boolean;
    /** Do objects in this layer snap to the grid */
    snapToGrid: boolean;
    /** The class used to represent an object on this layer. */
    objectClass: ConstructorOf<PlaceableObject>;
    /** Does this layer use a quadtree to track object positions? */
    quadtree: boolean;
    /** Are contained objects sorted based on elevation instead of zIndex */
    elevationSorting: boolean;
  }

  interface PlaceablesLayerEvent<TObject extends PlaceableObject> extends PIXI.FederatedEvent {
    interactionData: PlaceableInteractionData<TObject>;
  }

  interface PlaceablesLayerPointerEvent<TObject extends PlaceableObject> extends PIXI.FederatedPointerEvent {
    interactionData: PlaceableInteractionData<TObject>;
  }

  interface CanvasHistory<TObject extends PlaceableObject> {
    /** The type of operation stored as history */
    type: 'create' | 'update' | 'delete';
    /** The data corresponding to the action which may later be un-done */
    data: TObject['document']['_source'][];
  }
}

interface PlaceableInteractionData<TObject extends PlaceableObject> {
  clearPreviewContainer: boolean;
  preview?: TObject | null;
  layerDragState?: number;
  clones?: TObject[];
  object: PIXI.Container | PIXI.Mesh;
  origin: Point;
  destination: Point;
}

declare global {
  /** The Ruler - used to measure distances and trigger movements */
  class Ruler extends PIXI.Container {
    /** Record the User which this Ruler references */
    user: User;

    /** The ruler name - used to differentiate between players */
    name: string;

    /** The ruler color - by default the color of the active user */
    color: foundry.utils.Color;

    /**
     * This Array tracks individual waypoints along the ruler's measured path.
     * The first waypoint is always the origin of the route.
     */
    waypoints: PIXI.Point[];

    /** The Ruler element is a Graphics instance which draws the line and points of the measured path */
    ruler: PIXI.Graphics;

    /** The Labels element is a Container of Text elements which label the measured path */
    labels: PIXI.Container;

    /** Track the current measurement state */
    protected _state: RulerState;

    /** The current destination point at the end of the measurement */
    destination: Point;

    /** The array of most recently computed ruler measurement segments */
    segments: RulerMeasurementSegment[];

    /** An enumeration of the possible Ruler measurement states. */
    static STATES: {
      INACTIVE: 0;
      STARTING: 1;
      MEASURING: 2;
      MOVING: 3;
    };

    /**
     * @param user The User for whom to construct the Ruler instance
     */
    constructor(user: User | undefined | null, { color }?: { color?: HexColorString | null });

    /** Is the Ruler being actively used to measure distance? */
    get active(): boolean;

    /** Get a GridHighlight layer for this Ruler */
    get highlightLayer(): GridHighlight;

    /* -------------------------------------------- */
    /*  Ruler Methods                               */
    /* -------------------------------------------- */

    /** Clear display of the current Ruler */
    clear(): void;

    /**
     * Measure the distance between two points and render the ruler UI to illustrate it
     * @param destination  The destination point to which to measure
     * @param [gridSpaces] Restrict measurement only to grid spaces
     * @returns The array of measured segments
     */
    measure(destination: PIXI.Point, { gridSpaces }?: { gridSpaces?: boolean }): RulerMeasurementSegment[] | void;

    /**
     * While measurement is in progress, update the destination to be the central point of the target grid space.
     * @param destination The current pixel coordinates of the mouse movement
     * @returns The destination point, a center of a grid space
     */
    protected _getMeasurementDestination(destination: Point): PIXI.Point;

    /**
     * Translate the waypoints and destination point of the Ruler into an array of Ray segments.
     * @returns The segments of the measured path
     */
    protected _getMeasurementSegments(): RulerMeasurementSegment[];

    /**
     * Compute the distance of each segment and the total distance of the measured path.
     * @param gridSpaces Base distance on the number of grid spaces moved?
     */
    protected _computeDistance(gridSpaces: boolean): void;

    /** Get the text label for a segment of the measured path */
    protected _getSegmentLabel(segment: RulerMeasurementSegment, totalDistance: number): string;

    /** Draw each segment of the measured path. */
    protected _drawMeasuredPath(): void;

    /** Highlight the measurement required to complete the move in the minimum number of discrete spaces */
    protected _highlightMeasurementSegment(segment: RulerMeasurementSegment): void;

    /* -------------------------------------------- */
    /*  Token Movement Execution                    */
    /* -------------------------------------------- */

    /**
     * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
     * @returns An indicator for whether a token was successfully moved or not. If True the
     *          event should be prevented from propagating further, if False it should move on
     *          to other handlers.
     */
    moveToken(): Promise<boolean>;

    /** Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler */
    protected _getMovementToken(): Token | undefined;

    /**
     * Animate piecewise Token movement along the measured segment path.
     * @param token The Token being animated
     * @returns A Promise which resolves once all animation is completed
     */
    protected _animateMovement(token: Token): Promise<void>;

    /**
     * Update Token position and configure its animation properties for the next leg of its animation.
     * @param token       The Token being updated
     * @param segment     The measured segment being moved
     * @param destination The adjusted destination coordinate
     * @returns A Promise which resolves once the animation for this segment is done
     */
    protected _animateSegment(token: Token, segment: RulerMeasurementSegment, destination: Point): Promise<unknown>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /**
     * Handle the beginning of a new Ruler measurement workflow
     * @param event The drag start event
     * @see {Canvas._onDragLeftStart}
     */
    _onDragStart(event: PIXI.FederatedEvent): void;

    /**
     * Handle left-click events on the Canvas during Ruler measurement.
     * @param event The pointer-down event
     * @see {Canvas._onClickLeft}
     */
    protected _onClickLeft(event: PIXI.FederatedEvent): void;

    /**
     * Handle right-click events on the Canvas during Ruler measurement.
     * @param event The pointer-down event
     * @see {Canvas._onClickRight}
     */
    protected _onClickRight(event: PIXI.FederatedEvent): void;

    /**
     * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.
     * @param event The mouse move event
     * @see {Canvas._onDragLeftMove}
     */
    protected _onMouseMove(event: PIXI.FederatedEvent): void;

    /**
     * Conclude a Ruler measurement workflow by releasing the left-mouse button.
     * @param event The pointer-up event
     * @see {Canvas._onDragLeftDrop}
     */
    protected _onMouseUp(event: PIXI.FederatedEvent): void;

    /** Handle the addition of a new waypoint in the Ruler measurement path */
    protected _addWaypoint(point: PIXI.Point): void;

    /**
     * Handle the removal of a waypoint in the Ruler measurement path
     * @param point  The current cursor position to snap to
     * @param [snap] Snap exactly to grid spaces?
     */
    protected _removeWaypoint(point: PIXI.Point, { snap }?: { snap?: boolean }): void;

    /** Handle the conclusion of a Ruler measurement workflow */
    protected _endMeasurement(): void;

    /* -------------------------------------------- */
    /*  Saving and Loading                          */
    /* -------------------------------------------- */

    /** Package Ruler data to an object which can be serialized to a string. */
    toJSON(): RulerData;

    /**
     * Update a Ruler instance using data provided through the cursor activity socket
     * @param data Ruler data with which to update the display
     */
    update(data: RulerData): void;
  }

  interface RulerMeasurementSegment {
    /** The Ray which represents the point-to-point line segment */
    ray: Ray;
    /** The text object used to display a label for this segment */
    label: PreciseText;
    /** The measured distance of the segment */
    distance: number;
    /** The string text displayed in the label */
    text: string;
    /** Is this segment the last one? */
    last: boolean;
  }

  interface RulerData {
    /** The ruler measurement state. */
    _state: RulerState;
    /** A unique name for the ruler containing the owning user's ID. */
    name: string;
    /** The current point the ruler has been extended to. */
    destination: PIXI.Point;
    /** The class name of this ruler instance. */
    class: string;
    /** Additional waypoints along the ruler's length, including the starting point. */
    waypoints: PIXI.Point[];
  }

  type RulerState = (typeof Ruler.STATES)[keyof typeof Ruler.STATES];
}

declare global {
  /**
   * The visibility Layer which implements dynamic vision, lighting, and fog of war
   * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.
   * @see {@link PointSource}
   * @category - Canvas
   *
   * @property explored The exploration container which tracks exploration progress
   * @property vision   The container of current vision exploration
   */
  class CanvasVisibility extends CanvasLayer {
    /** The current vision container which provides line-of-sight for vision sources and field-of-view of light sources. */
    vision: PIXI.Container;

    /** The canonical line-of-sight polygon which defines current Token visibility. */
    los: PIXI.Graphics;

    /** The optional visibility overlay sprite that should be drawn instead of the unexplored color in the fog of war. */
    visibilityOverlay: PIXI.Sprite;

    /** The active vision source data object */
    visionModeData: {
      source: VisionSource | null;
      activeLightingOptions: object;
    };

    /**
     * Define whether each lighting layer is enabled, required, or disabled by this vision mode.
     * The value for each lighting channel is a number in LIGHTING_VISIBILITY
     */
    lightingVisibility: {
      background: LightingVisibility;
      illumination: LightingVisibility;
      coloration: LightingVisibility;
      any: boolean;
    };

    /* -------------------------------------------- */
    /*  Canvas Visibility Properties                */
    /* -------------------------------------------- */

    /** A status flag for whether the layer initialization workflow has succeeded. */
    get initialized(): boolean;

    /** Does the currently viewed Scene support Token field of vision? */
    get tokenVision(): boolean;

    /** The configured options used for the saved fog-of-war texture. */
    get textureConfiguration(): FogTextureConfiguration;

    /* -------------------------------------------- */
    /*  Layer Initialization                        */
    /* -------------------------------------------- */

    /**
     * Initialize all Token vision sources which are present on this layer
     */
    initializeSources(): void;

    /* -------------------------------------------- */
    /*  Layer Rendering                             */
    /* -------------------------------------------- */

    protected _draw(options: object): Promise<void>;

    protected override _tearDown(options: object): Promise<void>;

    /**
     * Update the display of the sight layer.
     * Organize sources into rendering queues and draw lighting containers for each source
     */
    refresh(): void;

    /** Update vision (and fog if necessary) */
    refreshVisibility(): void;

    /** Reset the exploration container with the fog sprite */
    resetExploration(): void;

    /* -------------------------------------------- */
    /*  Visibility Testing                          */
    /* -------------------------------------------- */

    /**
     * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
     * These assets should only be displayed if they are visible given the current player's field of view
     */
    restrictVisibility(): void;

    /**
     * Test whether a target point on the Canvas is visible based on the current vision and LOS polygons.
     * @param point     The point in space to test, an object with coordinates x and y.
     * @param [options] Additional options which modify visibility testing.
     * @param [options.tolerance=2] A numeric radial offset which allows for a non-exact match.
     *                              For example, if tolerance is 2 then the test will pass if the point
     *                              is within 2px of a vision polygon.
     * @param [options.object]      An optional reference to the object whose visibility is being tested
     * @returns Whether the point is currently visible.
     */
    testVisibility(point: Point, options?: { tolerance?: number; object?: object | null }): boolean;
  }

  interface VisibilityTextureConfiguration {
    resolution: number;
    width: number;
    height: number;
    mipmap: PIXI.MIPMAP_MODES;
    scaleMode: PIXI.SCALE_MODES;
    multisample: PIXI.MSAA_QUALITY;
  }

  interface FogTextureConfiguration extends VisibilityTextureConfiguration {
    alphaMode: PIXI.ALPHA_MODES;
    format: PIXI.FORMATS;
  }

  interface CanvasVisibilityTestConfig {
    /** The target object */
    object: PlaceableObject | DoorControl;
    /** An array of visibility tests */
    tests: CanvasVisibilityTest[];
  }

  interface CanvasVisibilityTest {
    point: Point;
    los: Map<VisionSource<Token>, boolean>;
  }
}

declare global {
  /**
   * The Lighting Layer which displays darkness and light within the rendered Scene.
   * Lighting Layer (Container)
   *   Illumination Container [MULTIPLY]
   *     Background (Graphics)
   *     Light (Container) [LOS Mask]
   *       Source 1, ..., Source N (Container)
   *     Darkness (Container)
   *       Source 1, ..., Source N (Container)
   *   Coloration Container [ADD_NPM]
   *
   * @example <caption>The lightingRefresh hook</caption>
   * Hooks.on("lightingRefresh", layer => {});
   */
  class LightingLayer<TObject extends AmbientLight = AmbientLight> extends PlaceablesLayer<TObject> {
    static override documentName: 'AmbientLight';

    static override get layerOptions(): PlaceablesLayerOptions;

    override get hookName(): 'LightingLayer';

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    protected override _activate(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /**
     * Actions to take when the darkness level of the Scene is changed
     * @param darkness The new darkness level
     * @param prior    The prior darkness level
     */
    protected _onDarknessChange(darkness: number, prior: number): void;

    protected override _onDragLeftStart(event: PlaceablesLayerPointerEvent<TObject>): Promise<void>;

    protected override _onDragLeftMove(event: PlaceablesLayerPointerEvent<TObject>): Promise<void>;

    protected override _onDragLeftCancel(event: PIXI.FederatedEvent): void;

    protected override _onMouseWheel(event: WheelEvent): void;
  }

  interface IlluminationContainer extends PIXI.Container {
    primary: PIXI.Container;
    background: PIXI.Graphics;
    filter: InstanceType<typeof PIXI.AlphaFilter> | InstanceType<typeof PIXI.BlurFilter>;
    lights: PIXI.Container;
  }

  interface LightChannel {
    hex: number;
    rgb: number[];
  }

  interface LightChannels {
    background: LightChannel;
    black: LightChannel;
    bright: LightChannel;
    canvas: LightChannel;
    dark: LightChannel;
    darkness: {
      level: number;
      rgb: [number, number, number];
    };
    dim: LightChannel;
  }
}

declare global {
  class TemplateLayer<TObject extends MeasuredTemplate = MeasuredTemplate> extends PlaceablesLayer<TObject> {
    static override get layerOptions(): TemplateLayerOptions;

    static documentName: 'MeasuredTemplate';

    override quadtree: CanvasQuadtree<TObject>;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override activate(): this;

    override deactivate(): this;

    /** Register game settings used by the TemplatesLayer */
    static registerSettings(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    protected override _onDragLeftStart(event: PlaceablesLayerPointerEvent<TObject>): Promise<TObject | void>;

    protected override _onDragLeftMove(event: PlaceablesLayerPointerEvent<TObject>): void;

    protected override _onMouseWheel(event: WheelEvent): Promise<TObject['document'] | undefined> | void;
  }

  /**
   * This Canvas Layer provides a container for MeasuredTemplate objects.
   * @todo: fill this in
   */
  interface TemplateLayerOptions extends PlaceablesLayerOptions {
    name: 'templates';
    sortActiveTop: boolean;
    zIndex: number;
  }
}

declare global {
  /** The Tokens Container */
  class TokenLayer<TToken extends Token = Token> extends PlaceablesLayer<TToken> {
    constructor();

    override quadtree: CanvasQuadtree<TToken>;

    /** The current index position in the tab cycle */
    protected _tabIndex: number | null;

    /** Remember the last drawn wildcard token image to avoid repetitions */
    protected _lastWildcard: string | null;

    static override get layerOptions(): PlaceablesLayerOptions;

    static override documentName: 'Token';

    override get gridPrecision(): 1;

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    /** Token objects on this layer utilize the TokenHUD */
    override get hud(): TokenHUD<TToken>;

    /** An Array of tokens which belong to actors which are owned */
    get ownedTokens(): TToken[];

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    protected override _tearDown(): Promise<void>;

    override activate(): this;

    override deactivate(): this;

    override selectObjects({
      x,
      y,
      width,
      height,
      releaseOptions,
      controlOptions,
    }: {
      x: number;
      y: number;
      width: number;
      height: number;
      releaseOptions?: object;
      controlOptions?: object;
    }): number;
    /**
     * Target all Token instances which fall within a coordinate rectangle.
     * @param x             The top-left x-coordinate of the selection rectangle
     * @param y             The top-left y-coordinate of the selection rectangle
     * @param width         The width of the selection rectangle
     * @param height        The height of the selection rectangle
     * @param releaseOthers Whether or not to release other targeted tokens
     * @return The number of Token instances which were targeted.
     */
    targetObjects(
      { x, y, width, height }: { x: number; y: number; width: number; height: number },
      { releaseOthers }?: { releaseOthers?: boolean },
    ): number;

    /**
     * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
     * Tokens are currently sorted in order of their TokenID
     *
     * @param forwards Which direction to cycle. A truthy value cycles forward, while a false value cycles backwards.
     * @param reset    Restart the cycle order back at the beginning?
     * @return The Token object which was cycled to, or null
     */
    cycleTokens(forwards: boolean, reset: boolean): TToken | null;

    /**
     * Add or remove the set of currently controlled Tokens from the active combat encounter
     * @param state   The desired combat state which determines if each Token is added (true) or removed (false)
     * @param combat  A Combat encounter from which to add or remove the Token
     * @param [token] A specific Token which is the origin of the group toggle request
     * @return The Combatants added or removed
     */
    toggleCombat(
      state: boolean | undefined,
      combat: Combat,
      { token }?: { token?: TToken | null },
    ): Promise<NonNullable<TToken['combatant']>>[];

    /** Get the tab cycle order for tokens by sorting observable tokens based on their distance from top-left. */
    protected _getCycleOrder(): TToken[];

    /** Immediately conclude the animation of any/all tokens */
    concludeAnimation(): void;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    /** Handle dropping of Actor data onto the Scene canvas */
    protected _onDropActorData(
      event: DragEvent,
      data: DropCanvasData<'Actor', NonNullable<TToken['actor']>['_source']>,
    ): Promise<TToken['actor']>;

    protected override _onClickLeft(event: PIXI.FederatedEvent): void;
  }

  interface TokenLayer<TToken extends Token = Token> extends PlaceablesLayer<TToken> {
    children: [CanvasStage<TToken>, PIXI.Container];
  }
}

interface CanvasStage<TToken extends Token> extends PIXI.Container {
  children: TToken[];
}

declare global {
  /** The Walls canvas layer which provides a container for Wall objects within the rendered Scen */
  class WallsLayer<
    TObject extends Wall<WallDocument<Scene | null>> = Wall<WallDocument<Scene | null>>,
  > extends PlaceablesLayer<TObject> {
    constructor();

    override quadtree: CanvasQuadtree<TObject>;

    /** A graphics layer used to display chained Wall selection */
    chain: PIXI.Graphics;

    /**
     * An array of all the unique perception-blocking endpoints which are present in the layer
     * We keep this array cached for faster sight polygon computations
     */
    endpoints: PointArray[];

    /** Track whether we are currently within a chained placement workflow */
    protected _chain: boolean;

    /**
     * Track whether the layer is currently toggled to snap at exact grid precision
     */
    protected _forceSnap: boolean;

    /** Track the most recently created or updated wall data for use with the clone tool */
    protected _cloneType: foundry.documents.WallSource;

    /** Reference the last interacted wall endpoint for the purposes of chaining */
    last: { id: string | null; point: PointArray };

    /* -------------------------------------------- */
    /*  Properties                                  */
    /* -------------------------------------------- */

    static override get layerOptions(): WallsLayerOptions;

    static documentName: 'Wall';

    /** An Array of Wall instances in the current Scene which act as Doors. */
    get doors(): TObject[];

    /** Gate the precision of wall snapping to become less precise for small scale maps. */
    get gridPrecision(): number;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    override draw(): Promise<this>;

    override deactivate(): this;

    /**
     * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.
     * Cache unique wall endpoints and identify interior walls using overhead roof tiles.
     */
    initialize(): void;

    /** Identify walls which are treated as "interior" because they are contained fully within a roof tile. */
    identifyInteriorWalls(): void;

    /**
     * Given a point and the coordinates of a wall, determine which endpoint is closer to the point
     * @param point The origin point of the new Wall placement
     * @param wall  The existing Wall object being chained to
     * @return The [x,y] coordinates of the starting endpoint
     */
    static getClosestEndpoint(point: Point, wall: Wall<WallDocument<Scene>>): PointArray;

    /**
     * Given an array of Wall instances, identify the unique endpoints across all walls.
     * @param walls  An collection of Wall objects
     * @param [options={}] Additional options which modify the set of endpoints identified
     * @param [options.bounds]        An optional bounding rectangle within which the endpoint must lie.
     * @param [options.type=movement] The type of polygon being computed: "movement", "sight", or "sound"
     * @return An array of endpoints
     */
    static getUniqueEndpoints(
      walls: Iterable<Wall<WallDocument<Scene>>>,
      { bounds, type }?: { bounds?: PIXI.Rectangle; type?: WallType },
    ): PointArray[];

    /**
     * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer
     */
    highlightControlledSegments(): void;

    override releaseAll(options: Record<string, unknown>): number;

    pasteObjects(position: { x: number; y: number }, { hidden }?: { hidden?: boolean }): Promise<TObject['document'][]>;

    /**
     * Pan the canvas view when the cursor position gets close to the edge of the frame
     * @param event The originating mouse movement event
     * @param x     The x-coordinate
     * @param y     The y-coordinate
     */
    protected _panCanvasEdge(event: MouseEvent, x: number, y: number): void;

    /**
     * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
     * Require snap-to-grid until a redesign of the wall chaining system can occur.
     * @param point The initial candidate point
     * @param [snap=true] Whether to snap to grid
     * @return The endpoint coordinates [x,y]
     */
    protected _getWallEndpointCoordinates(point: [number, number], { snap }?: { snap?: boolean }): [number, number];

    /**
     * The Scene Controls tools provide several different types of prototypical Walls to choose from
     * This method helps to translate each tool into a default wall data configuration for that type
     * @param tool The active canvas tool
     */
    protected _getWallDataFromActiveTool(tool: string): Partial<foundry.documents.WallSource>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    protected override _onClickLeft(event: PlaceablesLayerPointerEvent<TObject>): void;

    protected override _onDragLeftStart(event: PlaceablesLayerPointerEvent<TObject>): Promise<void>;

    protected override _onDragLeftMove(event: PlaceablesLayerPointerEvent<TObject>): Promise<void>;

    protected override _onDragLeftCancel(event: PIXI.FederatedEvent): void;

    protected override _onClickRight(event: PIXI.FederatedEvent): void;

    /* -------------------------------------------- */
    /*  Source Polygon Computation                  */
    /* -------------------------------------------- */

    /**
     * Compute source polygons of a requested type for a given origin position and maximum radius.
     * This method returns two polygons, one which is unrestricted by the provided radius, and one that is constrained
     * by the maximum radius.
     *
     * @param origin An point with coordinates x and y representing the origin of the test
     * @param radius A distance in canvas pixels which reflects the visible range
     * @param [options={}] Additional options which modify the sight computation
     * @param [options.type=sight] The type of polygon being computed: "movement", "sight", or "sound"
     * @param [options.angle=360]  An optional limited angle of emission with which to restrict polygons
     * @param [options.density=6]  The desired radial density of emission for rays, in degrees
     * @param [options.rotation=0] The current angle of rotation, used when the angle is limited
     * @param [options.unrestricted=false]  Compute sight that is fully unrestricted by walls
     *
     * @returns The computed rays and polygons
     */
    computePolygon(
      origin: Point,
      radius: number,
      {
        type,
        angle,
        density,
        rotation,
        unrestricted,
      }: {
        type?: WallType;
        angle?: number;
        density?: number;
        rotation?: number;
        unrestricted?: boolean;
      },
    ): { rays: Ray; los: PIXI.Polygon; fov: PIXI.Polygon };

    /**
     * Get the set of wall collisions for a given Ray
     * @param ray The Ray being tested
     * @param [options={}] Options which customize how collision is tested
     * @param [options.type=movement] Which collision type to check: movement, sight, sound
     * @param [options.mode=any]      Which type of collisions are returned: any, closest, all
     * @param [options._performance]  Internal performance tracking
     *
     * @return An array of collisions, if mode is "all"
     *         The closest collision, if mode is "closest"
     *         Whether any collision occurred if mode is "any"
     */
    getRayCollisions(
      ray: Ray,
      { type, mode, _performance }?: { type?: WallType; mode?: WallMode; _performance?: unknown },
    ): Record<string, unknown> | Record<string, unknown> | boolean;

    /* -------------------------------------------- */
    /*  Helper Methods                              */
    /* -------------------------------------------- */

    /**
     * A helper method responsible for casting rays at wall endpoints.
     * Rays are restricted by limiting angles.
     *
     * @param x          The origin x-coordinate
     * @param y          The origin y-coordinate
     * @param distance   The ray distance
     * @param density    The desired radial density
     * @param endpoints  An array of endpoints to target
     * @param limitAngle Whether the rays should be cast subject to a limited angle of emission
     * @param aMin               The minimum bounding angle
     * @param aMax               The maximum bounding angle
     *
     * @returns An array of Ray objects
     */
    static castRays(
      x: number,
      y: number,
      distance: number,
      {
        density,
        endpoints,
        limitAngle,
        aMin,
        aMax,
      }?: { density?: number; endpoints?: PointArray[]; limitAngle?: boolean; aMin?: number; aMax?: boolean },
    ): Ray[];

    /**
     * Test a single Ray against a single Wall
     * @param ray  The Ray being tested
     * @param wall The Wall against which to test
     * @return A RayIntersection if a collision occurred, or null
     */
    static testWall(ray: Ray, wall: Wall<WallDocument<Scene>>): RayIntersection | null;

    /**
     * Identify the closest collision point from an array of collisions
     * @param collisions  An array of intersection points
     * @return The closest blocking intersection or null if no collision occurred
     */
    static getClosestCollision(collisions: RayIntersection[]): RayIntersection | null;

    /**
     * Normalize an angle to ensure it is baselined to be the smallest angle that is greater than a minimum.
     * @param aMin  The lower-bound minimum angle
     * @param angle The angle to adjust
     * @return The adjusted angle which is greater than or equal to aMin.
     */
    protected static _normalizeAngle(aMin: number, angle: number): number;

    /**
     * Map source types to wall collision types
     * @param type The source polygon type
     * @returns The wall collision attribute
     */
    protected static _mapWallCollisionType(type: WallType): string;
  }

  interface WallsLayerOptions extends PlaceablesLayerOptions {
    name: 'walls';
    controllableObjects: boolean;
    objectClass: typeof Wall;
    quadtree: boolean;
    sheetClass: typeof WallConfig;
    sortActiveTop: boolean;
    zIndex: number;
  }

  type WallType = 'movement' | 'sight' | 'sound';

  type WallMode = 'all' | 'any' | 'closest';
}

declare global {
  /**
   * A PointSourcePolygon implementation that uses CCW (counter-clockwise) geometry orientation.
   * Sweep around the origin, accumulating collision points based on the set of active walls.
   * This algorithm was created with valuable contributions from https://github.com/caewok
   */
  class ClockwiseSweepPolygon extends PointSourcePolygon {
    /** A mapping of vertices which define potential collision points */
    vertices: Map<number, PolygonVertex>;

    /** The set of edges which define potential boundaries of the polygon */
    edges: Set<PolygonEdge>;

    /** A collection of rays which are fired at vertices */
    rays: Ray[];

    protected _compute(): void;

    protected _testCollision(ray: Ray, mode: string): boolean | PolygonVertex | PolygonVertex[] | null;
  }
}

declare global {
  /**
   * A singleton class dedicated to manage the color spaces associated with the scene and the canvas.
   * @category - Canvas
   */
  class CanvasColorManager {
    /** Colors exposed by the manager. */
    colors: {
      darkness: foundry.utils.Color;
      halfdark: foundry.utils.Color;
      background: foundry.utils.Color;
      dim: foundry.utils.Color;
      bright: foundry.utils.Color;
      ambientBrightest: foundry.utils.Color;
      ambientDaylight: foundry.utils.Color;
      ambientDarkness: foundry.utils.Color;
      sceneBackground: foundry.utils.Color;
      fogExplored: foundry.utils.Color;
      fogUnexplored: foundry.utils.Color;
    };

    /** Weights used by the manager to compute colors. */
    weights: {
      dark: number;
      halfdark: number;
      dim: number;
      bright: number;
    };

    /** Returns the darkness penalty for the actual scene configuration. */
    get darknessPenalty(): number;

    /** Get the darkness level of this scene. */
    get darknessLevel(): number;

    /**
     * Initialize color space pertaining to a specific scene.
     * @param [colors={}]
     * @param [colors.backgroundColor]    The background canvas color
     * @param [colors.brightestColor]     The brightest ambient color
     * @param [colors.darknessColor]      The color of darkness
     * @param [colors.darknessLevel]      A preview darkness level
     * @param [colors.daylightColor]      The ambient daylight color
     * @param [colors.fogExploredColor]   The color applied to explored areas
     * @param [colors.fogUnexploredColor] The color applied to unexplored areas
     */
    initialize({
      backgroundColor,
      brightestColor,
      darknessColor,
      darknessLevel,
      daylightColor,
      fogExploredColor,
      fogUnexploredColor,
    }?: {
      backgroundColor?: foundry.utils.Color | number | string;
      brightestColor?: foundry.utils.Color | number | string;
      darknessColor?: foundry.utils.Color | number | string;
      darknessLevel?: number;
      daylightColor?: number;
      fogExploredColor?: number;
      fogUnexploredColor?: number;
    }): void;
  }
}

declare global {
  /**
   * A Detection Mode which can be associated with any kind of sense/vision/perception.
   * A token could have multiple detection modes.
   */
  class DetectionMode {
    id: string;
    label: string;
    tokenConfig: boolean;
    walls: boolean;
    type: DetectionType;

    constructor(params: DetectionModeConstructionParams, context?: DocumentConstructionContext<null>);

    /** Get the detection filter pertaining to this mode. */
    static getDetectionFilter(): PIXI.Filter | undefined;

    /** An optional filter to apply on the target when it is detected with this mode. */
    protected static _detectionFilter: PIXI.Filter | undefined;

    /**
     * The type of the detection mode. If its sight based, sound based, etc.
     * It is related to wall's WALL_RESTRICTION_TYPES
     * @see CONST.WALL_RESTRICTION_TYPES
     */
    static DETECTION_TYPES: {
      SIGHT: 0; // Sight, and anything depending on light perception
      SOUND: 1; // What you can hear. Includes echolocation for bats per example
      MOVE: 2; // This is mostly a sense for touch and vibration, like tremorsense, movement detection, etc.
      OTHER: 3; // Can't fit in other types (smell, life sense, trans-dimensional sense, sense of humor...)
    };

    /** The identifier of the basic sight detection mode. */
    static BASIC_MODE_ID: string;

    /* -------------------------------------------- */
    /*  Visibility Testing                          */
    /* -------------------------------------------- */

    /**
     * Test visibility of a target object or array of points for a specific vision source.
     * @param visionSource The vision source being tested
     * @param mode         The detection mode configuration
     * @param config       The visibility test configuration
     * @returns Is the test target visible?
     */
    testVisibility(
      visionSource: VisionSource<Token>,
      mode: TokenDetectionMode,
      config?: CanvasVisibilityTestConfig,
    ): boolean;

    /**
     * Can this VisionSource theoretically detect a certain object based on its properties?
     * This check should not consider the relative positions of either object, only their state.
     * @param visionSource The vision source being tested
     * @param target       The target object being tested
     * @returns Can the target object theoretically be detected by this vision source?
     */
    protected _canDetect(visionSource: VisionSource<Token>, target: PlaceableObject): boolean;

    /**
     * Evaluate a single test point to confirm whether it is visible.
     * Standard detection rules require that the test point be both within LOS and within range.
     * @param visionSource The vision source being tested
     * @param mode         The detection mode configuration
     * @param target       The target object being tested
     * @param test         The test case being evaluated
     */
    protected _testPoint(
      visionSource: VisionSource<Token>,
      mode: TokenDetectionMode,
      target: PlaceableObject,
      test: CanvasVisibilityTest,
    ): boolean;

    /**
     * Test whether the line-of-sight requirement for detection is satisfied.
     * Always true if the detection mode bypasses walls, otherwise the test point must be contained by the LOS polygon.
     * The result of is cached for the vision source so that later checks for other detection modes do not repeat it.
     * @param visionSource The vision source being tested
     * @param mode         The detection mode configuration
     * @param target       The target object being tested
     * @param test         The test case being evaluated
     * @returns Is the LOS requirement satisfied for this test?
     */
    protected _testLOS(
      visionSource: VisionSource<Token>,
      mode: TokenDetectionMode,
      target: PlaceableObject,
      test: CanvasVisibilityTest,
    ): boolean;

    /**
     * Verify that a target is in range of a source.
     * @param visionSource The vision source being tested
     * @param mode         The detection mode configuration
     * @param target       The target object being tested
     * @param test         The test case being evaluated
     * @returns Is the target within range?
     */
    protected _testRange(
      visionSource: VisionSource<Token>,
      mode: TokenDetectionMode,
      target: PlaceableObject,
      test: CanvasVisibilityTest,
    ): boolean;
  }

  /**
   * A special detection mode which models standard human vision.
   * This mode is the default case which is tested first when evaluating visibility of objects.
   * It is also a special case, in that it is the only detection mode which considers the area of distant light sources.
   */
  class DetectionModeBasicSight extends DetectionMode {
    static override BASIC_MODE_ID: 'basicSight';

    protected override _testPoint(
      visionSource: VisionSource<Token>,
      mode: TokenDetectionMode,
      target: PlaceableObject,
      test: CanvasVisibilityTest,
    ): boolean;
  }

  /**
   * Detection mode that see invisible creatures.
   * This detection mode allows the source to:
   * - See/Detect the invisible target as if visible.
   * - The "See" version needs sight and is affected by blindness
   */
  class DetectionModeInvisibility extends DetectionMode {
    static override getDetectionFilter(): PIXI.Filter;

    protected override _canDetect(visionSource: VisionSource<Token>, target: PlaceableObject): boolean;
  }

  /**
   * Detection mode that see creatures in contact with the ground.
   */
  class DetectionModeTremor extends DetectionMode {
    static override getDetectionFilter(): OutlineOverlayFilter;

    protected override _canDetect(visionSource: VisionSource<Token>, target: PlaceableObject): boolean;
  }

  /**
   * Detection mode that see ALL creatures (no blockers).
   * If not constrained by walls, see everything within the range.
   */
  class DetectionModeAll extends DetectionMode {
    static override getDetectionFilter(): PIXI.Filter;

    protected override _canDetect(visionSource: VisionSource<Token>, target: PlaceableObject): boolean;
  }

  interface TokenDetectionMode {
    /** The id of the detection mode, a key from CONFIG.Canvas.detectionModes */
    id: string;
    /** Whether or not this detection mode is presently enabled */
    enabled: boolean;
    /** The maximum range in distance units at which this mode can detect targets */
    range: number;
  }

  type DetectionType = (typeof DetectionMode.DETECTION_TYPES)[keyof typeof DetectionMode.DETECTION_TYPES];
}

interface DetectionModeConstructionParams {
  id: string;
  label: string;
  // If this DM is available in Token Config UI
  tokenConfig?: boolean;
  // If this DM is constrained by walls
  walls?: boolean;
  type?: DetectionType;
}

declare global {
  /**
   * A helper class which manages the refresh workflow for perception layers on the canvas.
   * This controls the logic which batches multiple requested updates to minimize the amount of work required.
   * A singleton instance is available as canvas#perception.
   * @see {Canvas#perception}
   */
  class PerceptionManager {
    /**
     * The set of state flags which are supported by the Perception Manager.
     * When a refresh occurs, operations associated with each true flag are executed and the state is reset.
     */
    static FLAGS: {
      initializeLighting: { propagate: ['refreshLighting']; reset: [] };
      refreshLighting: { propagate: ['refreshLightSources']; reset: [] };
      refreshLightSources: { propagate: []; reset: [] };
      refreshVisionSources: { propagate: []; reset: [] };
      refreshPrimary: { propagate: []; reset: [] };
      initializeVision: {
        propagate: ['refreshVision', 'refreshTiles', 'refreshLighting', 'refreshLightSources', 'refreshPrimary'];
        reset: [];
      };
      refreshVision: { propagate: ['refreshVisionSources']; reset: [] };
      initializeSounds: { propagate: ['refreshSounds']; reset: [] };
      refreshSounds: { propagate: []; reset: [] };
      refreshTiles: { propagate: ['refreshLightSources', 'refreshVisionSources']; reset: [] };
      soundFadeDuration: { propagate: []; reset: [] };
      forceUpdateFog: { propagate: []; reset: [] };
    };

    /* -------------------------------------------- */
    /*  Perception Manager Methods                  */
    /* -------------------------------------------- */

    /**
     * Activate perception management by registering the update function to the Ticker.
     */
    activate(): void;

    /**
     * Deactivate perception management by un-registering the update function from the Ticker.
     */
    deactivate(): void;

    /**
     * Update perception manager flags which configure which behaviors occur on the next frame render.
     * @param flags      Flag values (true) to assign where the keys belong to PerceptionManager.FLAGS
     * @param [v2=false] Opt-in to passing v2 flags, otherwise a backwards compatibility shim will be applied
     */
    update(flags: { [K in keyof typeof PerceptionManager.FLAGS]?: true }, v2?: boolean): void;

    /**
     * A helper function to perform an immediate initialization plus incremental refresh.
     */
    initialize(): void;

    /**
     * A helper function to perform an incremental refresh only.
     */
    refresh(): void;
  }
}

declare global {
  /**
   * A Vision Mode which can be selected for use by a Token.
   * The selected Vision Mode alters the appearance of various aspects of the canvas while that Token is the POV.
   */
  class VisionMode {
    /**
     * Construct a Vision Mode using provided configuration parameters and callback functions.
     * @param data      Data which fulfills the model defined by the VisionMode schema.
     * @param [options] Additional options passed to the DataModel constructor.
     */
    constructor(data?: object, options?: { animated?: boolean });

    id: string;
    label: string;
    tokenConfig: boolean;
    canvas: {
      shader: PIXI.Shader;
      uniforms: object;
    };

    lighting: {
      background: {
        visibility: LightingVisibility;
        postProcessingModes: string[];
        uniforms: object;
      };
      coloration: {
        visibility: LightingVisibility;
        postProcessingModes: string[];
        uniforms: LightingVisibility;
      };
      illumination: {
        visibility: number;
        postProcessingModes: string[];
        uniforms: object;
      };
      levels: { [K in keyof typeof VisionMode.LIGHTING_LEVELS]?: (typeof VisionMode.LIGHTING_LEVELS)[K] };
      multipliers: { [K in keyof typeof VisionMode.LIGHTING_LEVELS]?: (typeof VisionMode.LIGHTING_LEVELS)[K] };
    };

    vision: {
      background: { shader: PIXI.Shader; uniforms: object };
      coloration: { shader: PIXI.Shader; uniforms: object };
      illumination: { shader: PIXI.Shader; uniforms: object };
      darkness: {
        adaptive: boolean;
      };
      defaults: Partial<
        Pick<TokenDocument['sight'], 'attenuation' | 'brightness' | 'saturation' | 'contrast' | 'range'>
      >;
    };

    /** The lighting illumination levels which are supported. */
    static LIGHTING_LEVELS: {
      DARKNESS: -2;
      HALFDARK: -1;
      UNLIT: 0;
      DIM: 1;
      BRIGHT: 2;
      BRIGHTEST: 3;
    };

    /**
     * Flags for how each lighting channel should be rendered for the currently active vision modes:
     * - Disabled: this lighting layer is not rendered, the shaders does not decide.
     * - Enabled: this lighting layer is rendered normally, and the shaders can choose if they should be rendered or not.
     * - Required: the lighting layer is rendered, the shaders does not decide.
     */
    static LIGHTING_VISIBILITY: {
      DISABLED: 0;
      ENABLED: 1;
      REQUIRED: 2;
    };

    /** A flag for whether this vision source is animated */
    animated: boolean;

    /**
     * Special handling which is needed when this Vision Mode is activated for a VisionSource.
     * @param source Activate this VisionMode for a specific source
     */
    activate(source: VisionSource<Token>): void;

    /**
     * An animation function which runs every frame while this Vision Mode is active.
     * @param dt The deltaTime passed by the PIXI Ticker
     */
    animate(dt: number): Promise<void>;

    /**
     * Special handling which is needed when this Vision Mode is deactivated for a VisionSource.
     * @param source Deactivate this VisionMode for a specific source
     */
    deactivate(source: VisionSource<Token>): void;
  }

  type LightingVisibility = (typeof VisionMode.LIGHTING_VISIBILITY)[keyof typeof VisionMode.LIGHTING_VISIBILITY];
}

declare global {
  /**
   * An Abstract Base Class which defines a Placeable Object which represents an Entity placed on the Canvas
   * @param document The Document instance which is represented by this object
   */
  abstract class PlaceableObject<
    TDocument extends CanvasDocument = CanvasDocument,
  > extends RenderFlagsContainer<TDocument> {
    constructor(document: TDocument);

    static override RENDER_FLAGS: {
      redraw: { propagate: string[] };
      refresh: { propagate: string[]; alias: boolean };
      refreshState: {};
    };

    /** Retain a reference to the Scene within which this Placeable Object resides */
    scene: TDocument['parent'];

    /** A reference to the Scene embedded Document instance which this object represents */
    document: TDocument;

    /**
     * Track the field of vision for the placeable object.
     * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
     */
    vision: { fov: unknown; shape: unknown };

    /** A control icon for interacting with the object */
    controlIcon: ControlIcon;

    /** A mouse interaction manager instance which handles mouse workflows related to this object. */
    mouseInteractionManager: MouseInteractionManager;

    /* -------------------------------------------- */
    /* Properties                                   */
    /* -------------------------------------------- */

    /** Identify the official EmbeddedEntity name for this PlaceableObject class */
    static embeddedName: string;

    /** Passthrough certain drag operations on locked objects. */
    protected _dragPassthrough: boolean;

    /** Know if a placeable is in the hover-in state.  */
    protected _isHoverIn: boolean;

    /**
     * The bounding box for this PlaceableObject.
     * This is required if the layer uses a Quadtree, otherwise it is optional
     */
    get bounds(): PIXI.Rectangle;

    /** The central coordinate pair of the placeable object based on it's own width and height */
    get center(): PIXI.Point;

    /** The id of the corresponding Document which this PlaceableObject represents. */
    get id(): string;

    /** A unique identifier which is used to uniquely identify elements on the canvas related to this object. */
    get objectId(): string;

    /**
     * The named identified for the source object associated with this PlaceableObject.
     * This differs from the objectId because the sourceId is the same for preview objects as for the original.
     */
    get sourceId(): string;

    /** Is this placeable object a temporary preview? */
    get isPreview(): boolean;

    /** The field-of-vision polygon for the object, if it has been computed */
    get fov(): PIXI.Polygon;

    /** Provide a reference to the CanvasLayer which contains this PlaceableObject. */
    get layer(): PlaceablesLayer<this>;

    /** The line-of-sight polygon for the object, if it has been computed */
    get los(): PIXI.Polygon | null;

    /**
     * A Form Application which is used to configure the properties of this Placeable Object or the EmbeddedEntity
     * it represents.
     */
    get sheet(): TDocument['sheet'];

    /** An indicator for whether the object is currently controlled */
    get controlled(): boolean;

    /** An indicator for whether the object is currently a hover target */
    get hover(): boolean;

    /* -------------------------------------------- */
    /*  Permission Controls                         */
    /* -------------------------------------------- */

    /**
     * Test whether a user can perform a certain interaction with regards to a Placeable Object
     * @param user   The User performing the action
     * @param action The named action being attempted
     * @return Does the User have rights to perform the action?
     */
    can(user: User, action: UserAction): boolean;

    /** Can the User access the HUD for this Placeable Object? */
    protected _canHUD(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to configure the Placeable Object? */
    protected _canConfigure(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to control the Placeable Object? */
    protected _canControl(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to view details of the Placeable Object? */
    protected _canView(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to create the underlying Embedded Entity? */
    protected _canCreate(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to drag this Placeable Object? */
    protected _canDrag(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to hover on this Placeable Object? */
    protected _canHover(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to update the underlying Embedded Entity? */
    protected _canUpdate(user: User, event?: PIXI.FederatedEvent): boolean;

    /** Does the User have permission to delete the underlying Embedded Entity? */
    protected _canDelete(user: User, event?: PIXI.FederatedEvent): boolean;

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    /**
     * Apply any current render flags, clearing the renderFlags set.
     * Subclasses should override this method to define behavior.
     */
    applyRenderFlags(): void;

    /**
     * Apply render flags before a render occurs.
     * @param flags  The render flags which must be applied
     */
    protected _applyRenderFlags(flags: Record<string, boolean>): void;

    /**
     * Clear the display of the existing object
     * @return The cleared object
     */
    clear(): this;

    /**
     * Clone the placeable object, returning a new object with identical attributes
     * The returned object is non-interactive, and has no assigned ID
     * If you plan to use it permanently you should call the create method
     *
     * @return A new object with identical data
     */
    clone(): this;

    override destroy(options?: boolean | PIXI.IDestroyOptions): void;

    /**
     * The inner _destroy method which may optionally be defined by each PlaceableObject subclass.
     * @param [options] Options passed to the initial destroy call
     */
    protected _destroy(options?: boolean | PIXI.IDestroyOptions): void;

    /** Draw the placeable object into its parent container */
    draw(): Promise<this>;

    /** The inner _draw method which must be defined by each PlaceableObject subclass. */
    protected abstract _draw(): Promise<void>;

    /**
     * Refresh the current display state of the Placeable Object
     * @return The refreshed object
     */
    refresh(): this;

    /** Update the quadtree. */
    protected _updateQuadtree(): void;

    /** Get the target opacity that should be used for a Placeable Object depending on its preview state. */
    protected _getTargetAlpha(): number;

    /** Register pending canvas operations which should occur after a new PlaceableObject of this type is created */
    protected _onCreate(
      data: TDocument['_source'],
      options: DocumentModificationContext<TDocument['parent']>,
      userId: string,
    ): void;

    /** Define additional steps taken when an existing placeable object of this type is updated with new data */

    protected _onUpdate(
      changed: DeepPartial<TDocument['_source']>,
      options: DocumentUpdateContext<TDocument['parent']>,
      userId: string,
    ): void;

    /** Define additional steps taken when an existing placeable object of this type is deleted */

    protected _onDelete(options: DocumentModificationContext<TDocument['parent']>, userId: string): void;

    /* -------------------------------------------- */
    /*  Methods                                     */
    /* -------------------------------------------- */

    /**
     * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
     * @param options               Additional options which modify the control request
     * @param options.releaseOthers Release any other controlled objects first
     * @return                      A flag denoting whether or not control was successful
     */
    control(options?: { releaseOthers?: boolean }): boolean;

    /**
     * Additional events which trigger once control of the object is established
     * @param options Optional parameters which apply for specific implementations
     */
    protected _onControl(options?: { releaseOthers?: boolean }): void;

    /**
     * Release control over a PlaceableObject, removing it from the controlled set
     * @return  A Boolean flag confirming the object was released.
     */
    release(options?: object): boolean;

    /**
     * Additional events which trigger once control of the object is released
     * @param options   Options which modify the releasing workflow
     */
    protected _onRelease(options?: object): void;

    /**
     * Rotate the PlaceableObject to a certain angle of facing
     * @param angle The desired angle of rotation
     * @param snap  Snap the angle of rotation to a certain target degree increment
     * @return The rotated object
     */
    rotate(angle: number, snap: number): Promise<this | TDocument | undefined>;

    /**
     * Determine a new angle of rotation for a PlaceableObject either from an explicit angle or from a delta offset.
     * @param angle An explicit angle, either this or delta must be provided
     * @param delta A relative angle delta, either this or the angle must be provided
     * @param snap  A precision (in degrees) to which the resulting angle should snap. Default is 0.
     * @return      The new rotation angle for the object
     */
    protected _updateRotation({ angle, delta, snap }?: { angle?: number; delta?: number; snap?: number }): number;

    /**
     * Obtain the shifted position for the Object
     * @param dx    The number of grid units to shift along the X-axis
     * @param dy    The number of grid units to shift along the Y-axis
     * @return      The target movement coordinates subject to some offset
     */
    protected _getShiftedPosition(dx: number, dy: number): { x: number; y: number };

    /* -------------------------------------------- */
    /*  Interactivity                               */
    /* -------------------------------------------- */

    /** Activate interactivity for the Placeable Object */
    activateListeners(): void;

    /** Create a standard MouseInteractionManager for the PlaceableObject */
    protected _createInteractionManager(): MouseInteractionManager;

    /** Actions that should be taken for this Placeable Object when a mouseover event occurs */
    protected _onHoverIn(
      event: PIXI.FederatedPointerEvent,
      { hoverOutOthers }?: { hoverOutOthers?: boolean },
    ): boolean | void;

    /** Actions that should be taken for this Placeable Object when a mouseout event occurs */
    protected _onHoverOut(event: PIXI.FederatedPointerEvent): boolean | void;

    /** Should the placeable propagate left click downstream? */
    protected _propagateLeftClick(event: PIXI.FederatedPointerEvent): boolean;

    /** Callback actions which occur on a single left-click event to assume control of the object */
    protected _onClickLeft(event: PIXI.FederatedPointerEvent): boolean | void;

    /** Callback actions which occur on a double left-click event to activate */
    protected _onClickLeft2(event: PIXI.FederatedPointerEvent): boolean | void;

    /** Callback actions which occur on a single right-click event to configure properties of the object */
    protected _onClickRight(event: PIXI.FederatedPointerEvent): void;

    /**
     * Handle mouse-wheel events at the PlaceableObjects layer level to rotate multiple objects at once.
     * This handler will rotate all controlled objects by some incremental angle.
     * @param event The mousewheel event which originated the request
     */
    protected _onMouseWheel(event: WheelEvent): void;

    /** Callback actions which occur on a double right-click event to configure properties of the object */
    protected _onClickRight2(event: PIXI.FederatedPointerEvent): void;

    /** Callback actions which occur when a mouse-drag action is first begun. */
    protected _onDragLeftStart(event: PIXI.FederatedPointerEvent): void;

    /**
     * Begin a drag operation from the perspective of the preview clone.
     * Modify the appearance of both the clone (this) and the original (_original) object.
     */
    protected _onDragStart(): void;

    /**
     * Conclude a drag operation from the perspective of the preview clone.
     * Modify the appearance of both the clone (this) and the original (_original) object.
     */
    protected _onDragEnd(): void;

    /** Callback actions which occur on a mouse-move operation. */
    protected _onDragLeftMove(event: PlaceablesLayerPointerEvent<this>): void;

    /** Callback actions which occur on a mouse-move operation. */
    protected _onDragLeftDrop(event: PlaceablesLayerPointerEvent<this>): Promise<TDocument[] | void>;

    /** Callback actions which occur on a mouse-move operation. */
    protected _onDragLeftCancel(event: PlaceablesLayerPointerEvent<this>): void;
  }

  interface PlaceableObject<TDocument extends CanvasDocument = CanvasDocument> extends RenderFlagsContainer<TDocument> {
    hitArea: PIXI.Rectangle;
  }
}

declare class RenderFlagsContainer<TDocument extends CanvasDocument> extends PIXI.Container {
  constructor(document: TDocument);

  /** Configure the render flags used for this class. */
  static RENDER_FLAGS: Record<string, Partial<RenderFlag>>;

  /**
   * The ticker priority when RenderFlags of this class are handled.
   * Valid values are OBJECTS or PERCEPTION.
   */
  static RENDER_FLAG_PRIORITY: 'OBJECTS';

  /**
   * Status flags which are applied at render-time to update the PlaceableObject.
   * If an object defines RenderFlags, it should at least include flags for "redraw" and "refresh".
   */
  renderFlags: RenderFlags;

  /**
   * Apply any current render flags, clearing the renderFlags set.
   * Subclasses should override this method to define behavior.
   */
  applyRenderFlags(): void;
}

interface PrimaryCanvasObjectData {
  /** The x-coordinate of the PCO location */
  x: number;
  /** The y-coordinate of the PCO location */
  y: number;
  /** The z-index of the PCO */
  z: number;
  /** The width of the PCO */
  width: number;
  /** The height of the PCO */
  height: number;
  /** The alpha of this PCO */
  alpha: number;
  /** The rotation of this PCO */
  rotation: number;
  /** The PCO is hidden? */
  hidden: boolean;
  /** The elevation of the PCO */
  elevation: number | undefined;
  /** The sort key that resolves ties among the same elevation */
  sort: number;
  /** The data texture values */
  texture: SourcePropFromDataField<foundry.data.TextureData>;
}

declare global {
  /**
   * A SpriteMesh which visualizes a Token object in the PrimaryCanvasGroup.
   * @todo: fill in
   */
  class TokenMesh extends SpriteMesh {
    data: PrimaryCanvasObjectData;
    get sort(): number;

    initialize(data: { sort?: number }): void;

    refresh(): void;

    /**
     * Get the attributes for this TokenMesh which configure the display of this TokenMesh and are compatible
     * with CanvasAnimation.
     */
    getDisplayAttributes(): TokenMeshDisplayAttributes;
  }

  interface TokenMeshDisplayAttributes {
    x: number;
    y: number;
    width: number;
    height: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
    tint: foundry.utils.Color;
  }
}

declare global {
  /**
   * A PlaceablesLayer designed for rendering the visual Scene for a specific vertical cross-section.
   * @category - Canvas
   */
  class Tile<
    TDocument extends TileDocument<Scene | null> = TileDocument<Scene | null>,
  > extends PlaceableObject<TDocument> {
    /* -------------------------------------------- */
    /*  Attributes                                  */
    /* -------------------------------------------- */

    /** The Tile border frame */
    frame: TileBorderFrame;

    /**
     * The primary tile image texture
     */
    texture: PIXI.Texture;

    /** The Tile image sprite */
    tile: PIXI.Sprite;

    /** The occlusion image sprite */
    occlusionTile: PIXI.Sprite;

    /** A Tile background which is displayed if no valid image texture is present */
    bg: PIXI.Graphics;

    /** A cached mapping of non-transparent pixels */
    protected _alphaMap: {
      minX: number;
      minY: number;
      maxX: number;
      maxY: number;
      pixels: Uint8Array | undefined;
      texture: PIXI.RenderTexture | undefined;
    };

    /** A flag which tracks whether the overhead tile is currently in an occluded state */
    occluded: boolean;

    static override embeddedName: 'Tile';

    /** Get the native aspect ratio of the base texture for the Tile sprite */
    get aspectRatio(): number;

    override get bounds(): PIXI.Rectangle;

    /** The HTML source element for the primary Tile texture */
    get sourceElement(): HTMLImageElement | HTMLVideoElement;

    /** Does this Tile depict an animated video texture? */
    get isVideo(): boolean;

    /** Is this tile a roof */
    get isRoof(): boolean;

    /** The effective volume at which this Tile should be playing, including the global ambient volume modifier */
    get volume(): number;

    /* -------------------------------------------- */
    /*  Rendering                                   */
    /* -------------------------------------------- */

    protected _draw(): Promise<void>;

    override destroy(options: object): void;

    /** @param [options.refreshPerception=false]  Also refresh the perception layer. */
    override refresh(options?: { refreshPerception?: boolean }): this;

    /** Refresh the display of the Tile border */
    protected _refreshBorder(b: PIXI.Rectangle): void;

    /** Refresh the display of the Tile resizing handle */
    protected _refreshHandle(b: PIXI.Rectangle): void;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    override _onUpdate(
      changed: DeepPartial<TDocument['_source']>,
      options: DocumentModificationContext<TDocument['parent']>,
      userId: string,
    ): void;

    override _onDelete(options: DocumentModificationContext<TDocument['parent']>, userId: string): void;

    /**
     * Update wall states and refresh lighting and vision when a tile becomes a roof, or when an existing roof tile's
     * state changes.
     */
    protected _refreshPerception(): void;

    /* -------------------------------------------- */
    /*  Interactivity                               */
    /* -------------------------------------------- */

    override activateListeners(): void;

    protected override _canConfigure(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _onClickLeft2(event: PIXI.FederatedPointerEvent): void;

    protected override _onDragLeftStart(event: PIXI.FederatedPointerEvent): void;

    protected override _onDragLeftMove(event: PIXI.FederatedPointerEvent): void;

    protected override _onDragLeftDrop(event: PIXI.FederatedPointerEvent): Promise<this['document'][]>;

    protected override _onDragLeftCancel(event: PIXI.FederatedPointerEvent): void;

    /* -------------------------------------------- */
    /*  Resize Handling                             */
    /* -------------------------------------------- */

    /**
     * Handle mouse-over event on a control handle
     * @param event The mouseover event
     */
    protected _onHandleHoverIn(event: PIXI.FederatedPointerEvent): void;

    /**
     * Handle mouse-out event on a control handle
     * @param event The mouseout event
     */
    protected _onHandleHoverOut(event: PIXI.FederatedPointerEvent): void;

    /**
     * When we start a drag event - create a preview copy of the Tile for re-positioning
     * @param event The mousedown event
     */
    protected _onHandleMouseDown(event: PIXI.FederatedPointerEvent): void;

    /**
     * Handle the beginning of a drag event on a resize handle
     * @param event The mousedown event
     */
    protected _onHandleDragStart(event: PIXI.FederatedPointerEvent): void;

    /**
     * Handle mousemove while dragging a tile scale handler
     * @param event The mousemove event
     */
    protected _onHandleDragMove(event: PIXI.FederatedPointerEvent): void;

    /**
     * Handle mouseup after dragging a tile scale handler
     * @param event The mouseup event
     */
    protected _onHandleDragDrop(event: PIXI.FederatedPointerEvent): void;

    /** Get resized Tile dimensions */
    protected _getResizedDimensions(event: PIXI.FederatedEvent, origin: Point, destination: Point): Rectangle;

    /** Handle cancellation of a drag event for one of the resizing handles */
    protected _onHandleDragCancel(): void;

    /**
     * Create a preview tile with a background texture instead of an image
     * @param data Initial data with which to create the preview Tile
     */
    static createPreview(data: DeepPartial<foundry.documents.TileSource>): Tile;
  }

  interface Tile<TDocument extends TileDocument<Scene | null> = TileDocument<Scene | null>>
    extends PlaceableObject<TDocument> {
    get layer(): TilesLayer<this>;
  }
}

interface TileBorderFrame extends PIXI.Container {
  border: PIXI.Graphics;
  handle: ResizeHandle;
}

declare global {
  /** A Token is an implementation of PlaceableObject that represents an Actor within a viewed Scene on the game canvas. */
  class Token<TDocument extends TokenDocument = TokenDocument> extends PlaceableObject<TDocument> {
    constructor(document: TDocument);

    static override embeddedName: 'Token';

    static override RENDER_FLAGS: {
      redraw: { propagate: ['refresh'] };
      redrawEffects: {};
      refresh: {
        propagate: [
          'refreshState',
          'refreshSize',
          'refreshPosition',
          'refreshElevation',
          'refreshBars',
          'refreshNameplate',
          'refreshBorder',
          'refreshShader',
        ];
        alias: true;
      };
      refreshState: { propagate: ['refreshVisibility', 'refreshBorder'] };
      refreshSize: {
        propagate: [
          'refreshMesh',
          'refreshBorder',
          'refreshBars',
          'refreshPosition',
          'refreshTarget',
          'refreshEffects',
        ];
      };
      refreshPosition: { propagate: ['refreshMesh', 'refreshVisibility'] };
      refreshElevation: { propagate: ['refreshMesh'] };
      refreshVisibility: {};
      refreshEffects: {};
      refreshMesh: {};
      refreshShader: {};
      refreshBars: {};
      refreshNameplate: {};
      refreshBorder: {};
      refreshTarget: {};
    };

    /** Defines the filter to use for detection. */
    detectionFilter: PIXI.Filter | null;

    /** A Graphics instance which renders the border frame for this Token inside the GridLayer. */
    border: PIXI.Graphics;

    /** Track the set of User entities which are currently targeting this Token */
    targeted: Set<User>;

    /** A reference to the SpriteMesh which displays this Token in the PrimaryCanvasGroup. */
    mesh: TokenMesh;

    /** A reference to the PointSource object which defines this vision source area of effect */
    vision: VisionSource<this>;

    /** A reference to the PointSource object which defines this light source area of effect */
    light: LightSource<this>;

    /** A reference to an animation that is currently in progress for this Token, if any */
    _animation: Promise<unknown> | null;

    /**
     * An Object which records the Token's prior velocity dx and dy
     * This can be used to determine which direction a Token was previously moving
     */
    protected _velocity: TokenVelocity;

    /** The Token's most recent valid position */
    protected _validPosition: Point;

    /** Load token texture */
    texture: PIXI.Texture;

    /** A linked ObjectHUD element which is synchronized with the location and visibility of this Token */
    hud: ObjectHUD<this>;

    /**
     * Establish an initial velocity of the token based on it's direction of facing.
     * Assume the Token made some prior movement towards the direction that it is currently facing.
     */
    protected _getInitialVelocity(): TokenVelocity;

    /* -------------------------------------------- */
    /*  Permission Attributes                       */
    /* -------------------------------------------- */

    /** A convenient reference to the Actor object associated with the Token embedded document. */
    get actor(): TDocument['actor'];

    /** A convenient reference for whether the current User has full control over the Token document. */
    get isOwner(): boolean;

    /** A boolean flag for whether the current game User has observer permission for the Token */
    get observer(): boolean;

    /** Is the HUD display active for this token? */
    get hasActiveHUD(): boolean;

    /** Convenience access to the token's nameplate string */
    get name(): string;

    /* -------------------------------------------- */
    /*  Rendering Attributes                        */
    /* -------------------------------------------- */

    icon?: PIXI.Sprite;
    bars?: PIXI.Container & { bar1: PIXI.Graphics; bar2: PIXI.Graphics };
    nameplate?: PIXI.Text;
    tooltip?: PIXI.Container;
    effects?: PIXI.Container;
    target?: PIXI.Graphics;

    override get bounds(): PIXI.Rectangle;

    /** Translate the token's grid width into a pixel width based on the canvas size */
    get w(): number;

    /** Translate the token's grid height into a pixel height based on the canvas size */
    get h(): number;

    /** The Token's current central position */
    override get center(): PIXI.Point;

    /** The HTML source element for the primary Tile texture */
    get sourceElement(): HTMLImageElement | HTMLVideoElement;

    /** The named identified for the source object associated with this Token */
    override get sourceId(): `Token.${string}`;

    /** Does this Tile depict an animated video texture? */
    get isVideo(): boolean;

    /* -------------------------------------------- */
    /*  State Attributes                            */
    /* -------------------------------------------- */

    /** An indicator for whether or not this token is currently involved in the active combat encounter. */
    get inCombat(): boolean;

    /** Return a reference to a Combatant that represents this Token, if one is present in the current encounter. */
    get combatant(): TDocument['combatant'];

    /** An indicator for whether the Token is currently targeted by the active game User */
    get isTargeted(): boolean;

    /**
     * Determine whether the Token is visible to the calling user's perspective.
     * Hidden Tokens are only displayed to GM Users.
     * Non-hidden Tokens are always visible if Token Vision is not required.
     * Controlled tokens are always visible.
     * All Tokens are visible to a GM user if no Token is controlled.
     *
     * @see {SightLayer#testVisibility}
     */
    get isVisible(): boolean | undefined;

    /** The animation name used for Token movement */
    get movementAnimationName(): string;

    /* -------------------------------------------- */
    /*  Lighting and Vision Attributes              */
    /* -------------------------------------------- */

    /** Test whether the Token has sight (or blindness) at any radius */
    get hasSight(): boolean;

    /** Test whether the Token emits light (or darkness) at any radius */
    get emitsLight(): boolean;

    /** Test whether the Token has a limited angle of vision or light emission which would require sight to update on Token rotation */
    get hasLimitedVisionAngle(): boolean;

    /**
     * Translate the token's sight distance in units into a radius in pixels.
     * @return The sight radius in pixels
     */
    get dimRadius(): number;

    /**
     * Translate the token's bright light distance in units into a radius in pixels.
     * @return The bright radius in pixels
     */
    get brightRadius(): number;

    /** Translate the token's vision range in units into a radius in pixels. */
    get sightRange(): number;

    /** Translate the token's maximum vision range that takes into account lights. */
    get optimalSightRange(): number;

    /**
     * Update the light and vision source objects associated with this Token.
     * @param [options={}] Options which configure how perception sources are updated
     * @param [options.defer=false] Defer refreshing the SightLayer to manually call that refresh later
     * @param [options.deleted=false]Indicate that this light source has been deleted
     */
    updateSource(options?: { defer?: boolean; deleted?: boolean }): void;

    /**
     * Update an emitted light source associated with this Token.
     * @param [defer]   Defer refreshing the LightingLayer to manually call that refresh later.
     * @param [deleted] Indicate that this light source has been deleted.
     */
    updateLightSource({ defer, deleted }?: { defer?: boolean; deleted?: boolean }): void;

    /**
     * Update an Token vision source associated for this token.
     * @param [defer]         Defer refreshing the LightingLayer to manually call that refresh later.
     * @param [deleted]       Indicate that this vision source has been deleted.
     * @param [skipUpdateFog] Never update the Fog exploration progress for this update.
     */
    updateVisionSource({
      defer,
      deleted,
      skipUpdateFog,
    }?: {
      defer?: boolean;
      deleted?: boolean;
      skipUpdateFog?: boolean;
    }): void;

    /** Test whether this Token is a viable vision source for the current User */
    protected _isVisionSource(): boolean;

    /* -------------------------------------------- */
    /* Rendering                                    */
    /* -------------------------------------------- */

    override render(renderer: PIXI.Renderer): void;

    /**
     * Render the bound mesh detection filter.
     * Note: this method does not verify that the detection filter exists.
     */
    protected _renderDetectionFilter(renderer: PIXI.Renderer): void;

    override clear(): this;

    protected override _destroy(options?: boolean | PIXI.IDestroyOptions): void;

    protected override _draw(): Promise<void>;

    /* -------------------------------------------- */
    /*  Incremental Refresh                         */
    /* -------------------------------------------- */

    protected override _applyRenderFlags(flags: Record<string, boolean>): void;

    /** Refresh the visibility. */
    protected _refreshVisibility(): void;

    /** Draw the HUD container which provides an interface for managing this Token */
    protected _drawHUD(): ObjectHUD<this>;

    protected override _destroy(options?: object): void;

    /** Apply initial sanitizations to the provided input data to ensure that a Token has valid required attributes. */
    protected _cleanData(): void;

    /** Draw resource bars for the Token */
    protected _drawAttributeBars(): TokenAttributeBars;

    /** Draw the Sprite icon for the Token */
    protected _drawIcon(): Promise<PIXI.Sprite>;

    /**
     * Play video for this Token (if applicable).
     * @param [playing]    Should the Token video be playing?
     * @param [options={}] Additional options for modifying video playback
     * @param [options.loop]   Should the video loop?
     * @param [options.offset] A specific timestamp between 0 and the video duration to begin playback
     * @param [options.volume] Desired volume level of the video's audio channel (if any)
     */
    play(playing?: boolean, { loop, offset, volume }?: { loop?: boolean; offset?: number; volume?: number }): void;

    /**
     * Unlink the playback of this video token from the playback of other tokens which are using the same base texture.
     * @param source The video element source
     */
    protected _unlinkVideoPlayback(source: HTMLVideoElement): Promise<void>;

    /** Update display of the Token, pulling latest data and re-rendering the display of Token components */
    refresh(): this;

    /** Draw the Token border, taking into consideration the grid type and border color */
    protected _refreshBorder(): void;

    /**
     * Get the hex color that should be used to render the Token border
     * @param [options]
     * @param [options.hover]  Return a border color for this hover state, otherwise use the token's current state.
     * @returns The hex color used to depict the border color
     */
    protected _getBorderColor(options?: { hover?: boolean }): number | null;

    /** Refresh the display of the Token HUD interface. */
    refreshHUD(): void;

    /**
     * Refresh the target indicators for the Token.
     * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.
     */
    protected _refreshTarget(): void;

    /**
     * Refresh the display of Token attribute bars, rendering latest resource data
     * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.
     */
    drawBars(): void;

    /**
     * Draw a single resource bar, given provided data
     * @param number The Bar number
     * @param bar The Bar container
     * @param data Resource data for this bar
     */
    protected _drawBar(number: number, bar: PIXI.Graphics, data: TokenResourceData): void;

    /**
     * Draw the token's nameplate as a text object
     * @return The Text object for the Token nameplate
     */
    protected _drawNameplate(): PIXI.Text;

    /** Draw a text tooltip for the token which can be used to display Elevation or a resource value */
    protected _drawTooltip(): void;

    /** Return the text which should be displayed in a token's tooltip field */
    protected _getTooltipText(): string;

    protected _getTextStyle(): PIXI.TextStyle;

    /** Draw the active effects and overlay effect icons which are present upon the Token */
    drawEffects(): Promise<void>;

    /** Draw the overlay effect icon */
    protected _drawOverlay({ src, tint }?: { src?: string; tint?: number }): Promise<void>;

    /** Draw a status effect icon */
    protected _drawEffect(src: ImageFilePath, i: number, bg: PIXI.Container, w: number, tint: number): Promise<void>;

    /**
     * Helper method to determine whether a token attribute is viewable under a certain mode
     * @param mode The mode from CONST.TOKEN_DISPLAY_MODES
     * @return Is the attribute viewable?
     */
    protected _canViewMode(mode: TokenDisplayMode): boolean;

    /**
     * Animate changes to the appearance of the Token.
     * Animations are performed over differences between the TokenDocument and the current Token and TokenMesh appearance.
     * @param updateData A record of the differential data which changed, for reference only
     * @param [options]  Options which configure the animation behavior
     * @param [options.ontick]        An optional function called each animation frame
     * @param [options.movementSpeed] A desired token movement speed in grid spaces per second
     * @param [options.a0]            The animation starting attributes if different from those cached.
     * @param [options.hoverInOut]    The placeable need hover/un-hover emulation.
     * @returns A promise which resolves once the animation is complete
     */
    animate(updateData: Record<string, unknown>, options?: TokenAnimationOptions<this>): Promise<void>;

    /** Update perception each frame depending on the animation configuration */
    protected _animatePerceptionFrame({
      source,
      sound,
      fog,
    }?: {
      source?: boolean;
      sound?: boolean;
      fog?: boolean;
    }): void;

    /** Terminate animation of this particular Token */
    stopAnimation(): void;

    /**
     * Check for collision when attempting a move to a new position
     * @param destination  The central destination point of the attempted movement
     * @param [options={}] Additional options forwarded to WallsLayer#checkCollision
     * @returns The result of the WallsLayer#checkCollision test
     */
    checkCollision(destination: Point, { type, mode }: { type?: WallRestrictionType; mode: 'closest' }): PolygonVertex;
    checkCollision(destination: Point, { type, mode }: { type?: WallRestrictionType; mode: 'any' }): boolean;
    checkCollision(destination: Point, { type, mode }: { type?: WallRestrictionType; mode: 'all' }): PolygonVertex[];
    checkCollision(
      destination: Point,
      { type, mode }?: { type?: WallRestrictionType; mode?: undefined },
    ): PolygonVertex[];
    checkCollision(
      destination: Point,
      { type, mode }?: { type?: WallRestrictionType; mode?: WallMode },
    ): boolean | PolygonVertex | PolygonVertex[];

    /**
     * Handle changes to Token behavior when a significant status effect is applied
     * @param statusId The status effect ID being applied, from CONFIG.specialStatusEffects
     * @param active   Is the special status effect now active?
     */
    _onApplyStatusEffect(statusId: string, active: boolean): void;

    protected override _onControl(options?: { releaseOthers?: boolean; pan?: boolean }): void;

    protected override _onRelease(options?: Record<string, unknown>): void;

    /**
     * Get the center-point coordinate for a given grid position
     * @param x The grid x-coordinate that represents the top-left of the Token
     * @param y The grid y-coordinate that represents the top-left of the Token
     * @return The coordinate pair which represents the Token's center at position (x, y)
     */
    getCenter(x: number, y: number): Point;

    /**
     * Set the token's position by comparing its center position vs the nearest grid vertex
     * Return a Promise that resolves to the Token once the animation for the movement has been completed
     * @param x The x-coordinate of the token center
     * @param y The y-coordinate of the token center
     * @param [options={}] Additional options which configure the token movement
     * @param [options.animate=true] Animate the movement path
     * @return The Token after animation has completed
     */
    setPosition(x: number, y: number, { animate }?: { animate?: boolean }): Promise<this>;

    /**
     * Update the Token velocity auto-regressively, shifting increasing weight towards more recent movement
     * Employ a magic constant chosen to minimize (effectively zero) the likelihood of trigonometric edge cases
     * @param ray The proposed movement ray
     * @return An updated velocity with directional memory
     */
    protected _updateVelocity(ray: Ray): TokenVelocity;

    /**
     * Set this Token as an active target for the current game User
     * @param targeted       Is the Token now targeted?
     * @param user           Assign the token as a target for a specific User
     * @param releaseOthers  Release other active targets for the same player?
     * @param groupSelection Is this target being set as part of a group selection workflow?
     */
    setTarget(
      targeted?: boolean,
      {
        user,
        releaseOthers,
        groupSelection,
      }?: { user?: User | null; releaseOthers?: boolean; groupSelection?: boolean },
    ): void;

    /**
     * Add or remove the currently controlled Tokens from the active combat encounter
     * @param [combat] A specific combat encounter to which this Token should be added
     * @returns The Token which initiated the toggle
     */
    toggleCombat(combat?: Combat): Promise<this>;

    /**
     * Toggle an active effect by its texture path.
     * Copy the existing Array in order to ensure the update method detects the data as changed.
     * @param effect  The texture file-path of the effect icon to toggle on the Token.
     * @param [options]      Additional optional arguments which configure how the effect is handled.
     * @param [options.active]    Force a certain active state for the effect
     * @param [options.overlay]   Whether to set the effect as the overlay effect?
     * @return Was the texture applied (true) or removed (false)
     */
    toggleEffect(
      effect: StatusEffect | ImageFilePath,
      { active, overlay }?: { active?: boolean; overlay?: boolean },
    ): Promise<boolean>;

    /** A helper function to toggle the overlay status icon on the Token */
    protected _toggleOverlayEffect(texture: ImageFilePath, { active }: { active: boolean }): Promise<this>;

    /**
     * Toggle the visibility state of any Tokens in the currently selected set
     * @return A Promise which resolves to the updated Token documents
     */
    toggleVisibility(): Promise<TDocument[]>;

    /** Return the token's sight origin, tailored for the direction of their movement velocity to break ties with walls */
    getSightOrigin(): Point;

    /**
     * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.
     * This function adds additional padding to the light radius equal to half the token width.
     * This causes light to be measured from the outer token edge, rather than from the center-point.
     * @param units The radius in grid units
     * @return The radius in canvas units
     */
    getLightRadius(units: number): number;

    protected override _getShiftedPosition(dx: number, dy: number): Point;

    override rotate(angle: number, snap: number): Promise<this | undefined>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    protected override _onCreate(
      data: TDocument['_source'],
      options: DocumentModificationContext<TDocument['parent']>,
      userId: string,
    ): void;

    override _onUpdate(
      changed: DeepPartial<TDocument['_source']>,
      options: DocumentModificationContext<TDocument['parent']>,
      userId: string,
    ): void;

    /** Control updates to the appearance of the Token and its linked TokenMesh when a data update occurs. */
    protected _onUpdateAppearance(
      data: DeepPartial<TDocument['_source']>,
      changed: Set<string>,
      options: DocumentModificationContext<TDocument['parent']>,
    ): Promise<void>;

    /** Define additional steps taken when an existing placeable object of this type is deleted */
    protected override _onDelete(options: DocumentModificationContext<TDocument['parent']>, userId: string): void;

    protected override _canControl(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _canHUD(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _canConfigure(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _canHover(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _canView(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _canDrag(user: User, event?: PIXI.FederatedEvent): boolean;

    protected override _onHoverIn(
      event: PIXI.FederatedPointerEvent,
      { hoverOutOthers }?: { hoverOutOthers?: boolean },
    ): boolean | void;

    protected override _onHoverOut(event: PIXI.FederatedPointerEvent): boolean | void;

    protected override _onClickLeft(event: PIXI.FederatedPointerEvent): void;

    protected override _propagateLeftClick(event: PIXI.FederatedPointerEvent): boolean;

    protected override _onClickLeft2(event: PIXI.FederatedPointerEvent): void;

    protected override _onClickRight2(event: PIXI.FederatedPointerEvent): void;

    protected override _onDragLeftDrop(event: TokenPointerEvent<this>): Promise<TDocument[]>;

    protected override _onDragLeftMove(event: TokenPointerEvent<this>): void;

    protected override _onDragLeftCancel(event: TokenPointerEvent<this>): void;

    protected override _onDragStart(): void;

    protected override _onDragEnd(): void;
  }

  interface Token<TDocument extends TokenDocument = TokenDocument> extends PlaceableObject<TDocument> {
    get layer(): TokenLayer<this>;
  }

  interface TokenVelocity {
    dx: number;
    dy: number;
    sx: number;
    sy: number;
  }

  interface TokenAnimationAttribute<T extends Token> {
    attribute: string;
    d: number;
    delta: number;
    done: number;
    parent: T;
    remaining: number;
    to: number;
  }

  interface TokenAnimationConfig {
    animate: boolean;
    fog: boolean;
    sound: boolean;
    source: boolean;
  }

  interface TokenAttributeBars extends PIXI.Container {
    bar1: PIXI.Graphics;
    bar2: PIXI.Graphics;
  }

  interface TokenResourceData {
    attribute: string;
    type: 'bar';
    value: number;
    max?: number;
    editable: boolean;
  }

  interface TokenPointerEvent<T extends Token> extends PlaceablesLayerPointerEvent<T> {
    interactionData: PlaceablesLayerPointerEvent<T>['interactionData'] & {
      clones?: T[];
    };
  }

  interface TokenAnimationOptions<TObject extends Token> extends CanvasAnimationOptions<TObject> {
    /** A desired token movement speed in grid spaces per second */
    movementSpeed?: number;
    a0?: Partial<TokenMeshDisplayAttributes>;
    hoverInOut?: boolean;
  }
}

declare global {
  /**
   * A specialized subclass of the PointSource abstraction which is used to control the rendering of light sources.
   * @param [options.object] The light-emitting object that generates this light source
   */
  class LightSource<TObject extends AmbientLight | Token | null> extends RenderedPointSource<TObject> {
    static sourceType: string;

    protected static override _initializeShaderKeys: string[];

    protected static override _refreshUniformsKeys: string[];

    /* -------------------------------------------- */
    /*  Light Source Attributes                     */
    /* -------------------------------------------- */

    /** The object of data which configures how the source is rendered */
    override data: LightSourceData;

    /** The ratio of dim:bright as part of the source radius */
    ratio: number;

    /* -------------------------------------------- */
    /*  Light Source Properties                     */
    /* -------------------------------------------- */

    /** Is this darkness? */
    get isDarkness(): boolean;

    /* -------------------------------------------- */
    /*  Light Source Initialization                 */
    /* -------------------------------------------- */

    /**
     * Initialize the source with provided object data.
     * @param data Initial data provided to the point source
     * @return A reference to the initialized source
     */
    protected override _initialize(data?: Partial<LightSourceData>): void;

    protected override _configure(changes: object): void;

    protected override _getPolygonConfiguration(): PointSourcePolygonConfig;

    protected override _initializeBlending(): void;

    /* -------------------------------------------- */
    /*  Shader Management                           */
    /* -------------------------------------------- */

    protected override _updateColorationUniforms(): void;

    protected override _updateIlluminationUniforms(): void;

    protected override _updateBackgroundUniforms(): void;

    protected _updateCommonUniforms(shader: PIXI.Shader): void;

    /**
     * Map luminosity value to exposure value
     * luminosity[-1  , 0  [ => Darkness => map to exposure ]   0, 1]
     * luminosity[ 0  , 0.5[ => Light    => map to exposure [-0.5, 0[
     * luminosity[ 0.5, 1  ] => Light    => map to exposure [   0, 1]
     * @param lum The luminosity value
     * @return The exposure value
     */
    protected _mapLuminosity(lum: number): number;

    /* -------------------------------------------- */
    /*  Animation Functions                         */
    /* -------------------------------------------- */
    /**
     * An animation with flickering ratio and light intensity.
     * @param dt           Delta time
     * @param [options={}] Additional options which modify the flame animation
     * @param [options.speed=5]       The animation speed, from 1 to 10
     * @param [options.intensity=5]   The animation intensity, from 1 to 10
     * @param [options.reverse=false] Reverse the animation direction
     */
    animateTorch(dt: number, options?: { speed?: number; intensity?: number; reverse?: boolean }): void;

    /**
     * An animation with flickering ratio and light intensity
     * @param dt           Delta time
     * @param [options={}] Additional options which modify the flame animation
     * @param [options.speed=5]         The animation speed, from 1 to 10
     * @param [options.intensity=5]     The animation intensity, from 1 to 10
     * @param [options.amplification=1] Noise amplification (>1) or dampening (<1)
     * @param [options.reverse=false]   Reverse the animation direction
     */
    animateFlickering(
      dt: number,
      options?: { speed?: number; intensity?: number; amplification?: boolean; reverse?: boolean },
    ): void;

    /**
     * A basic "pulse" animation which expands and contracts.
     * @param dt        Delta time
     * @param speed     The animation speed, from 1 to 10
     * @param intensity The animation intensity, from 1 to 10
     * @param reverse   Is the animation reversed?
     */
    animatePulse(dt: number, options?: { speed?: number; intensity?: number; reverse?: number }): void;

    /* -------------------------------------------- */
    /*  Visibility Testing                          */
    /* -------------------------------------------- */

    /**
     * Test whether this LightSource provides visibility to see a certain target object.
     * @param config The visibility test configuration
     * @param config.tests   The sequence of tests to perform
     * @param config.object  The target object being tested
     * @returns Is the target object visible to this source?
     */
    testVisibility(config: { tests: CanvasVisibilityTest[]; object: PlaceableObject }): boolean;

    /**
     * Can this LightSource theoretically detect a certain object based on its properties?
     * This check should not consider the relative positions of either object, only their state.
     * @param target The target object being tested
     * @returns Can the target object theoretically be detected by this vision source?
     */
    protected _canDetectObject(target: PlaceableObject): boolean;
  }

  /**
   * A specialized subclass of the LightSource which is used to render global light source linked to the scene.
   */
  class GlobalLightSource extends LightSource<null> {
    protected override _createPolygon(): PointSourcePolygon;

    protected override _configureSoftEdges(): void;

    protected override _initialize(data?: Partial<LightSourceData>): void;
  }

  interface LightSourceData extends RenderedPointSourceData {
    /** An opacity for the emitted light, if any */
    alpha: number;
    /** An animation configuration for the source */
    animation: object;
    /** The allowed radius of bright vision or illumination */
    bright: number;
    /** The coloration technique applied in the shader */
    coloration: number;
    /** The amount of contrast this light applies to the background texture */
    contrast: number;
    /** The allowed radius of dim vision or illumination */
    dim: number;
    /** Strength of the attenuation between bright, dim, and dark */
    attenuation: number;
    /** The luminosity applied in the shader */
    luminosity: number;
    /** The amount of color saturation this light applies to the background texture */
    saturation: number;
    /** The depth of shadows this light applies to the background texture */
    shadows: number;
    /** Whether or not this source provides a source of vision */
    vision: boolean;
  }

  interface LightSourceMeshes {
    background: PIXI.Mesh | null;
    light: PIXI.Mesh | null;
    color: PIXI.Mesh | null;
  }
}

declare global {
  /**
   * A specialized subclass of the PointSource abstraction which is used to control the rendering of sound sources.
   * @param object The AmbientSound object that generates this sound source
   */
  class SoundSource<TObject extends PlaceableObject> extends PointSource<TObject> {
    static sourceType: 'sound';

    protected override _getPolygonConfiguration(): PointSourcePolygonConfig;
  }
}

declare global {
  /**
   * A mixin which decorates a PIXI.Filter or PIXI.Shader with common properties.
   * @category - Mixins
   * @param ShaderClass The parent ShaderClass class being mixed.
   * @returns A Shader/Filter subclass mixed with BaseShaderMixin features.
   */
  interface BaseShaderMixin<TBase extends PIXI.Shader> {
    new (program: string, uniforms: object): TBase;

    /** Common attributes for vertex shaders. */
    VERTEX_ATTRIBUTES: string;

    /** Common uniforms for vertex shaders. */
    VERTEX_UNIFORMS: string;

    /** Common varyings shared by vertex and fragment shaders. */
    VERTEX_FRAGMENT_VARYINGS: string;

    /** Common uniforms shared by fragment shaders. */
    FRAGMENT_UNIFORMS: string;

    /** Useful constant values computed at compile time */
    CONSTANTS: string;

    /**
     * Fast approximate perceived brightness computation
     * Using Digital ITU BT.709 : Exact luminance factors
     */
    PERCEIVED_BRIGHTNESS: string;

    /**
     * Fractional Brownian Motion for a given number of octaves
     * @param [octaves=4]
     * @param [amp=1.0]
     */
    FBM(octaves?: number, amp?: number): string;

    /**
     * High Quality Fractional Brownian Motion
     * @param [octaves=3]
     */
    FBMHQ(octaves?: number): string;

    /** A conventional pseudo-random number generator with the "golden" numbers, based on uv position */
    PRNG: string;

    /** A Vec3 pseudo-random generator, based on uv position */
    PRNG3D: string;

    /** A conventional noise generator */
    NOISE: string;

    /** Convert a Hue-Saturation-Brightness color to RGB - useful to convert polar coordinates to RGB */
    HSB2RGB: string;

    /**
     * Declare a wave function in a shader -> wcos (default), wsin or wtan.
     * Wave on the [v1,v2] range with amplitude -> a and speed -> speed.
     * @param [func="cos"] the math function to use
     */
    WAVE(func?: string): string;
  }

  /**
   * This class defines an interface which all shaders utilize
   * @property uniforms The current uniforms of the Shader
   */
  abstract class AbstractBaseShader extends BaseShaderMix {
    protected _defaults: object;

    constructor(program: string, uniforms: object);

    /**
     * The raw vertex shader used by this class.
     * A subclass of AbstractBaseShader must implement the vertexShader static field.
     */
    static vertexShader: string;

    /**
     * The raw fragment shader used by this class.
     * A subclass of AbstractBaseShader must implement the fragmentShader static field.
     */
    static fragmentShader: string;

    /**
     * The default uniform values for the shader.
     * A subclass of AbstractBaseShader must implement the defaultUniforms static field.
     */
    static defaultUniforms: object;

    /** A factory method for creating the shader using its defined default values */
    static create<T extends AbstractBaseShader>(this: ConstructorOf<T>, defaultUniforms: object): T;

    /**
     * Reset the shader uniforms back to their provided default values
     */
    reset(): void;
  }

  /**
   * An abstract filter which provides a framework for reusable definition
   */
  class AbstractBaseFilter extends BaseFilterMix {
    /** The default uniforms used by the filter */
    static defaultUniforms: object;

    /** The fragment shader which renders this filter. */
    static fragmentShader: string;

    /** The vertex shader which renders this filter. */
    static vertexShader: string;

    /**
     * A factory method for creating the filter using its defined default values.
     * @param [uniforms] Initial uniform values which override filter defaults
     * @returns The constructed AbstractFilter instance.
     */
    static create<T extends AbstractBaseFilter>(this: ConstructorOf<T>, uniforms?: object): T;

    /** Always target the resolution of the render texture or renderer */
    get resolution(): number;

    set resolution(value: number);

    /** Always target the MSAA level of the render texture or renderer */
    multisample: number;
  }
}

type BaseShaderMix<TBase extends PIXI.Shader> = BaseShaderMixin<TBase>;
declare const BaseShaderMix: BaseShaderMix<PIXI.Shader>;

type BaseFilterMix<TBase extends PIXI.Filter> = BaseShaderMixin<TBase>;
declare const BaseFilterMix: BaseFilterMix<PIXI.Filter>;

declare global {
  /** This class defines an interface for masked custom filters */
  class AbstractBaseMaskFilter extends AbstractBaseFilter {
    /** The default vertex shader used by all instances of AbstractBaseMaskFilter */
    static vertexShader: string;

    override apply(
      filterManager: PIXI.FilterSystem,
      input: PIXI.RenderTexture,
      output: PIXI.RenderTexture,
      clearMode?: PIXI.CLEAR_MODES,
      _currentState?: PIXI.FilterState,
    ): void;
  }

  /**
   * A filter which implements an outline.
   * Inspired from https://github.com/pixijs/filters/tree/main/filters/outline
   * @license MIT
   */
  class OutlineOverlayFilter extends AbstractBaseFilter {
    override padding: number;

    override autoFit: boolean;

    /** If the filter is animated or not. */
    animate: boolean;

    static override defaultUniforms: object;

    static vertexShader: string;

    static createFragmentShader(): string;

    /** The thickness of the outline. */
    get thickness(): number;

    set thickness(value: number);

    static create<T extends AbstractBaseFilter>(this: ConstructorOf<T>, uniforms?: object): T;

    override apply(
      filterManager: PIXI.FilterSystem,
      input: PIXI.RenderTexture,
      output: PIXI.RenderTexture,
      clearMode?: PIXI.CLEAR_MODES,
      _currentState?: PIXI.FilterState,
    ): void;
  }
}

declare global {
  /**
   * A simple shader to emulate a PIXI.Sprite with a PIXI.SpriteMesh
   * @todo Fill in
   */
  class BaseSamplerShader extends AbstractBaseShader {}

  /**
   * A color adjustment shader.
   * @todo Fill in
   */
  class ColorAdjustmentsSamplerShader extends BaseSamplerShader {}

  /**
   * A light amplification shader.
   * @todo Fill in
   */
  class AmplificationSamplerShader extends ColorAdjustmentsSamplerShader {}

  /**
   * A color adjustment shader.
   * @todo Fill in
   */
  class TokenInvisibilitySamplerShader extends BaseSamplerShader {}

  /**
   * A monochromatic shader.
   * @todo Fill in
   */
  class MonochromaticSamplerShader extends BaseSamplerShader {}

  /**
   * A shader used to control channels intensity using an externally provided mask texture.
   * @todo Fill in
   */
  class InverseOcclusionSamplerShader extends BaseSamplerShader {}

  /**
   * An occlusion shader to reveal certain area with elevation comparisons.
   * This shader is also working as a batched plugin.
   * @todo Fill in
   */
  class OcclusionSamplerShader extends BaseSamplerShader {}

  /**
   * This class defines an interface which all adaptive lighting shaders extend.
   * @todo Fill in
   */
  class AdaptiveLightingShader extends AbstractBaseShader {
    static SHADER_TECHNIQUES: Record<string, { label: string }>;
  }
}

declare global {
  module PIXI {
    export {
      AccessibilityManager,
      AlphaFilter,
      Application$1,
      ALPHA_MODES,
      BLEND_MODES,
      BlurFilter,
      CLEAR_MODES,
      Circle,
      Container,
      DisplayObject,
      Ellipse,
      EventBoundary,
      Extract,
      FederatedEvent,
      FederatedPointerEvent,
      FederatedWheelEvent,
      Filter,
      FilterState,
      FilterSystem,
      FORMATS,
      Geometry,
      Graphics,
      IDestroyOptions,
      ITextStyle,
      Graphics,
      Matrix,
      Mesh,
      MIPMAP_MODES,
      MSAA_QUALITY,
      ParticleContainer,
      ParticleRenderer,
      Point$1,
      Polygon,
      Prepare,
      Program,
      Rectangle$1,
      RenderTexture,
      Renderer,
      RoundedRectangle,
      SCALE_MODES,
      Shader,
      Sprite,
      Spritesheet,
      Text$1,
      TextStyle,
      Texture,
      TilingSpriteRenderer,
      Transform$1,
      UniformGroup,
      particles,
      smooth,
      utils,
    };
  }
}

declare global {
  /** TODO: Document Me */
  abstract class SpecialEffect {
    static OPTION_TYPES: {
      VALUE: 1;
      CHECKBOX: 2;
      RANGE: 3;
      SELECT: 4;
    };

    static get label(): string;
  }
}

declare global {
  /**
   * An abstract class which represents a single token that can be used as part of a Roll formula.
   * Every portion of a Roll formula is parsed into a subclass of RollTerm in order for the Roll to be fully evaluated.
   */
  abstract class RollTerm<TTermData extends RollTermData = RollTermData> {
    constructor(termData?: TTermData);

    /** An object of additional options which describes and modifies the term. */
    options: RollOptions;

    /** An internal flag for whether the term has been evaluated */
    _evaluated: boolean;

    /** Is this term intermediate, and should be evaluated first as part of the simplification process? */
    isIntermediate?: boolean;

    /** A regular expression pattern which identifies optional term-level flavor text */
    static FLAVOR_REGEXP_STRING?: string;

    /** A regular expression which identifies term-level flavor text */
    static FLAVOR_REGEXP: RegExp;

    /** A regular expression used to match a term of this type */
    static REGEXP: RegExp;

    /** An array of additional attributes which should be retained when the term is serialized */
    static SERIALIZE_ATTRIBUTES: string[];

    /* -------------------------------------------- */
    /*  RollTerm Attributes                         */
    /* -------------------------------------------- */

    /** A string representation of the formula expression for this RollTerm, prior to evaluation. */
    abstract get expression(): string;

    /** A string representation of the formula, including optional flavor text. */
    get formula(): string;

    /** A string or numeric representation of the final output for this term, after evaluation. */
    get total(): number | string | undefined;

    /** Optional flavor text which modifies and describes this term. */
    get flavor(): string;

    /** Whether this term is entirely deterministic or contains some randomness. */
    get isDeterministic(): boolean;

    /* -------------------------------------------- */
    /*  RollTerm Methods                            */
    /* -------------------------------------------- */

    /**
     * Evaluate the term, processing its inputs and finalizing its total.
     * @param [options={}]             Options which modify how the RollTerm is evaluated
     * @param [options.minimize=false] Minimize the result, obtaining the smallest possible value.
     * @param [options.maximize=false] Maximize the result, obtaining the largest possible value.
     * @param [options.async=false]    Evaluate the term asynchronously, receiving a Promise as the returned value.
     *                                 This will become the default behavior in version 10.x
     * @returns The evaluated RollTerm
     */
    evaluate({
      minimize,
      maximize,
      async,
    }?: {
      minimize?: boolean;
      maximize?: boolean;
      async?: false;
    }): Evaluated<this>;
    evaluate({
      minimize,
      maximize,
      async,
    }: {
      minimize?: boolean;
      maximize?: boolean;
      async: true;
    }): Promise<Evaluated<this>>;
    evaluate({
      minimize,
      maximize,
      async,
    }?: {
      minimize?: boolean;
      maximize?: boolean;
      async?: boolean;
    }): Evaluated<this> | Promise<Evaluated<this>>;

    /**
     * Evaluate the term.
     * @param [options={}] Options which modify how the RollTerm is evaluated, see RollTerm#evaluate
     */
    protected _evaluate({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): Promise<Evaluated<this>>;

    /**
     * This method is temporarily factored out in order to provide different behaviors synchronous evaluation.
     * This will be removed in 0.10.x
     */
    protected _evaluateSync({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): Evaluated<this>;

    /* -------------------------------------------- */
    /*  Serialization and Loading                   */
    /* -------------------------------------------- */

    /**
     * Construct a RollTerm from a provided data object
     * @param data Provided data from an un-serialized term
     * @return The constructed RollTerm
     */
    static fromData<TTerm extends RollTerm>(this: AbstractConstructorOf<TTerm>, data: TermDataOf<TTerm>): TTerm;

    /**
     * Define term-specific logic for how a de-serialized data object is restored as a functional RollTerm
     * @param data The de-serialized term data
     * @returns The re-constructed RollTerm object
     */
    protected static _fromData<D extends RollTermData, T extends RollTerm<D>>(this: ConstructorOf<T>, data: D): T;

    /**
     * Reconstruct a RollTerm instance from a provided JSON string
     * @param json A serialized JSON representation of a DiceTerm
     * @return A reconstructed RollTerm from the provided JSON
     */
    static fromJSON<D extends RollTermData, T extends RollTerm<D>>(this: ConstructorOf<T>, json: string): T;

    /**
     * Serialize the RollTerm to a JSON string which allows it to be saved in the database or embedded in text.
     * This method should return an object suitable for passing to the JSON.stringify function.
     */
    toJSON(): TTermData;
  }

  interface RollTermData {
    class?: string;
    options?: RollOptions;
    evaluated?: boolean;
  }

  type Evaluated<T extends RollTerm> = T & {
    _evaluated: true;
    total: NonNullable<T['total']>;
  };

  type TermDataOf<TTerm extends RollTerm> = TTerm extends RollTerm<infer TData> ? TData : never;
}

declare global {
  /**
   * An abstract base class for any type of RollTerm which involves randomized input from dice, coins, or other devices.
   * @param termData Data used to create the Dice Term, including the following:
   * @param [termData.number=1]  The number of dice of this term to roll, before modifiers are applied
   * @param termData.faces       The number of faces on each die of this type
   * @param [termData.modifiers] An array of modifiers applied to the results
   * @param [termData.results]   An optional array of pre-cast results for the term
   * @param [termData.options]   Additional options that modify the term
   */
  abstract class DiceTerm<TData extends DiceTermData = DiceTermData> extends RollTerm<TData> {
    constructor({ number, faces, modifiers, results, options }?: TData);

    /** The number of dice of this term to roll, before modifiers are applied */
    number: number;

    /** The number of faces on the die */
    faces: TData['faces'];

    /** An Array of dice term modifiers which are applied */
    modifiers: string[];

    /** The array of dice term results which have been rolled */
    results: DiceTermResult[];

    /** Define the denomination string used to register this DiceTerm type in CONFIG.Dice.terms */
    static DENOMINATION: string;

    /** Define the named modifiers that can be applied for this particular DiceTerm type. */
    static MODIFIERS: Record<string, string | ((term: DiceTermResult) => void)>;

    /**
     * A regular expression pattern which captures the full set of term modifiers
     * Anything until a space, group symbol, or arithmetic operator
     */
    static MODIFIERS_REGEXP_STRING: string;

    /**
     * A regular expression used to separate individual modifiers
     */
    static MODIFIER_REGEXP: RegExp;

    static override REGEXP: RegExp;

    /** System note: contents are ["number", "faces", "modifiers", "results"] */
    static override SERIALIZE_ATTRIBUTES: string[];

    /* -------------------------------------------- */
    /*  Dice Term Attributes                        */
    /* -------------------------------------------- */

    override get expression(): string;

    override get total(): number | undefined;

    /** Return an array of rolled values which are still active within this term */
    get values(): number;

    /* -------------------------------------------- */
    /*  Dice Term Methods                           */
    /* -------------------------------------------- */

    /**
     * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
     * @param multiply A factor to multiply. Dice are multiplied before any additions.
     * @param add      A number of dice to add. Dice are added after multiplication.
     * @return The altered term
     */
    alter(multiply: number, add: number): this;

    protected override _evaluateSync({
      minimize,
      maximize,
    }?: {
      minimize?: boolean;
      maximize?: boolean;
    }): Evaluated<this>;

    /**
     * Roll the DiceTerm by mapping a random uniform draw against the faces of the dice term.
     * @param [options={}] Options which modify how a random result is produced
     * @param [options.minimize=false] Minimize the result, obtaining the smallest possible value.
     * @param [options.maximize=false] Maximize the result, obtaining the largest possible value.
     * @return The produced result
     */
    roll({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): DiceTermResult;

    /**
     * Return a string used as the label for each rolled result
     * @param result The rolled result
     * @return The result label
     */
    getResultLabel(result: DiceTermResult): string;

    /**
     * Get the CSS classes that should be used to display each rolled result
     * @param result The rolled result
     * @return The desired classes
     */
    getResultCSS(result: DiceTermResult): (string | null)[];

    /**
     * Render the tooltip HTML for a Roll instance
     * @return The data object used to render the default tooltip template for this DiceTerm
     */
    getTooltipData(): DiceTermTooltipData;

    /* -------------------------------------------- */
    /*  Modifier Methods                            */
    /* -------------------------------------------- */

    /**
     * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
     * Augment or modify the results array.
     */
    protected _evaluateModifiers(): void;

    /**
     * Evaluate a single modifier command, recording it in the array of evaluated modifiers
     * @param command  The parsed modifier command
     * @param modifier The full modifier request
     */
    protected _evaluateModifier(command: string, modifier: string): void;

    /**
     * A helper comparison function.
     * Returns a boolean depending on whether the result compares favorably against the target.
     * @param result     The result being compared
     * @param comparison The comparison operator in [=,<,<=,>,>=]
     * @param target     The target value
     * @return Is the comparison true?
     */
    static compareResult(result: number, comparison: ComparisonOperator, target?: number): boolean;

    /**
     * A helper method to modify the results array of a dice term by flagging certain results are kept or dropped.
     * @param results   The results array
     * @param number    The number to keep or drop
     * @param [keep]    Keep results?
     * @param [highest] Keep the highest?
     * @return The modified results array
     */
    protected static _keepOrDrop<T extends DiceTermResult>(
      results: T[],
      number: number,
      { keep, highest }?: { keep?: boolean; highest?: boolean },
    ): T[];

    /**
     * A reusable helper function to handle the identification and deduction of failures
     */
    protected static _applyCount<T extends DiceTermResult>(
      results: T,
      comparison: ComparisonOperator,
      target: number,
      { flagSuccess, flagFailure }?: { flagSuccess?: boolean; flagFailure?: boolean },
    ): void;

    /** A reusable helper function to handle the identification and deduction of failures */
    protected static _applyDeduct<T extends DiceTermResult>(
      results: T[],
      comparison: ComparisonOperator,
      target: number,
      { deductFailure, invertFailure }?: { deductFailure?: boolean; invertFailure?: boolean },
    ): void;

    /* -------------------------------------------- */
    /*  Factory Methods                             */
    /* -------------------------------------------- */

    /**
     * Determine whether a string expression matches this type of term
     * @param expression The expression to parse
     * @param [options={}] Additional options which customize the match
     * @param [options.imputeNumber=true] Allow the number of dice to be optional, i.e. "d6"
     */
    static matchTerm(expression: string, { imputeNumber }?: { imputeNumber: boolean }): RegExpMatchArray | null;

    /**
     * Construct a term of this type given a matched regular expression array.
     * @param match The matched regular expression array
     * @return The constructed term
     */
    static fromMatch<T extends DiceTerm>(this: ConstructorOf<T>, match: RegExpMatchArray): T;
  }

  /**
   * @typedef DiceTermResult
   * @property result      The numeric result
   * @property [active]    Is this result active, contributing to the total?
   * @property [count]     A value that the result counts as, otherwise the result is not used directly as
   * @property [success]   Does this result denote a success?
   * @property [failure]   Does this result denote a failure?
   * @property [discarded] Was this result discarded?
   * @property [rerolled]  Was this result rerolled?
   * @property [exploded]  Was this result exploded?
   */
  interface DiceTermResult {
    result: number;
    active?: boolean;
    count?: number;
    success?: boolean;
    failure?: boolean;
    discarded?: boolean;
    rerolled?: boolean;
    exploded?: boolean;
  }

  interface DiceTermData extends RollTermData {
    number?: number;
    faces?: number;
    modifiers?: string[];
    results?: DiceTermResult[];
  }

  type ComparisonOperator = '=' | '<' | '<=' | '>' | '>=';

  interface DiceTermTooltipData {
    formula: string;
    total: number;
    faces: number;
    flavor: string;
    rolls: {
      result: string;
      classes: string;
    };
  }
}

declare global {
  /** Define a two-sided coin term that can be used as part of a Roll formula */
  class Coin extends DiceTerm<CoinData> {
    constructor(termData: CoinData);

    static override DENOMINATION: 'c';

    static override MODIFIERS: {
      c: 'call';
    };

    override roll({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): DiceTermResult;

    override getResultLabel(result: object): string;

    override getResultCSS(result: object): string[];

    /* -------------------------------------------- */
    /*  Term Modifiers                              */
    /* -------------------------------------------- */

    /**
     * Call the result of the coin flip, marking any coins that matched the called target as a success
     * 3dcc1      Flip 3 coins and treat "heads" as successes
     * 2dcc0      Flip 2 coins and treat "tails" as successes
     * @param modifier The matched modifier query
     */
    call(modifier: string): void;
  }

  interface CoinData extends DiceTermData {
    faces: 2;
  }
}

declare global {
  /**
   * Define a fair n-sided die term that can be used as part of a Roll formula
   *
   * @example
   * // Roll 4 six-sided dice
   * let die = new Die({faces: 6, number: 4}).evaluate();
   */
  class Die<TData extends DieData = DieData> extends DiceTerm<TData> {
    constructor(termData?: Partial<DieData>);

    static override DENOMINATION: string;

    static override MODIFIERS: {
      r: 'reroll';
      rr: 'rerollRecursive';
      x: 'explode';
      xo: 'explodeOnce';
      k: 'keep';
      kh: 'keep';
      kl: 'keep';
      d: 'drop';
      dh: 'drop';
      dl: 'drop';
      min: 'minimum';
      max: 'maximum';
      even: 'countEven';
      odd: 'countOdd';
      cs: 'countSuccess';
      cf: 'countFailures';
      df: 'deductFailures';
      sf: 'subtractFailures';
      ms: 'marginSuccess';
    };

    /**
     * Re-roll the Die, rolling additional results for any values which fall within a target set.
     * If no target number is specified, re-roll the lowest possible result.
     *
     * 20d20r         reroll all 1s
     * 20d20r1        reroll all 1s
     * 20d20r=1       reroll all 1s
     * 20d20r1=1      reroll a single 1
     *
     * @param modifier  The matched modifier query
     * @param recursive Reroll recursively, continuing to reroll until the condition is no longer met
     * @returns False if the modifier was unmatched
     */
    reroll(modifier: string, { recursive }?: { recursive?: boolean }): boolean | void;

    /**
     * @see {@link Die#reroll}
     */
    rerollRecursive(modifier: string): boolean | void;

    /**
     * Explode the Die, rolling additional results for any values which match the target set.
     * If no target number is specified, explode the highest possible result.
     * Explosion can be a "small explode" using a lower-case x or a "big explode" using an upper-case "X"
     *
     * @param modifier The matched modifier query
     * @param recursive Explode recursively, such that new rolls can also explode?
     */
    explode(modifier: string, { recursive }?: { recursive?: boolean }): void;

    /**
     * @see {@link Die#explode}
     */
    explodeOnce(modifier: string): void;

    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * 20d20k       Keep the 1 highest die
     * 20d20kh      Keep the 1 highest die
     * 20d20kh10    Keep the 10 highest die
     * 20d20kl      Keep the 1 lowest die
     * 20d20kl10    Keep the 10 lowest die
     *
     * @param  modifier     The matched modifier query
     */
    keep(modifier: string): void;

    /**
     * Drop a certain number of highest or lowest dice rolls from the result set.
     *
     * 20d20d       Drop the 1 lowest die
     * 20d20dh      Drop the 1 highest die
     * 20d20dl      Drop the 1 lowest die
     * 20d20dh10    Drop the 10 highest die
     * 20d20dl10    Drop the 10 lowest die
     *
     * @param modifier The matched modifier query
     */
    drop(modifier: string): void;

    /**
     * Count the number of successful results which occurred in a given result set.
     * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
     * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
     *
     * 20d20cs      Count the number of dice which rolled a 20
     * 20d20cs>10   Count the number of dice which rolled higher than 10
     * 20d20cs<10   Count the number of dice which rolled less than 10
     *
     * @param modifier The matched modifier query
     */
    countSuccess(modifier: string): void;

    /**
     * Count the number of failed results which occurred in a given result set.
     * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
     *
     * 6d6cf      Count the number of dice which rolled a 1 as failures
     * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
     * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
     *
     * @param modifier The matched modifier query
     */
    countFailures(modifier: string): void;

    /**
     * Count the number of even results which occurred in a given result set.
     * Even numbers are marked as a success and counted as 1
     * Odd numbers are marked as a non-success and counted as 0.
     *
     * 6d6even    Count the number of even numbers rolled
     *
     * @param modifier The matched modifier query
     */
    countEven(modifier: string): void;

    /**
     * Count the number of odd results which occurred in a given result set.
     * Odd numbers are marked as a success and counted as 1
     * Even numbers are marked as a non-success and counted as 0.
     *
     * 6d6odd    Count the number of odd numbers rolled
     *
     * @param modifier The matched modifier query
     */
    countOdd(modifier: string): void;

    /**
     * Deduct the number of failures from the dice result, counting each failure as -1
     * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a deduct-failures modifier to the results counts all failed results as -1.
     *
     * 6d6df      Subtract the number of dice which rolled a 1 from the non-failed total.
     * 6d6cs>3df  Subtract the number of dice which rolled a 3 or less from the non-failed count.
     * 6d6cf<3df  Subtract the number of dice which rolled less than 3 from the non-failed count.
     *
     * @param modifier The matched modifier query
     */
    deductFailures(modifier: string): void;

    /**
     * Subtract the value of failed dice from the non-failed total, where each failure counts as its negative value.
     * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a deduct-failures modifier to the results counts all failed results as -1.
     *
     * 6d6df<3    Subtract the value of results which rolled less than 3 from the non-failed total.
     *
     * @param modifier The matched modifier query
     */
    subtractFailures(modifier: string): void;

    /**
     * Subtract the total value of the DiceTerm from a target value, treating the difference as the final total.
     * Example: 6d6ms>12    Roll 6d6 and subtract 12 from the resulting total.
     * @param  modifier The matched modifier query
     */
    marginSuccess(modifier: string): void;

    /**
     * Constrain each rolled result to be at least some minimum value.
     * Example: 6d6min2    Roll 6d6, each result must be at least 2
     * @param modifier The matched modifier query
     */
    minimum(modifier: string): void;

    /**
     * Constrain each rolled result to be at most some maximum value.
     * Example: 6d6max5    Roll 6d6, each result must be at most 5
     * @param modifier The matched modifier query
     */
    maximum(modifier: string): void;
  }

  interface DieData extends DiceTermData {
    number: number;
    faces: number;
    marginSuccess?: boolean;
    marginFailure?: boolean;
  }
}

declare global {
  /**
   * Define a three-sided Fate/Fudge dice term that can be used as part of a Roll formula
   * Mathematically behaves like 1d3-2
   */
  class FateDie extends DiceTerm {
    constructor(termData: DiceTermData);

    static override DENOMINATION: 'f';

    override roll({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): DiceTermResult;

    override getResultLabel<T extends DiceTermResult>(
      result: DiceTermResult,
    ): T['result'] extends -1 ? '-' : T extends 0 ? '&nbsp;' : T extends 1 ? '+' : never;
  }

  interface FateDie extends DiceTerm {
    faces: 3;
  }
}

declare global {
  class MathTerm<TFunctionName extends MathFunctionName = MathFunctionName> extends RollTerm<
    MathTermData<TFunctionName>
  > {
    constructor({ fn, terms, options }: MathTermData<TFunctionName>);

    /** The named function in the Math environment which should be applied to the term */
    fn: TFunctionName;

    /** An array of string argument terms for the function */
    terms: string[];

    /** The cached Roll instances for each function argument */
    rolls: Roll[];

    /** The cached result of evaluating the method arguments */
    result: number | undefined;

    override isIntermediate: true;

    static override SERIALIZE_ATTRIBUTES: ['fn', 'terms'];

    /* -------------------------------------------- */
    /*  Math Term Attributes                        */
    /* -------------------------------------------- */

    /** An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll */
    get dice(): DiceTerm[];

    override get total(): number | undefined;

    override get expression(): `${MathFunctionName}(${string})`;

    /* -------------------------------------------- */
    /*  Math Term Methods                           */
    /* -------------------------------------------- */

    protected override _evaluateSync({
      minimize,
      maximize,
    }?: {
      minimize?: boolean;
      maximize?: boolean;
    }): Evaluated<this>;

    protected override _evaluate({
      minimize,
      maximize,
    }?: {
      minimize?: boolean;
      maximize?: boolean;
    }): Promise<Evaluated<this>>;
  }

  type MathFunctionName =
    | Exclude<MathStringKey, 'E' | 'LN2' | 'LN10' | 'LOG2E' | 'LOG10E' | 'PI' | 'SQRT1_2' | 'SQRT2'>
    | 'clamped'
    | 'normalizeDegrees'
    | 'normalizeRadians'
    | 'roundDecimals'
    | 'toDegrees'
    | 'toRadians'
    | 'safeEval';

  interface MathTermData<TFunctionName extends MathFunctionName = MathFunctionName> extends RollTermData {
    class?: 'MathTerm';
    fn?: TFunctionName;
    terms?: RollTerm[];
  }
}

type MathStringKey<T extends keyof Math = keyof Math> = T extends string ? T : never;

declare global {
  /** A type of RollTerm used to capture static numbers. */
  class NumericTerm<TData extends NumericTermData = NumericTermData> extends RollTerm<TData> {
    constructor({ number, options }: NumericTermData);

    number: number;

    static override REGEXP: RegExp;

    static override SERIALIZE_ATTRIBUTES: ['number'];

    override get expression(): string;

    override get total(): number;

    /* -------------------------------------------- */
    /*  Factory Methods                             */
    /* -------------------------------------------- */

    /**
     * Determine whether a string expression matches a NumericTerm
     * @param expression The expression to parse
     */
    static matchTerm(expression: string): RegExpMatchArray | null;

    /**
     * Construct a term of this type given a matched regular expression array.
     * @param match The matched regular expression array
     * @return The constructed term
     */
    static fromMatch<T extends NumericTerm<NumericTermData>>(this: T, match: RegExpMatchArray): T;
  }

  interface NumericTermData extends RollTermData {
    class?: 'NumericTerm';
    number: number;
  }
}

declare global {
  /** A type of RollTerm used to denote and perform an arithmetic operation. */
  class OperatorTerm extends RollTerm<OperatorTermData> {
    constructor({ operator, options }: OperatorTermData);

    operator: ArithmeticOperator;

    /** An array of operators which represent arithmetic operations */
    static OPERATORS: ['+', '-', '*', '/'];

    static override REGEXP: RegExp;

    static SERIALIZE_ATTRIBUTES: ['operator'];

    override get flavor(): ''; // Operator terms cannot have flavor text

    override get expression(): ` ${ArithmeticOperator} `;

    override get total(): ` ${ArithmeticOperator} `;
  }

  type ArithmeticOperator = (typeof OperatorTerm)['OPERATORS'][number];

  interface OperatorTermData extends RollTermData {
    operator: ArithmeticOperator;
  }
}

declare global {
  /** A type of RollTerm used to enclose a parenthetical expression to be recursively evaluated. */
  class ParentheticalTerm extends RollTerm<ParentheticalTermData> {
    constructor({ term, roll, options }: { term: string; roll?: Roll; options?: Record<string, unknown> });
    constructor({ term, roll, options }: { term?: string; roll: Roll; options?: Record<string, unknown> });

    /** The original provided string term used to construct the parenthetical */
    term: string;

    /** Alternatively, an already-evaluated Roll instance may be passed directly */
    roll?: Roll;

    /** @override */
    isIntermediate: true;

    /**
     * The regular expression pattern used to identify the opening of a parenthetical expression.
     * This could also identify the opening of a math function.
     */
    static OPEN_REGEXP: RegExp;

    /** A regular expression pattern used to identify the closing of a parenthetical expression. */
    static CLOSE_REGEXP: RegExp;

    /** @override */
    static SERIALIZE_ATTRIBUTES: ['term'];

    /* -------------------------------------------- */
    /*  Parenthetical Term Attributes               */
    /* -------------------------------------------- */

    /** An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll */
    get dice(): Evaluated<DiceTerm>[];

    /** @override */
    get total(): string | number | undefined;

    /** @inheritdoc */
    get expression(): `(${string})`;

    /* -------------------------------------------- */
    /*  Parenthetical Term Methods                  */
    /* -------------------------------------------- */

    /** @override */
    protected _evaluateSync({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): Evaluated<this>;

    /** @override */
    protected _evaluate({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): Promise<Evaluated<this>>;

    /**
     * Construct a ParentheticalTerm from an Array of component terms which should be wrapped inside the parentheses.
     * @param terms The array of terms to use as internal parts of the parenthetical
     * @param [options={}]   Additional options passed to the ParentheticalTerm constructor
     * @returns The constructed ParentheticalTerm instance
     *
     * @example <caption>Create a Parenthetical Term from an array of component RollTerm instances</caption>
     * const d6 = new Die({number: 4, faces: 6});
     * const plus = new OperatorTerm({operator: "+"});
     * const bonus = new NumericTerm({number: 4});
     * t = ParentheticalTerm.fromTerms([d6, plus, bonus]);
     * t.formula; // (4d6 + 4)
     */
    static fromTerms(terms: RollTerm[], options?: Record<string, unknown>): ParentheticalTerm;
  }

  interface ParentheticalTermData extends RollTermData {
    term?: string;
  }
}

declare global {
  /**
   * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total
   * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any
   * success count or margin.
   *
   * @example
   * // Keep the highest of the 3 roll expressions
   * let pool = new PoolTerm({
   *   rolls: ["4d6", "3d8 - 1", "2d10 + 3"],
   *   modifiers: ["kh"]
   * });
   * pool.evaluate();
   */
  class PoolTerm<TData extends PoolTermData = PoolTermData> extends RollTerm<TData> {
    constructor({
      terms,
      modifiers,
      rolls,
      results,
      options,
    }?: Omit<TData, 'rolls'> & { rolls: TData['rolls'] | Roll[] });

    /** The original provided terms to the Dice Pool */
    terms: RollTerm[];

    /** The string modifiers applied to resolve the pool */
    modifiers: string[];

    /** Each component term of a dice pool is evaluated as a Roll instance */
    rolls: Roll[];

    /** The array of dice pool results which have been rolled */
    results: DiceTermResult[];

    /** Define the modifiers that can be used for this particular DiceTerm type. */
    static MODIFIERS: {
      k: 'keep';
      kh: 'keep';
      kl: 'keep';
      d: 'drop';
      dh: 'drop';
      dl: 'drop';
      cs: 'countSuccess';
      cf: 'countFailures';
    };

    /** The regular expression pattern used to identify the opening of a dice pool expression. */
    static OPEN_REGEXP: RegExp;

    /** A regular expression pattern used to identify the closing of a dice pool expression. */
    static CLOSE_REGEXP: RegExp;

    static override SERIALIZE_ATTRIBUTES: ['terms', 'modifiers', 'rolls', 'results'];

    /* -------------------------------------------- */
    /*  Dice Pool Attributes                        */
    /* -------------------------------------------- */

    /** Return an Array of each individual DiceTerm instances contained within the PoolTerm. */
    get dice(): DiceTerm[];

    override get expression(): string;

    override get total(): number | undefined;

    /** Return an array of rolled values which are still active within the PoolTerm */
    get values(): number[];

    /* -------------------------------------------- */

    /**
     * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
     * @param args Arguments passed to each contained Roll#alter method.
     * @return The altered pool
     */
    alter(...args: unknown[]): this[];

    protected override _evaluateSync({ minimize, maximize }?: Omit<EvaluateRollParams, 'async'>): Evaluated<this>;

    protected override _evaluate({ minimize, maximize }?: Omit<EvaluateRollParams, 'async'>): Promise<Evaluated<this>>;

    /**
     * Use the same logic as for the DiceTerm to avoid duplication
     * @see DiceTerm#_evaluateModifiers
     */
    _evaluateModifiers(): void;

    /**
     * Use the same logic as for the DiceTerm to avoid duplication
     * @see DiceTerm#_evaluateModifier
     */
    _evaluateModifier(command: string, modifier: string): void;

    /* -------------------------------------------- */
    /*  Saving and Loading                          */
    /* -------------------------------------------- */

    protected static override _fromData<D extends RollTermData, T extends RollTerm<D>>(
      this: ConstructorOf<T>,
      data: D,
    ): T;

    /**
     * Given a string formula, create and return an evaluated PoolTerm object
     * @param formula   The string formula to parse
     * @param [options] Additional options applied to the PoolTerm
     * @return The evaluated PoolTerm object or null if the formula is invalid
     */
    static fromExpression<D extends PoolTermData, T extends PoolTerm<D>>(
      this: ConstructorOf<T>,
      formula: string,
      options?: Record<string, unknown>,
    ): T | null;

    /**
     * Create a PoolTerm by providing an array of existing Roll objects
     * @param rolls An array of Roll objects from which to create the pool
     * @returns The constructed PoolTerm comprised of the provided rolls
     */
    static fromRolls<TTerm extends PoolTerm>(this: ConstructorOf<TTerm>, rolls?: Roll[]): TTerm;

    /* -------------------------------------------- */
    /*  Modifiers                                   */
    /* -------------------------------------------- */

    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * {1d6,1d8,1d10,1d12}kh2       Keep the 2 best rolls from the pool
     * {1d12,6}kl                   Keep the lowest result in the pool
     *
     * @param modifier The matched modifier query
     */
    keep(modifier: string): void;

    /**
     * Keep a certain number of highest or lowest dice rolls from the result set.
     *
     * {1d6,1d8,1d10,1d12}dl3       Drop the 3 worst results in the pool
     * {1d12,6}dh                   Drop the highest result in the pool
     *
     * @param modifier The matched modifier query
     */
    drop(modifier: string): void;

    /**
     * Count the number of successful results which occurred in the pool.
     * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
     * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
     *
     * 20d20cs      Count the number of dice which rolled a 20
     * 20d20cs>10   Count the number of dice which rolled higher than 10
     * 20d20cs<10   Count the number of dice which rolled less than 10
     *
     * @param modifier The matched modifier query
     */
    countSuccess(modifier: string): void;

    /**
     * Count the number of failed results which occurred in a given result set.
     * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
     * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
     *
     * 6d6cf      Count the number of dice which rolled a 1 as failures
     * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
     * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
     *
     * @param modifier The matched modifier query
     */
    countFailures(modifier: string): void;
  }

  interface PoolTermData extends RollTermData {
    terms?: string[];
    modifiers?: string[];
    rolls?: RollJSON[];
    results?: DiceTermResult[];
  }
}

declare global {
  /** A type of RollTerm used to capture residual strings which have not yet been matched */
  class StringTerm extends RollTerm<StringTermData> {
    constructor({ term, options }: StringTermData);

    term: string;

    static override SERIALIZE_ATTRIBUTES: ['term'];

    override get expression(): string;

    override get total(): string;

    override evaluate(options?: Record<string, unknown>): never;
  }

  interface StringTermData extends RollTermData {
    term?: string;
  }
}

declare global {
  /**
   * An interface and API for constructing and evaluating dice rolls.
   * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
   *
   * @param formula The string formula to parse
   * @param data    The data object against which to parse attributes within the formula
   *
   * @example
   * // Attack with advantage!
   * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
   *
   * // The parsed terms of the roll formula
   * console.log(r.terms);    // [Die, OperatorTerm, NumericTerm, OperatorTerm, NumericTerm]
   *
   * // Execute the roll
   * r.evaluate();
   *
   * // The resulting equation after it was rolled
   * console.log(r.result);   // 16 + 2 + 4
   *
   * // The total resulting from the roll
   * console.log(r.total);    // 22
   */
  class Roll {
    constructor(formula: string, data?: Record<string, unknown>, options?: RollOptions);

    /** The original provided data object which substitutes into attributes of the roll formula */
    data: Record<string, unknown>;

    /** Options which modify or describe the Roll */
    options: RollOptions;

    /** The identified terms of the Roll */
    terms: RollTerm[];

    /** An array of inner DiceTerms which were evaluated as part of the Roll evaluation */
    protected _dice: DiceTerm[];

    /** Store the original cleaned formula for the Roll, prior to any internal evaluation or simplification */
    _formula: string;

    /** Track whether this Roll instance has been evaluated or not. Once evaluated the Roll is immutable. */
    _evaluated: boolean;

    /** Cache the numeric total generated through evaluation of the Roll. */
    protected _total: number | undefined;

    /** A Proxy environment for safely evaluating a string using only available Math functions */
    static MATH_PROXY: RollMathProxy;

    /** The HTML template path used to render a complete Roll object to the chat log */
    static CHAT_TEMPLATE: string;

    /** The HTML template used to render an expanded Roll tooltip to the chat log */
    static TOOLTIP_TEMPLATE: string;

    /**
     * Prepare the data structure used for the Roll.
     * This is factored out to allow for custom Roll classes to do special data preparation using provided input.
     * @param data Provided roll data
     * @returns The prepared data object
     */
    protected _prepareData(data: Record<string, unknown>): Record<string, unknown>;

    /* -------------------------------------------- */
    /*  Roll Attributes                             */
    /* -------------------------------------------- */

    /** Return an Array of the individual DiceTerm instances contained within this Roll. */
    get dice(): DiceTerm[];

    /** Return a standardized representation for the displayed formula associated with this Roll. */
    get formula(): string;

    /** The resulting arithmetic expression after rolls have been evaluated */
    get result(): string;

    /** Return the total result of the Roll expression if it has been evaluated. */
    get total(): number | undefined;

    /** Whether this Roll contains entirely deterministic terms or whether there is some randomness. */
    get isDeterministic(): boolean;

    /* -------------------------------------------- */
    /*  Roll Instance Methods                       */
    /* -------------------------------------------- */

    /**
     * Alter the Roll expression by adding or multiplying the number of dice which are rolled
     * @param multiply A factor to multiply. Dice are multiplied before any additions.
     * @param add      A number of dice to add. Dice are added after multiplication.
     * @param [multiplyNumeric]  Apply multiplication factor to numeric scalar terms
     * @return The altered Roll expression
     */
    alter(multiply: number, add: number, { multiplyNumeric }?: { multiplyNumeric?: boolean }): this;

    /** Clone the Roll instance, returning a new Roll instance that has not yet been evaluated. */
    clone(): this;

    /**
     * Execute the Roll, replacing dice and evaluating the total result
     * @param [options={}] Options which inform how the Roll is evaluated
     * @param [options.minimize=false] Minimize the result, obtaining the smallest possible value.
     * @param [options.maximize=false] Maximize the result, obtaining the largest possible value.
     * @param [options.async=true]     Evaluate the roll asynchronously, receiving a Promise as the returned value.
     *                                 This will become the default behavior in version 10.x
     * @returns The evaluated Roll instance
     *
     * @example
     * let r = new Roll("2d6 + 4 + 1d4");
     * r.evaluate();
     * console.log(r.result); // 5 + 4 + 2
     * console.log(r.total);  // 11
     */
    evaluate({ minimize, maximize, async }: EvaluateRollParams & { async?: false }): Rolled<this>;
    evaluate({ minimize, maximize, async }: EvaluateRollParams & { async: true }): Promise<Rolled<this>>;
    evaluate({ minimize, maximize, async }: EvaluateRollParams): Rolled<this> | Promise<Rolled<this>>;

    /**
     * Evaluate the roll asynchronously.
     * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
     */
    protected _evaluate({ minimize, maximize }?: Omit<EvaluateRollParams, 'async'>): Promise<Rolled<this>>;

    /**
     * Evaluate the roll synchronously.
     * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
     */
    protected _evaluateSync({ minimize, maximize }?: Omit<EvaluateRollParams, 'async'>): Rolled<this>;

    /**
     * Safely evaluate the final total result for the Roll using its component terms.
     * @returns The evaluated total
     */
    protected _evaluateTotal(): number;

    /**
     * Alias for evaluate.
     * @see {Roll#evaluate}
     */
    roll({ minimize, maximize, async }: EvaluateRollParams & { async?: false }): Rolled<this>;
    roll({ minimize, maximize, async }: EvaluateRollParams & { async: true }): Promise<Rolled<this>>;
    roll({ minimize, maximize, async }: EvaluateRollParams): Rolled<this> | Promise<Rolled<this>>;

    /**
     * Create a new Roll object using the original provided formula and data.
     * Each roll is immutable, so this method returns a new Roll instance using the same data.
     * @param [options={}] Evaluation options passed to Roll#evaluate
     * @return A new Roll object, rolled using the same formula and data
     */
    reroll({ minimize, maximize, async }: EvaluateRollParams & { async?: false }): Rolled<this>;
    reroll({ minimize, maximize, async }: EvaluateRollParams & { async: true }): Promise<Rolled<this>>;
    reroll({ minimize, maximize, async }: EvaluateRollParams): Rolled<this> | Promise<Rolled<this>>;

    /* -------------------------------------------- */
    /*  Static Class Methods                        */
    /* -------------------------------------------- */

    /**
     * A factory method which constructs a Roll instance using the default configured Roll class.
     * @param formula      The formula used to create the Roll instance
     * @param [data={}]    The data object which provides component data for the formula
     * @param [options={}] Additional options which modify or describe this Roll
     * @return The constructed Roll instance
     */
    static create(formula: string, data?: Record<string, unknown>, options?: RollOptions): Roll;

    /** Get the default configured Roll class. */
    static get defaultImplementation(): typeof Roll;

    /**
     * Transform an array of RollTerm objects into a cleaned string formula representation.
     * @param terms An array of terms to represent as a formula
     * @returns The string representation of the formula
     */
    static getFormula(terms: RollTerm[]): string;

    /**
     * A sandbox-safe evaluation function to execute user-input code with access to scoped Math methods.
     * @param expression The input string expression
     * @returns The numeric evaluated result
     */
    static safeEval(expression: string): number;

    /**
     * After parenthetical and arithmetic terms have been resolved, we need to simplify the remaining expression.
     * Any remaining string terms need to be combined with adjacent non-operators in order to construct parsable terms.
     * @param terms An array of terms which is eligible for simplification
     * @returns An array of simplified terms
     */
    static simplifyTerms(terms: RollTerm[]): RollTerm[];
    /**
     * Simulate a roll and evaluate the distribution of returned results
     * @param formula The Roll expression to simulate
     * @param n The number of simulations
     * @return The rolled totals
     */
    static simulate(formula: string, n?: number): number[];

    /* -------------------------------------------- */
    /*  Roll Formula Parsing                        */
    /* -------------------------------------------- */

    /**
     * Parse a formula by following an order of operations:
     *
     * Step 1: Replace formula data
     * Step 2: Split outer-most parenthetical groups
     * Step 3: Further split outer-most dice pool groups
     * Step 4: Further split string terms on arithmetic operators
     * Step 5: Classify all remaining strings
     *
     * @param formula The original string expression to parse
     * @param data    A data object used to substitute for attributes in the formula
     * @returns A parsed array of RollTerm instances
     */
    static parse(formula: string, data: object): RollTerm[];

    /**
     * Replace referenced data attributes in the roll formula with values from the provided data.
     * Data references in the formula use the @attr syntax and would reference the corresponding attr key.
     *
     * @param formula   The original formula within which to replace
     * @param data      The data object which provides replacements
     * @param [missing] The value that should be assigned to any unmatched keys. If null, the unmatched key is
     *                  left as-is.
     * @param [warn] Display a warning notification when encountering an un-matched key.
     */
    static replaceFormulaData(
      formula: string,
      data: Record<string, unknown>,
      { missing, warn }?: { missing?: string; warn?: boolean },
    ): string;

    /**
     * Validate that a provided roll formula can represent a valid
     * @param formula A candidate formula to validate
     * @return Is the provided input a valid dice formula?
     */
    static validate(formula: string): boolean;

    /**
     * Split a formula by identifying its outer-most parenthetical and math terms
     * @param _formula      The raw formula to split
     * @returns An array of terms, split on parenthetical terms
     */
    protected static _splitParentheses(_formula: string): string[];

    /** Handle closing of a parenthetical term to create a MathTerm expression with a function and arguments */
    protected static _splitMathArgs(expression: string): MathTerm[];

    /**
     * Split a formula by identifying its outer-most dice pool terms
     * @param _formula The raw formula to split
     * @returns An array of terms, split on parenthetical terms
     */
    protected static _splitPools(_formula: string): PoolTerm[];

    /**
     * Split a formula by identifying its outer-most groups using a certain group symbol like parentheses or brackets.
     * @param _formula The raw formula to split
     * @param options  Options that configure how groups are split
     * @returns An array of terms, split on dice pool terms
     */
    protected static _splitGroup(
      _formula?: string,
      {
        openRegexp,
        closeRegexp,
        openSymbol,
        closeSymbol,
        onClose,
      }?: {
        openRegexp?: RegExp;
        closeRegexp?: RegExp;
        openSymbol?: string;
        closeSymbol?: string;
        onClose?: () => void | Promise<void>;
      },
    ): string[];

    /**
     * Split a formula by identifying arithmetic terms
     * @param _formula The raw formula to split
     * @returns An array of terms, split on arithmetic operators
     */
    protected static _splitOperators(_formula: string): (string | OperatorTerm)[];

    /**
     * Temporarily remove flavor text from a string formula allowing it to be accurately parsed.
     * @param formula The formula to extract
     * @returns The cleaned formula and extracted flavor mapping
     */
    protected static _extractFlavors(formula?: string): {
      formula: string;
      flavors: Record<string, string>;
    };

    /**
     * Restore flavor text to a string term
     * @param term    The string term possibly containing flavor symbols
     * @param flavors The extracted flavors object
     * @returns The restored term containing flavor text
     */
    protected static _restoreFlavor(term: string, flavors: Record<string, string>): RollTerm;

    /**
     * Classify a remaining string term into a recognized RollTerm class
     * @param term                         A remaining un-classified string
     * @param [options={}]                 Options which customize classification
     * @param [options.intermediate=false] Allow intermediate terms
     * @param [options.prior]              The prior classified term
     * @param [options.next]               The next term to classify
     * @returns A classified RollTerm instance
     */
    protected static _classifyStringTerm(
      term: string,
      { intermediate, prior, next }?: { intermediate?: boolean; prior?: RollTerm | string; next?: RollTerm | string },
    ): RollTerm;

    /* -------------------------------------------- */
    /*  Chat Messages                               */
    /* -------------------------------------------- */

    /**
     * Render the tooltip HTML for a Roll instance
     * @return The rendered HTML tooltip as a string
     */
    getTooltip(): Promise<string>;

    /**
     * Render a Roll instance to HTML
     * @param [options={}]              Options which affect how the Roll is rendered
     * @param [options.flavor]          Flavor text to include
     * @param [options.template]        A custom HTML template path
     * @param [options.isPrivate=false] Is the Roll displayed privately?
     * @returns The rendered HTML template as a string
     */
    render(options?: RollRenderOptions): Promise<string>;

    /**
     * Transform a Roll instance into a ChatMessage, displaying the roll result.
     * This function can either create the ChatMessage directly, or return the data object that will be used to create.
     *
     * @param messageData           The data object to use when creating the message
     * @param [options]             Additional options which modify the created message.
     * @param [options.rollMode]    The template roll mode to use for the message from CONFIG.Dice.rollModes
     * @param [options.create=true] Whether to automatically create the chat message, or only return the
     *                                          prepared chatData object.
     * @return A promise which resolves to the created ChatMessage entity, if create is true
     *         or the Object of prepared chatData otherwise.
     */
    toMessage(
      messageData: PreCreate<foundry.documents.ChatMessageSource> | undefined,
      { rollMode, create }: { rollMode?: RollMode | 'roll'; create: false },
    ): Promise<foundry.documents.ChatMessageSource>;
    toMessage(
      messageData?: PreCreate<foundry.documents.ChatMessageSource>,
      { rollMode, create }?: { rollMode?: RollMode | 'roll'; create?: true },
    ): Promise<ChatMessage>;
    toMessage(
      messageData?: PreCreate<foundry.documents.ChatMessageSource>,
      { rollMode, create }?: { rollMode?: RollMode | 'roll'; create?: boolean },
    ): Promise<ChatMessage | foundry.documents.ChatMessageSource>;

    /* -------------------------------------------- */
    /*  Interface Helpers                           */
    /* -------------------------------------------- */

    /**
     * Expand an inline roll element to display it's contained dice result as a tooltip
     * @param a The inline-roll button
     */
    static expandInlineResult(a: HTMLAnchorElement): Promise<void>;

    /**
     * Collapse an expanded inline roll to conceal it's tooltip
     * @param a The inline-roll button
     */
    static collapseInlineResult(a: HTMLAnchorElement): HTMLAnchorElement;

    /* -------------------------------------------- */
    /*  Serialization and Loading                   */
    /* -------------------------------------------- */

    /**
     * Represent the data of the Roll as an object suitable for JSON serialization.
     * @return Structured data which can be serialized into JSON
     */
    toJSON(): RollJSON;

    /**
     * Recreate a Roll instance using a provided data object
     * @param data   Unpacked data representing the Roll
     * @return A reconstructed Roll instance
     */
    static fromData<T extends Roll>(this: AbstractConstructorOf<T>, data: RollJSON): T;

    /**
     * Recreate a Roll instance using a provided JSON string
     * @param json   Serialized JSON data representing the Roll
     * @return A reconstructed Roll instance
     */
    static fromJSON<T extends Roll>(this: AbstractConstructorOf<T>, json: string): T;

    /**
     * Manually construct a Roll object by providing an explicit set of input terms
     * @param terms      The array of terms to use as the basis for the Roll
     * @param [options={}] Additional options passed to the Roll constructor
     * @returns The constructed Roll instance
     *
     * @example
     * const t1 = new Die({number: 4, faces: 8};
     * const plus = new OperatorTerm({operator: "+"});
     * const t2 = new NumericTerm({number: 8});
     * const roll = Roll.fromTerms([t1, plus, t2]);
     * roll.formula; // 4d8 + 8
     */
    static fromTerms<T extends Roll>(this: ConstructorOf<T>, terms: RollTerm[], options?: RollOptions): T;
  }

  interface RollOptions {
    flavor?: string;
    [key: string]: JSONValue;
  }

  interface RollJSON {
    class: string;
    options: Record<string, unknown>;
    data?: RollOptions;
    dice: DiceTerm[];
    formula: string;
    terms: RollTerm[] | RollTermData[];
    total?: number;
    evaluated: boolean;
  }

  interface RollRenderOptions {
    /** Flavor text to include */
    flavor?: string;
    /** A custom HTML template path */
    template?: string;
    /** Is the Roll displayed privately? */
    isPrivate?: boolean;
  }

  /** An evaluated Roll instance */
  type Rolled<T extends Roll> = T & {
    readonly result: string;
    readonly total: number;
    _evaluated: true;
    terms: RollTerm[];
  };

  interface EvaluateRollParams {
    minimize?: boolean;
    maximize?: boolean;
    async?: boolean;
  }

  // Empty extended interface that can be expanded by the system without polluting Math itself
  // eslint-disable-next-line @typescript-eslint/no-empty-interface
  interface RollMathProxy extends Math {}
}

declare global {
  /**
   * @param element   The containing HTML element within which the menu is positioned
   * @param selector  A CSS selector which activates the context menu.
   * @param menuItems An Array of entries to display in the menu
   * @param [options] Additional options to configure the context menu.
   * @param [options.eventName="contextmenu"] Optionally override the triggering event which can spawn the menu
   * @param [options.onOpen]                  A function to call when the context menu is opened.
   * @param [options.onClose]                 A function to call when the context menu is closed.
   */
  class ContextMenu {
    constructor(
      element: HTMLElement | JQuery,
      selector: string,
      menuItems: ContextMenuEntry[],
      {
        eventName,
        onOpen,
        onClose,
      }?: { eventName?: string; onOpen?: ContextMenuCallback; onClose?: ContextMenuCallback },
    );

    /** The target HTMLElement being selected */
    element: HTMLElement;

    /** The target CSS selector which activates the menu */
    selector: string;

    /** An interaction event name which activates the menu */
    eventName: string;

    /** The array of menu items being rendered */
    menuItems: ContextMenuEntry[];

    /** Track which direction the menu is expanded in */
    protected _expandUp: boolean;

    /** A convenience accessor to the context menu HTML object */
    get menu(): JQuery;

    /**
     * Create a ContextMenu for this Application and dispatch hooks.
     * @param app       The Application this ContextMenu belongs to.
     * @param html      The Application's rendered HTML.
     * @param selector  The target CSS selector which activates the menu.
     * @param menuItems The array of menu items being rendered.
     * @param [options] Additional options to configure context menu initialization.
     * @param [options.hookName="EntryContext"]  The name of the hook to call.
     */
    static create(
      app: Application,
      html: JQuery,
      selector: string,
      menuItems: ContextMenuEntry[],
      options?: { eventName?: string; hookName?: string },
    ): ContextMenu | void;

    /** Attach a ContextMenu instance to an HTML selector */
    bind(): void;

    /**
     * Closes the menu and removes it from the DOM.
     * @param [options]              Options to configure the closing behavior.
     * @param [options.animate=true] Animate the context menu closing.
     */
    close(options?: { animate?: boolean }): Promise<void>;

    protected _close(): void;

    protected _animateOpen(menu: JQuery): Promise<void>;

    protected _animateClose(menu: JQuery): Promise<void>;

    /**
     * Render the Context Menu by iterating over the menuItems it contains
     * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition
     * Attach a click handler to each item which is rendered
     */
    render(target: JQuery): Promise<void>;

    /**
     * Set the position of the context menu, taking into consideration whether the menu should expand upward or downward
     */
    protected _setPosition(html: JQuery, target: JQuery): void;

    /** Local listeners which apply to each ContextMenu instance which is created. */
    activateListeners(html: JQuery): void;

    /** Global listeners which apply once only to the document. */
    static eventListeners(): void;
  }

  /** The element that the context menu has been triggered for. */
  type ContextMenuCallback = (target: HTMLElement) => void;

  interface ContextMenuEntry {
    /** The context menu label. Can be localized. */
    name: string;
    /** A string containing an HTML icon element for the menu item */
    icon: string;
    /**
     * The function to call when the menu item is clicked. Receives the HTML element
     * of the entry that this context menu is for.
     */
    callback: (target: JQuery) => void;
    /**
     * A function to call to determine if this item appears in the menu.
     * Receives the HTML element of the entry that this context menu is for.
     */
    condition?: (target: JQuery) => boolean;
  }
}

declare global {
  /**
   * A controller class for managing drag and drop workflows within an Application instance.
   * The controller manages the following actions: dragstart, dragover, drop
   * @see {@link Application}
   *
   * @example
   * const dragDrop = new DragDrop({
   *   dragSelector: ".item",
   *   dropSelector: ".items",
   *   permissions: { dragstart: this._canDragStart.bind(this), drop: this._canDragDrop.bind(this) },
   *   callbacks: { dragstart: this._onDragStart.bind(this), drop: this._onDragDrop.bind(this) }
   * });
   * dragDrop.bind(html);
   */
  class DragDrop {
    /** The HTML selector which identifies draggable elements */
    dragSelector: string;

    /** The HTML selector which identifies drop targets */
    dropSelector: string;

    /** A set of permission checking functions for each action of the Drag and Drop workflow */
    permissions: Record<string, DocumentOwnershipLevel>;

    /** A set of callback functions for each action of the Drag and Drop workflow */
    callbacks: Record<DragDropAction, (event: DragEvent) => unknown>;

    constructor({ dragSelector, dropSelector, permissions, callbacks }?: DragDropConfiguration);

    /**
     * Bind the DragDrop controller to an HTML application
     * @param html The HTML element to which the handler is bound
     */
    bind(html: HTMLElement): this;

    /**
     * Execute a callback function associated with a certain action in the workflow
     * @param event  The drag event being handled
     * @param action The action being attempted
     */
    callback(event: DragEvent, action: DragDropAction): (event: DragEvent) => unknown;

    /**
     * Test whether the current user has permission to perform a step of the workflow
     * @param action   The action being attempted
     * @param selector The selector being targeted
     * @return Can the action be performed?
     */
    can(action: DragDropAction, selector: string): boolean;

    /**
     * Handle the start of a drag workflow
     * @param event The drag event being handled
     */
    protected _handleDragStart(event: DragEvent): void;

    /**
     * Handle a dragged element over a droppable target
     * @param event The drag event being handled
     */
    protected _handleDragOver(event: DragEvent): void;

    /**
     * Handle a dragged element dropped on a droppable target
     * @param event The drag event being handled
     */
    protected _handleDrop(event: DragEvent): unknown;

    static createDragImage(img: ImageFilePath, width: number, height: number): HTMLDivElement;
  }

  interface DragDropConfiguration {
    /** The HTML selector which identifies draggable elements */
    dragSelector: string;

    /** The HTML selector which identifies drop targets */
    dropSelector: string;

    /** A set of permission checking functions for each action of the Drag and Drop workflow */
    permissions?: Record<string, DocumentOwnershipLevel>;

    /** A set of callback functions for each action of the Drag and Drop workflow */
    callbacks?: Partial<Record<DragDropAction, (event: DragEvent) => unknown>>;
  }
}

type DragDropAction = 'dragstart' | 'dragover' | 'drop';

declare global {
  /** A collection of helper functions and utility methods related to the rich text editor */
  class TextEditor {
    /**
     * Create a Rich Text Editor. The current implementation uses TinyMCE
     * @param options Configuration options provided to the Editor init
     * @param [options.engine=tinymce] Which rich text editor engine to use, "tinymce" or "prosemirror". TinyMCE
     *                                 is deprecated and will be removed in a later version.
     * @param content Initial HTML or text content to populate the editor with
     * @returns The editor instance.
     */
    static create(options?: EditorCreateOptions, content?: string): Promise<TinyMCE.Editor | ProseMirrorEditor>;

    /** A list of elements that are retained when truncating HTML. */
    protected static _PARAGRAPH_ELEMENTS: Set<string>;

    protected static _decoder: HTMLTextAreaElement;

    /* -------------------------------------------- */
    /*  HTML Manipulation Helpers                   */
    /* -------------------------------------------- */

    /**
     * Safely decode an HTML string, removing invalid tags and converting entities back to unicode characters.
     * @param html The original encoded HTML string
     * @return The decoded unicode string
     */
    static decodeHTML(html: string): string;

    /**
     * Enrich HTML content by replacing or augmenting components of it
     * @param content      The original HTML content (as a string)
     * @param [options={}] Additional options which configure how HTML is enriched
     * @param [options.secrets=false]  Include secret tags in the final HTML? If false secret blocks will be removed.
     * @param [options.documents=true] Replace dynamic document links?
     * @param [options.links=true]     Replace hyperlink content?
     * @param [options.rolls=true]     Replace inline dice rolls?
     * @param [options.rollData]       The data object providing context for inline rolls
     * @return The enriched HTML content
     */
    static enrichHTML(content: string | null, options: EnrichmentOptions & { async: false }): string;
    static enrichHTML(content: string | null, options: EnrichmentOptions & { async: true }): Promise<string>;
    static enrichHTML(content: string | null, options: EnrichmentOptions): string | Promise<string>;

    /**
     * Convert text of the form @UUID[uuid]{name} to anchor elements.
     * @param text      The existing text content
     * @param [options] Options provided to customize text enrichment
     * @param [options.async]      Whether to resolve UUIDs asynchronously
     * @param [options.relativeTo] A document to resolve relative UUIDs against.
     * @returns Whether any content links were replaced and the text nodes need to be updated.
     */
    static _enrichContentLinks(text: Text[], options?: EnrichmentOptions): boolean | Promise<boolean>;

    /**
     * Preview an HTML fragment by constructing a substring of a given length from its inner text.
     * @param content The raw HTML to preview
     * @param length  The desired length
     * @return The previewed HTML
     */
    static previewHTML(content: string, length: number): string;

    /**
     * Sanitises an HTML fragment and removes any non-paragraph-style text.
     * @param html The root HTML element.
     */
    static truncateHTML<T extends HTMLElement>(html: T): T;

    /**
     * Truncate a fragment of text to a maximum number of characters.
     * @param text         The original text fragment that should be truncated to a maximum length
     * @param [maxLength]  The maximum allowed length of the truncated string.
     * @param [splitWords] Whether to truncate by splitting on white space (if true) or breaking words.
     * @param [suffix]     A suffix string to append to denote that the text was truncated.
     */
    static truncateText(
      text: string,
      { maxLength, splitWords, suffix }: { maxLength?: number; splitWords?: boolean; suffix?: string | null },
    ): string;

    /* -------------------------------------------- */
    /*  Text Node Manipulation                      */
    /* -------------------------------------------- */

    /**
     * Recursively identify the text nodes within a parent HTML node for potential content replacement.
     * @param parent The parent HTML Element
     * @return An array of contained Text nodes
     */
    protected static _getTextNodes(parent: HTMLElement): Text[];

    /**
     * Facilitate the replacement of text node content using a matching regex rule and a provided replacement function.
     */
    protected static _replaceTextContent(text: Text[], rgx: RegExp, func: (param: string) => string): boolean;

    /** Replace a matched portion of a Text node with a replacement Node */
    protected static _replaceTextNode(text: string, match: RegExpMatchArray, replacement: Node): void;

    /* -------------------------------------------- */
    /*  Text Replacement Functions                  */
    /* -------------------------------------------- */

    /**
     * Create a dynamic document link from a regular expression match
     * @param match     The regular expression match
     * @param [options] Additional options to configure enrichment behaviour
     * @param [options.async=false] If asynchronous evaluation is enabled, fromUuid will be
     *                              called, allowing comprehensive UUID lookup, otherwise fromUuidSync will be used.
     * @param [options.relativeTo]  A document to resolve relative UUIDs against.
     * @returns An HTML element for the document link, returned as a Promise if async was true and the message
     *          contained a UUID link.
     */
    protected static _createContentLink(
      match: RegExpMatchArray,
      options?: { async?: boolean; relativeTo?: ClientDocument },
    ): HTMLAnchorElement | Promise<HTMLAnchorElement>;

    /**
     * Replace a hyperlink-like string with an actual HTML &lt;a> tag
     * @param match The full matched string
     * @return An HTML element for the document link
     */
    protected static _createHyperlink(match: string): HTMLAnchorElement;

    /**
     * Replace an inline roll formula with a rollable &lt;a> element or an eagerly evaluated roll result
     * @param match     The regular expression match array
     * @param rollData  Provided roll data for use in roll evaluation
     * @param [options] Additional options to configure enrichment behaviour
     * @returns The replaced match, returned as a Promise if async was true and the message contained an
     *          immediate inline roll.
     */
    static _createInlineRoll(
      match: RegExpMatchArray,
      rollData: Record<string, unknown>,
      options?: EvaluateRollParams,
    ): HTMLAnchorElement | null | Promise<HTMLAnchorElement | null>;

    /* -------------------------------------------- */
    /*  Event Listeners and Handlers                */
    /* -------------------------------------------- */

    static activateListeners(): void;

    /** Handle click events on Document Links */
    protected static _onClickContentLink(event: Event): Promise<void>;

    /**
     * Handle left-mouse clicks on an inline roll, dispatching the formula or displaying the tooltip
     * @param event The initiating click event
     */
    static _onClickInlineRoll(event: MouseEvent): Promise<ChatMessage | void>;

    /**
     * Toggle playing or stopping an embedded {@link PlaylistSound} link.
     * @param doc The PlaylistSound document to play/stop.
     */
    protected static _onPlaySound(doc: PlaylistSound<Playlist>): void;

    /** Find all content links belonging to a given PlaylistSound. */
    protected static _getSoundContentLinks(doc: PlaylistSound<Playlist>): NodeListOf<HTMLAnchorElement>;

    /**
     * Begin a Drag+Drop workflow for a dynamic content link
     * @param event The originating drag event
     */
    protected static _onDragContentLink(event: DragEvent): void;

    /**
     * Handle dropping of transferred data onto the active rich text editor
     * @param event  The originating drop event which triggered the data transfer
     * @param editor The TinyMCE editor instance being dropped on
     */
    protected static _onDropEditorData(event: DragEvent, editor: TinyMCE.Editor): Promise<void>;

    /**
     * Extract JSON data from a drag/drop event.
     * @param event The drag event which contains JSON data.
     * @returns The extracted JSON data. The object will be empty if the DragEvent did not contain JSON-parseable data.
     */
    static getDragEventData(event: DragEvent): Record<string, JSONValue>;

    /** Given a Drop event, returns a Content link if possible such as @Actor[ABC123], else null */
    static getContentLink(event: DragEvent): Promise<string | null>;
  }

  interface EnrichmentOptions {
    async?: boolean;
    secrets?: boolean;
    documents?: boolean;
    links?: boolean;
    rolls?: boolean;
    rollData?: Record<string, unknown>;
  }

  type EditorCreateOptions = Partial<TinyMCE.EditorOptions | ProseMirrorEditorOptions> & {
    engine?: 'tinymce' | 'prosemirror';
  };
}

declare global {
  /**
   * A common framework for displaying notifications to the client.
   * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
   * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
   *
   * @example
   * ui.notifications.info("This is an info message");
   * ui.notifications.warn("This is a warning message");
   * ui.notifications.error("This is an error message");
   * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
   */
  class Notifications extends Application {
    /** Submitted notifications which are queued for display */
    queue: NotificationData[];

    /** Notifications which are currently displayed */
    active: JQuery[];

    constructor(options: ApplicationOptions);

    /** Initialize the Notifications system by displaying any system-generated messages which were passed from the server. */
    initialize(): void;

    /**
     * Push a new notification into the queue
     * @param message The content of the notification message
     * @param type    The type of notification, "info", "warning", and "error" are supported
     * @param [options={}] Additional options which affect the notification
     * @returns The ID of the notification
     */
    notify(message: string, type?: 'info' | 'warning' | 'error', { localize, permanent }?: NotifyOptions): number;

    /**
     * Display a notification with the "info" type
     * @param message   The content of the notification message
     * @param [options] Notification options passed to the notify function
     * @returns The ID of the notification
     */
    info(message: string, options?: NotifyOptions): number;

    /**
     * Display a notification with the "info" type
     * @param message   The content of the notification message
     * @param [options] Notification options passed to the notify function
     * @returns The ID of the notification
     */
    warn(message: string, options?: NotifyOptions): number;

    /**
     * Display a notification with the "info" type
     * @param message   The content of the notification message
     * @param [options] Notification options passed to the notify function
     * @returns The ID of the notification
     */
    error(message: string, options?: NotifyOptions): number;

    /**
     * Remove the notification linked to the ID.
     * @param id The ID of the notification
     */
    remove(id: number): void;

    /** Clear all notifications. */
    clear(): void;

    /** Retrieve a pending notification from the queue and display it */
    fetch(): void;
  }
}

interface NotifyOptions {
  /** Should the notification be permanently displayed until dismissed */
  permanent?: boolean;
  /** to localize the message content before displaying it */
  localize?: boolean;
  /** Whether to log the message to the console */
  console?: boolean;
}

interface NotificationData {
  message: string;
  type: 'info' | 'warning' | 'error';
  timestamp: number;
  permanent: boolean;
}

declare global {
  /** A class responsible for managing state and collaborative editing of a single ProseMirror instance. */
  class ProseMirrorEditor {
    /** A string that uniquely identifies this ProseMirror instance. */
    readonly uuid: string;

    /** The ProseMirror EditorView. */
    readonly view: ProseMirror.EditorView;

    /** Whether this is a collaborative editor. */
    readonly collaborate: boolean;

    /** Additional options. */
    options: {
      /** A document associated with this editor. */
      document?: ClientDocument;
    };

    constructor(
      uuid: string,
      view: ProseMirror.EditorView,
      isDirtyPlugin: boolean,
      collaborate: boolean,
      options?: { document: ClientDocument },
    );

    /** Retire this editor instance and clean up. */
    destroy(): void;

    /** Have the contents of the editor been edited by the user? */
    isDirty(): void;

    /**
     * Handle new editing steps supplied by the server.
     * @param offset  The offset into the history, representing the point at which it was last truncated.
     * @param history The entire edit history.
     */
    protected _onNewSteps(offset: number, history: ProseMirrorHistory[]): void;

    /**
     * Disable source code editing if the user was editing it when new steps arrived.
     */
    protected _disableSourceCodeEditing(): void;

    /** The state of this ProseMirror editor has fallen too far behind the central authority's and must be re-synced. */
    protected _resync(): void;

    /**
     * Handle users joining or leaving collaborative editing.
     * @param users The IDs of users currently editing (including ourselves).
     */
    protected _updateUserDisplay(users: string[]): void;

    /**
     * Handle an autosave update for an already-open editor.
     * @param html The updated editor contents.
     */
    protected _handleAutosave(html: string): void;

    /**
     * Create a ProseMirror editor instance.
     * @param target       An HTML element to mount the editor to.
     * @param [content=""] Content to populate the editor with.
     * @param [options]    Additional options to configure the ProseMirror instance.
     */
    static create(
      target: HTMLElement,
      content?: string | undefined,
      options?: ProseMirrorEditorOptions,
    ): Promise<ProseMirrorEditor>;

    /**
     * Create an EditorView with collaborative editing enabled.
     * @param uuid    The ProseMirror instance UUID.
     * @param target  An HTML element to mount the editor view to.
     * @param state   The ProseMirror editor state.
     * @param plugins The editor plugins to load.
     */
    protected static _createCollaborativeEditorView(
      uuid: string,
      target: HTMLElement,
      state: ProseMirror.EditorState,
      plugins: ProseMirror.Plugin,
    ): Promise<ProseMirror.EditorView>;

    /**
     * Create a plain EditorView without collaborative editing.
     * @param target  An HTML element to mount the editor view to.
     * @param state   The ProseMirror editor state.
     * @param plugins The editor plugins to load.
     */
    protected static _createLocalEditorView(
      target: HTMLElement,
      state: ProseMirror.EditorState,
      plugins: ProseMirror.Plugin[],
    ): ProseMirror.EditorView;

    /* -------------------------------------------- */
    /*  Socket Handlers                             */
    /* -------------------------------------------- */

    /**
     * Handle new editing steps supplied by the server.
     * @param uuid    The UUID that uniquely identifies the ProseMirror instance.
     * @param offset  The offset into the history, representing the point at which it was last truncated.
     * @param history The entire edit history.
     */
    protected static _onNewSteps(uuid: string, offset: number, history: ProseMirrorHistory[]): void;

    /**
     * Our client is too far behind the central authority's state and must be re-synced.
     * @param uuid  The UUID that uniquely identifies the ProseMirror instance.
     */
    protected static _onResync(uuid: string): void;

    /**
     * Handle users joining or leaving collaborative editing.
     * @param uuid  The UUID that uniquely identifies the ProseMirror instance.
     * @param users The IDs of the users editing (including ourselves).
     */
    protected static _onUsersEditing(uuid: string, users: string[]): void;

    /**
     * Update client state when the editor contents are autosaved server-side.
     * @param uuid The UUID that uniquely identifies the ProseMirror instance.
     * @param html The updated editor contents.
     */
    protected static _onAutosave(uuid: string, html: string): Promise<void>;
  }

  interface ProseMirrorEditorOptions {
    /** A string to uniquely identify this ProseMirror instance. Ignored for a collaborative editor. */
    uuid?: string;
    /** A Document whose content is being edited. Required for collaborative editing and relative UUID generation. */
    document?: ClientDocument;
    /** Plugins to include with the editor. */
    plugins?: Record<string, ProseMirror.Plugin>;
    /** The field within the Document that is being edited. Required for collaborative editing. */
    fieldName?: string;
    /** Whether to generate relative UUID links to Documents that are dropped on the editor. */
    relativeLinks?: boolean;
    /** Whether to enable collaborative editing for this editor. */
    collaborate?: boolean;
  }
}

interface ProseMirrorHistory {
  /** The ID of the user who submitted the step. */
  userId: string;
  /** The step that was submitted. */
  step: ProseMirror.Step;
}

declare global {
  /**
   * A composable class for managing functionality for secret blocks within DocumentSheets.
   * {@see DocumentSheet}
   * @example Activate secret revealing functionality within a certain block of content.
   * ```js
   * const secrets = new HTMLSecret({
   *   selector: "section.secret[id]",
   *   callbacks: {
   *     content: this._getSecretContent.bind(this),
   *     update: this._updateSecret.bind(this)
   *   }
   * });
   * secrets.bind(html);
   * ```
   */
  class HTMLSecret {
    /** The CSS selector used to target secret blocks. */
    readonly parentSelector: string;

    /** An object of callback functions for each operation. */
    readonly callbacks: Readonly<HTMLSecretConfiguration>;

    /**
     * @param options Configuration options.
     */
    constructor(options?: HTMLSecretConfiguration);

    /**
     * Add event listeners to the targeted secret blocks.
     * @param html The HTML content to select secret blocks from.
     */
    bind(html: HTMLElement): void;

    /**
     * Handle toggling a secret's revealed state.
     * @param The triggering click event.
     * @returns The Document whose content was modified.
     */
    protected _onToggleSecret(event: MouseEvent): Promise<ClientDocument>;
  }
}

interface HTMLSecretContentCallback {
  /**
   * @param secret The secret element whose surrounding content we wish to retrieve.
   * @returns The content where the secret is housed.
   */
  (secret: HTMLElement): string;
}

interface HTMLSecretUpdateCallback {
  /**
   * @param secret  The secret element that is being manipulated.
   * @param content The content block containing the updated secret element.
   * @returns The updated Document.
   */
  (secret: HTMLElement, content: string): Promise<ClientDocument>;
}

interface HTMLSecretConfiguration {
  /** The CSS selector used to target content that contains secret blocks. */
  parentSelector?: string;
  /** An object of callback functions for each operation. */
  callbacks?: { content?: HTMLSecretContentCallback; update?: HTMLSecretUpdateCallback };
}

declare global {
  /**
   * A singleton Tooltip Manager class responsible for rendering and positioning a dynamic tooltip element which is
   * accessible as `game.tooltip`.
   *
   * @example API Usage
   * ```js
   * game.tooltip.activate(htmlElement, {text: "Some tooltip text", direction: "UP"});
   * game.tooltip.deactivate();
   * ```
   *
   * @example HTML Usage
   * ```html
   * <span data-tooltip="Some Tooltip" data-tooltip-direction="LEFT">I have a tooltip</span>
   * <ol data-tooltip-direction="RIGHT">
   *   <li data-tooltip="The First One">One</li>
   *   <li data-tooltip="The Second One">Two</li>
   *   <li data-tooltip="The Third One">Three</li>
   * </ol>
   * ```
   */
  class TooltipManager {
    /** A cached reference to the global tooltip element */
    tooltip: HTMLElement;

    /** A reference to the HTML element which is currently tool-tipped, if any. */
    element: HTMLElement | null;

    /** An amount of margin which is used to offset tooltips from their anchored element. */
    static TOOLTIP_MARGIN_PX: number;

    /** The number of milliseconds delay which activates a tooltip on a "long hover". */
    static TOOLTIP_ACTIVATION_MS: number;

    /** The directions in which a tooltip can extend, relative to its tool-tipped element. */
    static TOOLTIP_DIRECTIONS: {
      UP: 'UP';
      DOWN: 'DOWN';
      LEFT: 'LEFT';
      RIGHT: 'RIGHT';
      CENTER: 'CENTER';
    };

    /** The number of pixels buffer around a locked tooltip zone before they should be dismissed. */
    static LOCKED_TOOLTIP_BUFFER_PX: number;

    /** Activate interactivity by listening for hover events on HTML elements which have a data-tooltip defined. */
    activateEventListeners(): void;

    /**
     * Activate the tooltip for a hovered HTML element which defines a tooltip localization key.
     * @param element              The HTML element being hovered.
     * @param [options={}]         Additional options which can override tooltip behavior.
     */
    activate(element: HTMLElement, options?: TooltipActivationOptions): void;

    /** Deactivate the tooltip from a previously hovered HTML element. */
    deactivate(): void;

    /** Clear any pending activation workflow. */
    protected clearPending(): void;

    /** Lock the current tooltip. */
    lockTooltip(): HTMLElement;

    /**
     * Handle a request to lock the current tooltip.
     * @param event  The click event.
     */
    protected _onLockTooltip(event: MouseEvent): void;

    /**
     * Handle dismissing a locked tooltip.
     * @param event  The click event.
     */
    protected _onLockedTooltipDismiss(event: MouseEvent): void;

    /**
     * Dismiss a given locked tooltip.
     * @param element  The locked tooltip to dismiss.
     */
    dismissLockedTooltip(element: HTMLElement): void;

    /** Dismiss the set of active locked tooltips. */
    dismissLockedTooltips(): void;

    /**
     * Create a locked tooltip at the given position.
     * @param position             A position object with coordinates for where the tooltip should be placed
     * @param position.top         Explicit top position for the tooltip
     * @param position.right       Explicit right position for the tooltip
     * @param position.bottom      Explicit bottom position for the tooltip
     * @param position.left        Explicit left position for the tooltip
     * @param text                 Explicit tooltip text or HTML to display.
     * @param [options={}]         Additional options which can override tooltip behavior.
     * @param [options.cssClass]   An optional, space-separated list of CSS classes to apply to the activated
     *                             tooltip.
     */
    createLockedTooltip(position: TooltipPosition, text: string, options?: { cssClass?: string }): HTMLElement;

    /**
     * If an explicit tooltip expansion direction was not specified, figure out a valid direction based on the bounds
     * of the target element and the screen.
     */
    protected _determineDirection(): 'UP' | 'DOWN';

    /**
     * Set tooltip position relative to an HTML element using an explicitly provided data-tooltip-direction.
     * @param direction  The tooltip expansion direction specified by the element or a parent element.
     */
    protected _setAnchor(direction: TooltipDirection): void;

    /**
     * Apply inline styling rules to the tooltip for positioning and text alignment.
     * @param position  An object of positioning data, supporting top, right, bottom, left, and textAlign
     */
    protected _setStyle(position: TooltipStylePosition): void;
  }

  type TooltipDirection = keyof (typeof TooltipManager)['TOOLTIP_DIRECTIONS'];

  interface TooltipActivationOptions {
    /**
     * Explicit tooltip text to display. If this is not provided the tooltip text is acquired from the elements
     * data-tooltip attribute. This text will be automatically localized.
     */
    text?: string;
    /**
     * An explicit tooltip expansion direction. If this is not provided the direction is acquired from the
     * data-tooltip-direction attribute of the element or one of its parents.
     */
    direction?: TooltipDirection;
    /**
     * An optional, space-separated list of CSS classes to apply to the activated tooltip. If this is not provided,
     * the CSS classes are acquired from the data-tooltip-class attribute of the element or one of its parents.
     */
    cssClass?: string;
    /** An optional boolean to lock the tooltip after creation. Defaults to false. */
    locked?: boolean;
    /** Explicit HTML content to inject into the tooltip rather than using tooltip text. */
    content?: HTMLElement;
  }

  interface TooltipPosition {
    top: string;
    right: string;
    bottom: string;
    left: string;
  }

  interface TooltipStylePosition {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
    textAlign?: string;
  }
}

declare global {
  /**
   * A Tour that shows a series of guided steps.
   * @param config           The configuration of the Tour
   */
  class Tour {
    constructor(config: TourConfig, override: { id?: string; namspace?: string });

    static STATUS: {
      UNSTARTED: 'unstarted';
      IN_PROGRESS: 'in-progress';
      COMPLETED: 'completed';
    };

    /** Indicates if a Tour is currently in progress. */
    static get tourInProgress(): boolean;

    /** Returns the active Tour, if any */
    static get activeTour(): Tour | null;

    /**
     * Handle a movement action to either progress or regress the Tour.
     * @param movementDirections           The Directions being moved in
     */
    static onMovementAction(movementDirections: string[]): boolean;

    /** Configuration of the tour. This object is cloned to avoid mutating the original configuration. */
    config: TourConfig;

    /** The HTMLElement which is the focus of the current tour step. */
    targetElement: HTMLElement;

    /** The HTMLElement that fades out the rest of the screen */
    fadeElement: HTMLElement;

    /** The HTMLElement that blocks input while a Tour is active */
    overlayElement: HTMLElement;

    /** Padding around a Highlighted Element */
    static HIGHLIGHT_PADDING: number;

    /** The unique identifier of the tour. */
    get id(): string;

    set id(value: string);

    /** The human-readable title for the tour. */
    get title(): string;

    /** The human-readable description of the tour. */
    get description(): string;

    /** The package namespace for the tour. */
    get namespace(): string;

    set namespace(value: string);

    /** The key the Tour is stored under in game.tours, of the form `${namespace}.${id}` */
    get key(): `${string}.${string}`;

    /** The configuration of tour steps */
    get steps(): TourStep[];

    /** Return the current Step, or null if the tour has not yet started. */
    get currentStep(): TourStep | null;

    /** The index of the current step; -1 if the tour has not yet started, or null if the tour is finished. */
    get stepIndex(): number | null;

    /** Returns True if there is a next TourStep */
    get hasNext(): boolean;

    /** Returns True if there is a previous TourStep */
    get hasPrevious(): boolean;

    /**
     * Return whether this Tour is currently eligible to be started?
     * This is useful for tours which can only be used in certain circumstances, like if the canvas is active.
     */
    get canStart(): boolean;

    /** The current status of the Tour */
    get status(): (typeof Tour.STATUS)[keyof typeof Tour.STATUS];

    /* -------------------------------------------- */
    /*  Tour Methods                                */
    /* -------------------------------------------- */

    /** Advance the tour to a completed state. */
    complete(): Promise<void>;

    /** Exit the tour at the current step. */
    exit(): void;

    /** Reset the Tour to an un-started state. */
    reset(): Promise<void>;

    /** Start the Tour at its current step, or at the beginning if the tour has not yet been started. */
    start(): Promise<void>;

    /** Progress the Tour to the next step. */
    next(): Promise<void>;

    /** Rewind the Tour to the previous step. */
    previous(): Promise<void>;

    /**
     * Progresses to a given Step
     * @param stepIndex  The step to progress to
     */
    progress(stepIndex: number): Promise<void>;

    /**
     * Query the DOM for the target element using the provided selector
     * @param selector     A CSS selector
     */
    protected _getTargetElement(selector: string): Element | null;

    /**
     * Creates and returns a Tour by loading a JSON file
     * @param {string} filepath   The path to the JSON file
     */
    static fromJSON(filepath: string): Promise<Tour>;

    /* -------------------------------------------- */
    /*  Event Handlers                              */
    /* -------------------------------------------- */

    /** Set-up operations performed before a step is shown. */
    protected _preStep(): Promise<void>;

    /** Clean-up operations performed after a step is completed. */
    protected _postStep(): Promise<void>;

    /** Renders the current Step of the Tour */
    protected _renderStep(): Promise<void>;

    /**
     * Handle Tour Button clicks
     * @param event   A click event
     * @param buttons   The step buttons
     */
    private _onButtonClick(event: MouseEvent, buttons: HTMLButtonElement[]): void;

    /** Saves the current progress of the Tour to a world setting */
    private _saveProgress(): void;

    /** Returns the User's current progress of this Tour */
    private _loadProgress(): number | null;

    /** Reloads the Tour's current step from the saved progress */
    protected _reloadProgress(): void;
  }

  /** A singleton Tour Collection class responsible for registering and activating Tours, accessible as game.tours */
  class Tours extends Collection {
    /**
     * Register a new Tour
     * @param namespace          The namespace of the Tour
     * @param id                 The machine-readable id of the Tour
     * @param tour               The constructed Tour
     */
    register(namespace: string, id: string, tour: Tour): void;

    override set(key: string, tour: Tour): this;
  }

  /** A step in a Tour */
  interface TourStep {
    /** A machine-friendly id of the Tour Step */
    id: string;
    /** The title of the step, displayed in the tooltip header */
    title: string;
    /** Raw HTML content displayed during the step */
    content: string;
    /** A DOM selector which denotes an element to highlight during this step.
     *  If omitted, the step is displayed in the center of the screen. */
    selector?: string;
    /** How the tooltip for the step should be displayed relative to the target element.
     *  If omitted, the best direction will be attempted to be auto-selected.
     */
    tooltipDirection?: TooltipDirection;
    /** Whether the Step is restricted to the GM only. Defaults to false. */
    restricted?: boolean;
  }

  /** Tour configuration data */
  interface TourConfig {
    /** The namespace this Tour belongs to. Typically, the name of the package which implements the tour should be used */
    namespace: string;
    /** A machine-friendly id of the Tour, must be unique within the provided namespace */
    id: string;
    /** A human-readable name for this Tour. Localized. */
    title: string;
    /** The list of Tour Steps */
    steps: TourStep[];
    /** A human-readable description of this Tour. Localized. */
    description?: string;
    /** A map of localizations for the Tour that should be merged into the default localizations */
    localization?: Record<string, string>;
    /** Whether the Tour is restricted to the GM only. Defaults to false. */
    restricted?: boolean;
    /** Whether the Tour should be displayed in the Manage Tours UI. Defaults to false. */
    display?: boolean;
    /** Whether the Tour can be resumed or if it always needs to start from the beginning. Defaults to false. */
    canBeResumed?: boolean;
    /** A list of namespaced Tours that might be suggested to the user when this Tour is completed.
     * The first non-completed Tour in the array will be recommended.
     */
    suggestedNextTours?: string[];
  }
}

declare global {
  interface FoundryUI<
    TActorDirectory extends ActorDirectory<Actor<null>>,
    TItemDirectory extends ItemDirectory<Item<null>>,
    TChatLog extends ChatLog,
    TCompendiumDirectory extends CompendiumDirectory,
    TCombatTracker extends CombatTracker<Combat | null>,
    THotbar extends Hotbar,
  > {
    actors: TActorDirectory;
    chat: TChatLog;
    combat: TCombatTracker;
    compendium: TCompendiumDirectory;
    controls: SceneControls;
    items: TItemDirectory;
    notifications: Notifications;
    settings: Settings;
    sidebar: Sidebar;
    tables: RollTableDirectory;
    windows: Record<number, Application>;
    hotbar: THotbar;
    nav: SceneNavigation;
  }
}

/** Test whether a string is a valid 16 character UID */
declare function isValidId(id: string): boolean;

/** Test whether a file path has an extension in a list of provided extensions */
declare function _hasFileExtension(path: string, extensions: string[]): path is `${string}.${string}`;

/**
 * Test whether a file path has a valid image file extension or is base64 PNG data
 * @param path The image path to test
 * @return Is the path valid?
 */
declare function hasImageExtension(path: string): path is ImageFilePath;

/**
 * Test whether a data blob represents a base64 image
 * @param data A base64 data string
 * @return Is it a base64 image?
 */
declare function isBase64Image(data: string): data is `data:image/${string}`;

/**
 * Test whether an input represents a valid 6-character color string
 * @param color The input string to test
 * @return Is the string a valid color?
 */
declare function isColorString(color: string): color is HexColorString;

/**
 * Test whether a file path has a valid audio file extension
 * @param path The image path to test
 * @return Is the path valid?
 */
declare function hasVideoExtension(path: string): path is VideoFilePath;

/**
 * Test whether a file path has a valid video file extension
 * @param path The image path to test
 * @return Is the path valid?
 */
declare function hasAudioExtension(path: string): path is AudioFilePath;

/**
 * Assert that the given value is in an array of allowed options
 * @param val   The value to test
 * @param array The set of allowed options
 * @return Is the valid included?
 */
declare function valueInArray<T extends readonly unknown[]>(val: unknown, array: T): val is T[number];

/**
 * Assert that the given value parses as a valid JSON string
 * @param val The value to test
 * @return Is the String valid JSON?
 */
declare function isJSON(val: string): boolean;

declare const validators_d__hasFileExtension: typeof _hasFileExtension;
declare const validators_d_hasAudioExtension: typeof hasAudioExtension;
declare const validators_d_hasImageExtension: typeof hasImageExtension;
declare const validators_d_hasVideoExtension: typeof hasVideoExtension;
declare const validators_d_isBase64Image: typeof isBase64Image;
declare const validators_d_isColorString: typeof isColorString;
declare const validators_d_isJSON: typeof isJSON;
declare const validators_d_isValidId: typeof isValidId;
declare const validators_d_valueInArray: typeof valueInArray;
declare namespace validators_d {
  export {
    validators_d__hasFileExtension as _hasFileExtension,
    validators_d_hasAudioExtension as hasAudioExtension,
    validators_d_hasImageExtension as hasImageExtension,
    validators_d_hasVideoExtension as hasVideoExtension,
    validators_d_isBase64Image as isBase64Image,
    validators_d_isColorString as isColorString,
    validators_d_isJSON as isJSON,
    validators_d_isValidId as isValidId,
    validators_d_valueInArray as valueInArray,
  };
}

type Data_AnimationData = AnimationData;
type Data_DarknessActivation = DarknessActivation;
type Data_LightData<TParent extends DataModel | null> = LightData<TParent>;
type Data_PrototypeToken<TParent extends BaseActor | null> = PrototypeToken<TParent>;
type Data_PrototypeTokenSource = PrototypeTokenSource;
type Data_ShapeData<TParent extends DataModel | null> = ShapeData<TParent>;
type Data_TextureData = TextureData;
declare const Data_TextureData: typeof TextureData;
type Data_TileOcclusion = TileOcclusion;
type Data_TombstoneData<TParent extends BaseActorDelta<BaseToken<BaseScene | null> | null> | null> =
  TombstoneData<TParent>;
type Data_TombstoneDataSchema = TombstoneDataSchema;
type Data_TombstoneSource<TDocumentId extends string | null = string | null> = TombstoneSource<TDocumentId>;
type Data_VideoData = VideoData;
declare namespace Data {
  export {
    type Data_AnimationData as AnimationData,
    type Data_DarknessActivation as DarknessActivation,
    type Data_LightData as LightData,
    type LightSource$1 as LightSource,
    type Data_PrototypeToken as PrototypeToken,
    type Data_PrototypeTokenSource as PrototypeTokenSource,
    type Data_ShapeData as ShapeData,
    Data_TextureData as TextureData,
    type Data_TileOcclusion as TileOcclusion,
    type Data_TombstoneData as TombstoneData,
    type Data_TombstoneDataSchema as TombstoneDataSchema,
    type Data_TombstoneSource as TombstoneSource,
    type Data_VideoData as VideoData,
    fields_d as fields,
    validationFailure_d as validation,
    validators_d as validators,
  };
}

/**
 * Determine the relative orientation of three points in two-dimensional space.
 * The result is also an approximation of twice the signed area of the triangle defined by the three points.
 * This method is fast - but not robust against issues of floating point precision. Best used with integer coordinates.
 * Adapted from https://github.com/mourner/robust-predicates
 *
 * @param a An endpoint of segment AB, relative to which point C is tested
 * @param b An endpoint of segment AB, relative to which point C is tested
 * @param c A point that is tested relative to segment AB
 *
 * @returns The relative orientation of points A, B, and C
 *          A positive value if the points are in counter-clockwise order (C lies to the left of AB)
 *          A negative value if the points are in clockwise order (C lies to the right of AB)
 *          Zero if the points A, B, and C are collinear.
 */
declare function orient2dFast(a: Point, b: Point, c: Point): number;

/**
 * Quickly test whether the line segment AB intersects with the line segment CD.
 * This method does not determine the point of intersection, for that use lineLineIntersection
 *
 * @param a The first endpoint of segment AB
 * @param b The second endpoint of segment AB
 * @param c The first endpoint of segment CD
 * @param d The second endpoint of segment CD
 *
 * @returns Do the line segments intersect?
 */
declare function lineSegmentIntersects(a: Point, b: Point, c: Point, d: Point): boolean;

/**
 * An internal helper method for computing the intersection between two infinite-length lines.
 * Adapted from http://paulbourke.net/geometry/pointlineplane/
 *
 * @param a The first endpoint of segment AB
 * @param b The second endpoint of segment AB
 * @param c The first endpoint of segment CD
 * @param d The second endpoint of segment CD
 *
 * @returns An intersection point, or null if no intersection occurred
 */
declare function lineLineIntersection(a: Point, b: Point, c: Point, d: Point): LineIntersection | null;

/**
 * An internal helper method for computing the intersection between two finite line segments.
 * Adapted from http://paulbourke.net/geometry/pointlineplane/
 *
 * @param a The first endpoint of segment AB
 * @param b The second endpoint of segment AB
 * @param c The first endpoint of segment CD
 * @param d The second endpoint of segment CD
 * @param [epsilon] A small epsilon which defines a tolerance for near-equality
 *
 * @returns An intersection point, or null if no intersection occurred
 */
declare function lineSegmentIntersection(
  a: Point,
  b: Point,
  c: Point,
  d: Point,
  epsilon?: number,
): LineIntersection | null;

/**
 * Determine the intersection between a candidate wall and the circular radius of the polygon.
 * @param a       The initial vertex of the candidate edge
 * @param b       The second vertex of the candidate edge
 * @param center  The center of the bounding circle
 * @param radius  The radius of the bounding circle
 * @param epsilon A small tolerance for floating point precision
 *
 * @returns The intersection of the segment AB with the circle
 */
declare function lineCircleIntersection(
  a: Point,
  b: Point,
  center: Point,
  radius: number,
  epsilon?: number,
): LineCircleIntersection;

/**
 * Identify the point closest to C on segment AB
 * @param c The reference point C
 * @param a Point A on segment AB
 * @param b Point B on segment AB
 *
 * @returns The closest point to C on segment AB
 */
declare function closestPointToSegment(c: Point, a: Point, b: Point): Point;

/**
 * Determine the points of intersection between a line segment (p0,p1) and a circle.
 * There will be zero, one, or two intersections
 * See https://math.stackexchange.com/a/311956
 *
 * @param p0          The initial point of the line segment
 * @param p1          The terminal point of the line segment
 * @param center      The center of the circle
 * @param radius      The radius of the circle
 * @param [epsilon=0] A small tolerance for floating point precision
 */
declare function quadraticIntersection(p0: Point, p1: Point, center: Point, radius: number, epsilon?: number): Point[];

declare global {
  /**
   * @property x  The x-coordinate of intersection
   * @property y  The y-coordinate of intersection
   * @property t0 The proximity to the Ray origin, as a ratio of distance
   * @property t1 The proximity to the Ray destination, as a ratio of distance
   */
  interface RayIntersection {
    x: number;
    y: number;
    t0: number;
    t1: number;
  }

  interface Vector2 {
    x: number;
    y: number;
    t0: number;
    t1: number;
  }

  interface LineIntersection {
    /** The x-coordinate of intersection */
    x: number;
    /** The y-coordinate of intersection */
    y: number;
    /** The vector distance from A to B on segment AB  */
    t0: number;
    /** The vector distance from C to D on segment CD */
    t1: number;
  }

  interface LineCircleIntersection {
    /** Is point A inside the circle? */
    aInside: boolean;
    /** Is point B inside the circle? */
    bInside: boolean;
    /** Is the segment AB contained within the circle? */
    contained: boolean;
    /** Is the segment AB fully outside the circle? */
    outside: boolean;
    /** Is the segment AB tangent to the circle? */
    tangent: boolean;
    /** Intersection points: zero, one, or two */
    intersections: Point[];
  }
}

/**
 * A wrapper method around `fetch` that attaches an AbortController signal to the `fetch` call for clean timeouts
 * @see https://www.npmjs.com/package/node-fetch#request-cancellation-with-abortsignal
 * @param url  The URL to make the Request to
 * @param data The data of the Request
 * @param timeoutMs How long to wait for a Response before cleanly aborting. If null, no timeout is applied
 * @param onTimeout A method to invoke if and when the timeout is reached
 * @throws {HttpError}
 */
declare function fetchWithTimeout(
  url: string,
  data?: RequestInit,
  options?: { timeoutMs?: number | null; onTimeout?: () => unknown | void },
): Promise<Response>;

/**
 * A small wrapper that automatically asks for JSON with a Timeout
 * @param url The URL to make the Request to
 * @param data The data of the Request
 * @param timeoutMs How long to wait for a Response before cleanly aborting
 * @param onTimeout A method to invoke if and when the timeout is reached
 */
declare function fetchJsonWithTimeout(
  url: string,
  data?: RequestInit,
  options?: { timeoutMs?: number | null; onTimeout?: () => unknown | void },
): Promise<JSONValue>;

/**
 * Represents an HTTP Error when a non-OK response is returned by Fetch
 * @extends {Error}
 */
declare class HttpError extends Error {
  constructor(statusText: string, code: number, displayMessage?: string);

  override toString(): string;
}

/**
 * Wrap a callback in a debounced timeout.
 * Delay execution of the callback function until the function has not been called for delay milliseconds
 * @param callback A function to execute once the debounced threshold has been passed
 * @param delay An amount of time in milliseconds to delay
 * @return A wrapped function which can be called to debounce execution
 */
declare function debounce<T extends unknown[]>(callback: (...args: T) => unknown, delay: number): (...args: T) => void;

/**
 * Quickly clone a simple piece of data, returning a copy which can be mutated safely.
 * This method DOES support recursive data structures containing inner objects or arrays.
 * This method DOES NOT support advanced object types like Set, Map, or other specialized classes.
 * @param original Some sort of data
 * @return The clone of that data
 */
declare function deepClone<T>(original: T): T;

/**
 * A cheap data duplication trick which is relatively robust.
 * For a subset of cases the deepClone function will offer better performance.
 * @param original Some sort of data
 */
declare function duplicate<T>(original: T): T;

/**
 * Test whether a value is empty-like; either undefined or a content-less object.
 * @param value The value to test
 * @returns Is the value empty-like?
 */
declare function isEmpty(value: unknown): boolean;

/**
 * Update a source object by replacing its keys and values with those from a target object.
 *
 * @param original     The initial object which should be updated with values from the target
 * @param [other={}]   A new object whose values should replace those in the source
 * @param [options={}] Additional options which configure the merge
 * @param [_d=0]       A privately used parameter to track recursion depth.
 * @returns The original source object including updated, inserted, or overwritten records.
 *
 * @example Control how new keys and values are added
 * ```js
 * mergeObject({k1: "v1"}, {k2: "v2"}, {insertKeys: false}); // {k1: "v1"}
 * mergeObject({k1: "v1"}, {k2: "v2"}, {insertKeys: true});  // {k1: "v1", k2: "v2"}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {insertValues: false}); // {k1: {i1: "v1"}}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {insertValues: true}); // {k1: {i1: "v1", i2: "v2"}}
 * ```
 *
 * @example Control how existing data is overwritten
 * ```js
 * mergeObject({k1: "v1"}, {k1: "v2"}, {overwrite: true}); // {k1: "v2"}
 * mergeObject({k1: "v1"}, {k1: "v2"}, {overwrite: false}); // {k1: "v1"}
 * ```
 *
 * @example Control whether merges are performed recursively
 * ```js
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {recursive: false}); // {k1: {i2: "v2"}}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {recursive: true}); // {k1: {i1: "v1", i2: "v2"}}
 * ```
 *
 * @example Deleting an existing object key
 * ```js
 * mergeObject({k1: "v1", k2: "v2"}, {"-=k1": null}, {performDeletions: true});   // {k2: "v2"}
 * ```
 */
declare function mergeObject<T extends object, U extends object = T>(
  original: T,
  other?: U | undefined,
  options?: MergeObjectOptions,
  _d?: number,
): T & U;

/**
 * Learn the named type of a token - extending the functionality of typeof to recognize some core Object types
 * @param token Some passed token
 * @return      The named type of the token
 */
declare function getType(token: unknown): string;

/**
 * A temporary shim to invert an object, flipping keys and values
 * @param obj    Some object where the values are unique
 * @return       An inverted object where the values of the original object are the keys of the new object
 */
declare function invertObject(obj: object): object;

/**
 * Filter the contents of some source object using the structure of a template object.
 * Only keys which exist in the template are preserved in the source object.
 *
 * @param source           An object which contains the data you wish to filter
 * @param template         An object which contains the structure you wish to preserve
 * @param keepSpecial      Whether to keep special tokens like deletion keys
 * @param templateValues   Instead of keeping values from the source, instead draw values from the template
 *
 * @example
 * const source = {foo: {number: 1, name: "Tim", topping: "olives"}, bar: "baz"};
 * const template = {foo: {number: 0, name: "Mit", style: "bold"}, other: 72};
 * filterObject(source, template); // {foo: {number: 1, name: "Tim"}};
 * filterObject(source, template, {templateValues: true}); // {foo: {number: 0, name: "Mit"}};
 */
declare function filterObject(
  source: object,
  template: object,
  keepSpecial?: boolean,
  templateValues?: boolean,
): object;

/**
 * Flatten a possibly multi-dimensional object to a one-dimensional one by converting all nested keys to dot notation
 * @param obj  The object to flatten
 * @param _d   Recursion depth, to prevent overflow
 * @return     A flattened object
 */
declare function flattenObject(obj: object, _d?: number): Record<string, unknown>;

/**
 * Expand a flattened object to be a standard multi-dimensional nested Object by converting all dot-notation keys to
 * inner objects.
 *
 * @param obj  The object to expand
 * @param _d   Recursion depth, to prevent overflow
 * @return     An expanded object
 */
declare function expandObject<T extends Record<string, unknown>>(obj: object, _d?: number): T;

/**
 * A simple function to test whether or not an Object is empty
 * @param obj    The object to test
 * @return       Is the object empty?
 */
declare function isObjectEmpty(obj: object): boolean;

/**
 * Deeply difference an object against some other, returning the update keys and values
 * @param original
 * @param other
 * @return
 */
declare function diffObject<T extends Record<string, unknown> = Record<string, unknown>>(
  original: object,
  other: object,
): T;

/**
 * A helper function which tests whether an object has a property or nested property given a string key.
 * The string key supports the notation a.b.c which would return true if object[a][b][c] exists
 * @param object   The object to traverse
 * @param key      An object property with notation a.b.c
 *
 * @return         An indicator for whether the property exists
 */
declare function hasProperty(object: object, key: string): boolean;

/**
 * A helper function which searches through an object to retrieve a value by a string key.
 * The string key supports the notation a.b.c which would return object[a][b][c]
 * @param object   The object to traverse
 * @param key      An object property with notation a.b.c
 *
 * @return         The value of the found property
 */
declare function getProperty<TValue = unknown>(object: object, key: string): TValue;

/**
 * A helper function which searches through an object to assign a value using a string key
 * This string key supports the notation a.b.c which would target object[a][b][c]
 *
 * @param object   The object to update
 * @param key      The string key
 * @param value    The value to be assigned
 *
 * @return A flag for whether or not the object was updated
 */
declare function setProperty(object: object, key: string, value: unknown): boolean;

/**
 * Encode a url-like string by replacing any characters which need encoding
 * @param path     A fully-qualified URL or url component (like a relative path)
 * @return         An encoded URL string
 */
declare function encodeURL(path: string): string;

/**
 * Express a timestamp as a relative string
 * @param timeStamp
 * @return
 */
declare function timeSince(timeStamp: Date): string;

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 1] and
 * returns h, s, and v in the set [0, 1].
 *
 * @param  r       The red color value
 * @param  g       The green color value
 * @param  b       The blue color value
 * @return         The HSV representation
 */
declare function rgbToHsv(r: number, g: number, b: number): number[];

/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 *
 * @param  h       The hue
 * @param  s       The saturation
 * @param  v       The value
 * @return         The RGB representation
 */
declare function hsvToRgb(h: number, s: number, v: number): [number, number, number];

/**
 * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
 * @param rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
 * @return      Number in hexadecimal.
 */
declare function rgbToHex(rgb: [number, number, number]): number;

/**
 * Convert a hex color code to an RGB array
 * @param hex    A hex color number
 * @return       An array of [r,g,b] colors normalized on the range of [0,1]
 */
declare function hexToRGB(hex: number): [number, number, number];

/**
 * Convert a hex color code to an RGBA color string which can be used for CSS styling
 * @param hex    A hex color number
 * @param alpha  A level of transparency
 * @return       An rgba style string
 */
declare function hexToRGBAString(hex: number, alpha?: number): string;

/**
 * Convert a string color to a hex integer
 * @param color    The string color
 * @return         The hexidecimal color code
 */
declare function colorStringToHex(color: string): number;

/**
 * Return whether or not a version (v1) is more advanced than some other version (v0)
 * Supports numeric or string version numbers
 * @param v0
 * @param v1
 * @return
 */
declare function isNewerVersion(v1: number | string | null, v0: number | string): boolean;

/**
 * Generate a random ID
 * Generate random number and convert it to base 36 and remove the '0.' at the beginning
 * As long as the string is not long enough, generate more random data into it
 * Use substring in case we generated a string with a length higher than the requested length
 *
 * @param length    The length of the random ID to generate
 * @return          Return a string containing random letters and numbers
 */
declare function randomID(length?: number): string;

/**
 * Parse a UUID into its constituent parts.
 * @param uuid               The UUID to parse.
 * @param [options]          Options to configure parsing behavior.
 * @param [options.relative] A document to resolve relative UUIDs against.
 * @returns Returns the Collection, Document Type, and Document ID to resolve the parent
 *          document, as well as the remaining Embedded Document parts, if any.
 */
declare function parseUuid(uuid: Maybe<string>, options?: { relative?: Maybe<ClientDocument> }): ResolvedUUID;

/**
 * Log a compatibility warning which is filtered based on the client's defined compatibility settings.
 * @param message              The original warning or error message
 * @param [options={}]         Additional options which customize logging
 * @param [options.mode]       A logging level in COMPATIBILITY_MODES which overrides the configured default
 * @param [options.since]      A version identifier since which a change was made
 * @param [options.until]      A version identifier until which a change remains supported
 * @param [options.details]    Additional details to append to the logged message
 * @param [options.stack=true] Include the message stack trace
 * @throws An Error if the mode is ERROR
 */
declare function logCompatibilityWarning(
  message: string,
  options?: {
    mode?: CompatibilityMode;
    since?: number | string;
    until?: number | string;
    details?: string;
    stack?: boolean;
  },
): void;

declare global {
  interface MergeObjectOptions {
    /**
     * Control whether to insert new top-level objects into the resulting structure which do not previously exist
     * in the original object.
     */
    insertKeys?: boolean;
    /**
     * Control whether to insert new nested values into child objects in the resulting structure which did not
     * previously exist in the original object. */
    insertValues?: boolean;
    /**
     * Control whether to replace existing values in the source, or only merge values which do not already exist
     * in the original object.
     */
    overwrite?: boolean;
    /**
     * Control whether to merge inner-objects recursively (if true), or whether to simply replace inner objects
     * with a provided new value.
     */
    recursive?: boolean;
    /**
     * Control whether to apply updates to the original object in-place (if true), otherwise the original object is
     * duplicated and the copy is merged.
     */
    inplace?: boolean;
    /**
     * Control whether strict type checking requires that the value of a key in the other object must match the
     * data type in the original data to be merged.
     */
    enforceTypes?: boolean;
    /**
     * Control whether to perform deletions on the original object if deletion keys are present in the other object.
     */
    performDeletions?: boolean;
  }
}

/**
 * A representation of a color in hexadecimal format.
 * This class provides methods for transformations and manipulations of colors.
 */
declare class Color extends Number {
  /**
   * A CSS-compatible color string.
   * An alias for Color#toString.
   */
  get css(): string;

  /** The color represented as an RGB array. */
  get rgb(): [number, number, number];

  /** The numeric value of the red channel between [0, 1]. */
  get r(): number;

  /** The numeric value of the green channel between [0, 1]. */
  get g(): number;

  /** The numeric value of the blue channel between [0, 1]. */
  get b(): number;

  /** The maximum value of all channels. */
  get maximum(): number;

  /** The minimum value of all channels. */
  get minimum(): number;

  /** Get the value of this color in little endian format. */
  get littleEndian(): number;

  /**
   * The color represented as an HSV array.
   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes r, g, and b are contained in the set [0, 1] and returns h, s, and v in the set [0, 1].
   */
  get hsv(): [number, number, number];

  /* ------------------------------------------ */
  /*  Color Manipulation Methods                */
  /* ------------------------------------------ */

  override toString(radix?: number): HexColorString;

  /**
   * Test whether this color equals some other color
   * @param other Some other color or hex number
   * @returns Are the colors equal?
   */
  equals(other: Color | number): boolean;

  /**
   * Get a CSS-compatible RGBA color string.
   * @param alpha The desired alpha in the range [0, 1]
   * @returns A CSS-compatible RGBA string
   */
  toRGBA(alpha: number): string;

  /**
   * Mix this Color with some other Color using a provided interpolation weight.
   * @param other Some other Color to mix with
   * @param weight The mixing weight placed on this color where weight is placed on the other color
   * @returns The resulting mixed Color
   */
  mix(other: Color, weight: number): Color;

  /**
   * Multiply this Color by another Color or a static scalar.
   * @param other Some other Color or a static scalar.
   * @returns The resulting Color.
   */
  multiply(other: Color | number): Color;

  /**
   * Add this Color by another Color or a static scalar.
   * @param other Some other Color or a static scalar.
   * @returns The resulting Color.
   */
  add(other: Color | number): Color;

  /**
   * Subtract this Color by another Color or a static scalar.
   * @param other Some other Color or a static scalar.
   * @returns The resulting Color.
   */
  subtract(other: Color | number): Color;

  /**
   * Max this color by another Color or a static scalar.
   * @param other Some other Color or a static scalar.
   * @returns The resulting Color.
   */
  maximize(other: Color | number): Color;

  /**
   * Min this color by another Color or a static scalar.
   * @param other Some other Color or a static scalar.
   * @returns The resulting Color.
   */
  minimize(other: Color | number): Color;

  /* ------------------------------------------ */
  /*  Iterator                                  */
  /* ------------------------------------------ */

  /** Iterating over a Color is equivalent to iterating over its [r,g,b] color channels. */
  [Symbol.iterator](): Generator<number>;

  /* ------------------------------------------ */
  /*  Factory Methods                           */
  /* ------------------------------------------ */

  /**
   * Create a Color instance from an RGB array.
   * @param color A color input
   * @returns The hex color instance or NaN
   */
  static from(color: null | string | number | [number, number, number]): Color | number;

  /**
   * Create a Color instance from a color string which either includes or does not include a leading #.
   * @param color A color string
   * @returns The hex color instance
   */
  static fromString(color: string): Color;

  /**
   * Create a Color instance from an RGB array.
   * @param rgb An RGB tuple
   * @returns The hex color instance
   */
  static fromRGB(rgb: [number, number, number]): Color;

  /**
   * Create a Color instance from an HSV array.
   * Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1].
   * @param hsv An HSV tuple
   * @returns The hex color instance
   */
  static fromHSV(hsv: [number, number, number]): Color;
}

type Utils_Color = Color;
declare const Utils_Color: typeof Color;
type Utils_HttpError = HttpError;
declare const Utils_HttpError: typeof HttpError;
declare const Utils_closestPointToSegment: typeof closestPointToSegment;
declare const Utils_colorStringToHex: typeof colorStringToHex;
declare const Utils_debounce: typeof debounce;
declare const Utils_deepClone: typeof deepClone;
declare const Utils_diffObject: typeof diffObject;
declare const Utils_duplicate: typeof duplicate;
declare const Utils_encodeURL: typeof encodeURL;
declare const Utils_expandObject: typeof expandObject;
declare const Utils_fetchJsonWithTimeout: typeof fetchJsonWithTimeout;
declare const Utils_fetchWithTimeout: typeof fetchWithTimeout;
declare const Utils_filterObject: typeof filterObject;
declare const Utils_flattenObject: typeof flattenObject;
declare const Utils_getProperty: typeof getProperty;
declare const Utils_getType: typeof getType;
declare const Utils_hasProperty: typeof hasProperty;
declare const Utils_hexToRGB: typeof hexToRGB;
declare const Utils_hexToRGBAString: typeof hexToRGBAString;
declare const Utils_hsvToRgb: typeof hsvToRgb;
declare const Utils_invertObject: typeof invertObject;
declare const Utils_isEmpty: typeof isEmpty;
declare const Utils_isNewerVersion: typeof isNewerVersion;
declare const Utils_isObjectEmpty: typeof isObjectEmpty;
declare const Utils_lineCircleIntersection: typeof lineCircleIntersection;
declare const Utils_lineLineIntersection: typeof lineLineIntersection;
declare const Utils_lineSegmentIntersection: typeof lineSegmentIntersection;
declare const Utils_lineSegmentIntersects: typeof lineSegmentIntersects;
declare const Utils_logCompatibilityWarning: typeof logCompatibilityWarning;
declare const Utils_mergeObject: typeof mergeObject;
declare const Utils_orient2dFast: typeof orient2dFast;
declare const Utils_parseUuid: typeof parseUuid;
declare const Utils_quadraticIntersection: typeof quadraticIntersection;
declare const Utils_randomID: typeof randomID;
declare const Utils_rgbToHex: typeof rgbToHex;
declare const Utils_rgbToHsv: typeof rgbToHsv;
declare const Utils_setProperty: typeof setProperty;
declare const Utils_timeSince: typeof timeSince;
declare namespace Utils {
  export {
    Utils_Color as Color,
    Utils_HttpError as HttpError,
    Utils_closestPointToSegment as closestPointToSegment,
    Utils_colorStringToHex as colorStringToHex,
    Utils_debounce as debounce,
    Utils_deepClone as deepClone,
    Utils_diffObject as diffObject,
    Utils_duplicate as duplicate,
    Utils_encodeURL as encodeURL,
    Utils_expandObject as expandObject,
    Utils_fetchJsonWithTimeout as fetchJsonWithTimeout,
    Utils_fetchWithTimeout as fetchWithTimeout,
    Utils_filterObject as filterObject,
    Utils_flattenObject as flattenObject,
    Utils_getProperty as getProperty,
    Utils_getType as getType,
    Utils_hasProperty as hasProperty,
    Utils_hexToRGB as hexToRGB,
    Utils_hexToRGBAString as hexToRGBAString,
    Utils_hsvToRgb as hsvToRgb,
    Utils_invertObject as invertObject,
    Utils_isEmpty as isEmpty,
    Utils_isNewerVersion as isNewerVersion,
    Utils_isObjectEmpty as isObjectEmpty,
    Utils_lineCircleIntersection as lineCircleIntersection,
    Utils_lineLineIntersection as lineLineIntersection,
    Utils_lineSegmentIntersection as lineSegmentIntersection,
    Utils_lineSegmentIntersects as lineSegmentIntersects,
    Utils_logCompatibilityWarning as logCompatibilityWarning,
    Utils_mergeObject as mergeObject,
    Utils_orient2dFast as orient2dFast,
    Utils_parseUuid as parseUuid,
    Utils_quadraticIntersection as quadraticIntersection,
    Utils_randomID as randomID,
    Utils_rgbToHex as rgbToHex,
    Utils_rgbToHsv as rgbToHsv,
    Utils_setProperty as setProperty,
    Utils_timeSince as timeSince,
  };
}

declare global {
  interface DocumentConstructionContext<TParent extends Document$1 | null>
    extends DataModelConstructionOptions<TParent> {
    pack?: string | null;
  }

  interface DocumentModificationContext<TParent extends Document$1 | null> {
    /** A parent Document within which these Documents should be embedded */
    parent?: TParent;
    /** Block the dispatch of preCreate hooks for this operation */
    noHook?: boolean;
    /** A Compendium pack identifier within which the Documents should be modified */
    pack?: string | null;
    /** Return an index of the Document collection, used only during a get operation. */
    index?: boolean;
    /** When performing a creation operation, keep the provided _id instead of clearing it. */
    keepId?: boolean;
    /** When performing a creation operation, keep existing _id values of documents embedded within the one being created instead of generating new ones. */
    keepEmbeddedIds?: boolean;
    /** Create a temporary document which is not saved to the database. Only used during creation. */
    temporary?: boolean;
    /** Automatically re-render existing applications associated with the document. */
    render?: boolean;
    /** Automatically create and render the Document sheet when the Document is first created. */
    renderSheet?: boolean;
    /** Difference each update object against current Document data to reduce the size of the transferred data. Only used during update. */
    diff?: boolean;
    /** Merge objects recursively. If false, inner objects will be replaced explicitly. Use with caution! */
    recursive?: boolean;
    /** Whether to delete all documents of a given type, regardless of the array of ids provided. Only used during a delete operation. */
    deleteAll?: boolean;
  }

  type DocumentUpdateContext<TParent extends Document$1 | null> = Omit<
    DocumentModificationContext<TParent>,
    'deleteAll' | 'index' | 'keepId' | 'keepEmbeddedIds' | 'temporary'
  >;

  /* ----------------------------------------- */
  /*  Reusable Type Definitions                */
  /* ----------------------------------------- */

  /** A single point, expressed as an object {x, y} */
  type Point = { x: number; y: number };

  /** A single point, expressed as an array [x,y] */
  type PointArray = [number, number];

  /** A standard rectangle interface. */
  type Rectangle = PIXI.Rectangle | { x: number; y: number; width: number; height: number };

  /* ----------------------------------------- */
  /*  Settings Type Definitions                */
  /* ----------------------------------------- */

  /** A Client Setting */
  interface SettingConfig<TChoices extends Record<string, unknown> | undefined = Record<string, unknown> | undefined> {
    /** A unique machine-readable id for the setting */
    key: string;
    /** The namespace the setting belongs to */
    namespace: string;
    /** The human readable name */
    name: string;
    /** An additional human readable hint */
    hint?: string;
    /** The scope the Setting is stored in, either World or Client */
    scope: 'world' | 'client';
    /** Indicates if this Setting should render in the Config application */
    config: boolean;
    /** This will prompt the user to reload the application for the setting to take effect. */
    requiresReload?: boolean;
    /** The JS Type that the Setting is storing */
    type:
      | NumberConstructor
      | StringConstructor
      | BooleanConstructor
      | ObjectConstructor
      | ArrayConstructor
      | ConstructorOf<DataModel>
      | Function;
    /** For string Types, defines the allowable values */
    choices?: TChoices;
    /** For numeric Types, defines the allowable range */
    range?: this['type'] extends NumberConstructor ? { min: number; max: number; step: number } : never;
    /** The default value */
    default: number | string | boolean | object | (() => number | string | boolean | object);
    /** Executes when the value of this Setting changes */
    onChange?: (choice: TChoices extends object ? keyof TChoices : unknown) => void | Promise<void>;
  }

  interface SettingSubmenuConfig {
    /** The human readable name */
    name: string;
    /** The human readable label */
    label: string;
    /** An additional human readable hint */
    hint: string;
    /** The classname of an Icon to render */
    icon: string;
    /** The FormApplication to render */
    type: SettingsMenuConstructor;
    /** If true, only a GM can edit this Setting */
    restricted: boolean;
  }

  interface SettingsMenuConstructor {
    new (object?: object, options?: Partial<FormApplicationOptions>): FormApplication;
    registerSettings(): void;
  }

  /** A Client Keybinding Action Configuration */
  interface KeybindingActionConfig {
    /** The namespace within which the action was registered */
    namespace?: string;
    /** The human readable name */
    name: string;
    /** An additional human readable hint */
    hint?: string;
    /** The default bindings that can never be changed nor removed. */
    uneditable?: KeybindingActionBinding[];
    /** The default bindings that can be changed by the user. */
    editable?: KeybindingActionBinding[];
    /** A function to execute when a key down event occurs. If True is returned, the event is consumed and no further keybinds execute. */
    onDown?: (context: KeyboardEventContext) => unknown;
    /** A function to execute when a key up event occurs. If True is returned, the event is consumed and no further keybinds execute. */
    onUp?: (context: KeyboardEventContext) => unknown;
    /** If True, allows Repeat events to execute the Action's onDown. Defaults to false. */
    repeat?: boolean;
    /** If true, only a GM can edit and execute this Action */
    restricted?: boolean;
    /** Modifiers such as [ "CONTROL" ] that can be also pressed when executing this Action. Prevents using one of these modifiers as a Binding. */
    reservedModifiers?: ModifierKey[];
    /** The preferred precedence of running this Keybinding Action */
    precedence?: number;
    /** The recorded registration order of the action */
    order?: number;
  }

  interface KeybindingActionBinding {
    /** The KeyboardEvent#code value from https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values */
    key: string | null;
    /** An array of modifiers keys from KeyboardManager.MODIFIER_KEYS which are required for this binding to be activated */
    modifiers: ModifierKey[];
  }

  /** An action that can occur when a key is pressed */
  interface KeybindingAction {
    /** The namespaced machine identifier of the Action */
    action: string;
    /** The Keyboard key */
    key: string;
    /** The human readable name */
    name: string;
    /** Required modifiers */
    requiredModifiers?: ModifierKey[];
    /** Optional (reserved) modifiers */
    optionalModifiers?: ModifierKey[];
    /** The handler that executes onDown */
    onDown?: (...args: unknown[]) => boolean;
    /** The handler that executes onUp */
    onUp?: (...args: unknown[]) => boolean;
    /** If True, allows Repeat events to execute this Action's onDown */
    repeat?: boolean;
    /** If true, only a GM can execute this Action */
    restricted?: boolean;
    /** The registration precedence */
    precedence?: number;
    /** The registration order */
    order?: number;
  }

  /** Keyboard event context */
  interface KeyboardEventContext {
    /** The normalized string key, such as "A" */
    key: string;
    /** The originating keypress event */
    event: KeyboardEvent;
    /** Is the Shift modifier being pressed */
    isShift: boolean;
    /** Is the Control or Meta modifier being processed */
    isControl: boolean;
    /** Is the Alt modifier being pressed */
    isAlt: boolean;
    /** Are any of the modifiers being pressed */
    hasModifiers: boolean;
    /** A list of string modifiers applied to this context, such as [ "CONTROL" ] */
    modifiers: ModifierKey[];
    /** True if the Key is Up, else False if down */
    up: boolean;
    /** True if the given key is being held down such that it is automatically repeating. */
    repeat: boolean;
    /** The executing Keybinding Action. May be undefined until the action is known. */
    action?: string;
  }

  interface ConnectedGamepad {
    /** A map of axes values */
    axes: Map<string, number>;
    /** The Set of pressed Buttons */
    activeButtons: Set<string>;
  }

  type RequestData = object | object[] | string | string[];

  interface SocketRequest {
    /** The type of object being modified */
    type?: string;
    /** The server-side action being requested */
    action?: string;
    /** Data applied to the operation */
    data?: RequestData;
    query?: object;
    /** The type of parent document */
    parentType?: string;
    /** The ID of a parent document */
    parentId?: string;
    /** A Compendium pack name */
    pack?: string;
    /** Additional options applied to the request */
    options?: object;
  }

  interface SocketResponse {
    /** The initial request */
    request: SocketRequest;
    /** An error, if one occurred */
    error?: Error;
    /** The status of the request */
    status?: string;
    /** The ID of the requesting User */
    userId?: string;
    /** Data returned as a result of the request */
    result: Record<string, unknown>[];
  }
}

declare global {
  const CONST: typeof Constants;
  namespace globalThis {
    namespace foundry {
      /** Constant definitions used throughout the Foundry Virtual Tabletop framework. */
      export { Constants as CONST };
      /** Abstract class definitions for fundamental concepts used throughout the Foundry Virtual Tabletop framework. */
      export { Abstract as abstract };
      /** Data schema definitions for data models. */
      export { Data as data };
      /** Document definitions used throughout the Foundry Virtual Tabletop framework. */
      export { Documents as documents };
      /** Package data definitions, validations, and schema. */
      export { Packages as packages };
      /** Utility functions providing helpful functionality. */
      export { Utils as utils };
    }
  }
}

declare global {
  namespace ProseMirror {
    type EditorView = View.EditorView;
    type EditorState = State.EditorState;
    type Plugin = State.Plugin;
    type Step = Transform.Step;
  }
}

declare global {
  type Maybe<T> = T | null | undefined;

  type DeepPartial<T extends object> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
  };

  type CollectionValue<T> = T extends Collection<infer U> ? U : never;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  type AbstractConstructorOf<T> = abstract new (...args: any[]) => T;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  type ConstructorOf<T> = new (...args: any[]) => T;

  type DocumentConstructorOf<T extends foundry.abstract.Document> = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): T;
    updateDocuments(updates?: object[], context?: DocumentModificationContext<T['parent']>): Promise<T[]>;
  };

  type ParentOf<TDataModel> = TDataModel extends DataModel<infer P extends DataModel | null> ? P : never;

  type SchemaOf<TDataModel> = TDataModel extends DataModel<infer _P, infer S extends DataSchema> ? S : never;

  type SetElement<TSet extends Set<unknown>> = TSet extends Set<infer TElement> ? TElement : never;

  type DropFirst<T extends unknown[]> = T extends [unknown, ...infer U] ? U : never;

  type TypeParamOf<T> = T extends TypeWithGeneric<infer U> ? U : never;

  type ValueOf<T extends object> = T[keyof T];

  /** A JSON-compatible value, plus `undefined` */
  type JSONValue = string | number | boolean | object | null | undefined;
}

type TypeWithGeneric<T> = T[];
